<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏花盛开，佑浅浅而归</title>
  
  <subtitle>夏佑随记</subtitle>
  <link href="http://summace.cc/atom.xml" rel="self"/>
  
  <link href="http://summace.cc/"/>
  <updated>2023-08-04T04:27:27.984Z</updated>
  <id>http://summace.cc/</id>
  
  <author>
    <name>夏佑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新博客</title>
    <link href="http://summace.cc/NewBlog/"/>
    <id>http://summace.cc/NewBlog/</id>
    <published>2023-08-03T00:00:00.000Z</published>
    <updated>2023-08-04T04:27:27.984Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="出错。">  <script id="hbeData" type="hbeData" data-hmacdigest="c92cd65995ca5dd8715e666f665675752adec31655389b53c3bac12296192081">4630436162ade97ba2718b7d0c4b3b6377abd193e61de69559b7b58c5eb066f0b3fff512a5e27adcde7972cde5dee91410685dbcb80dbc851910b01340c23ec98fe2c935c79397b786bab884fca09e0f8b9a25259c0a727c10e962939a586534d92e3736311d5416e2de6884b6709199a748f52a253abd531cb12a2d8575690607a3c1f3286facc6fe4848e36c9f830e82ed009003aa969a0904c80511b01b446bad9600457c2e1b901716156cb31f1bd1625c25457a1bb94c6d6a1fc839c1e5ff96dca7d00be7e58dde54751d89aed7a771902e4dd4e836f84f8d31de7f7eff499481deb962946fdce823ad5c854116aa716715fbb835215a83b3d0b4e75c0c768090b5a68f2b409a6fb12957dd9720ddd2e6104361812839dfb74e8da7609fcd65ca7ab2e38eacc85dda5d4dcf72fc158ded5c7440d3481ef92a58bd0c80d402149de07b74499e808d3333e2440f70fa5a275b3610c2a9e8d35496a1af225db96e936709ac09a09907fa879b8663cc64155cca84446f0570fde9c02732ba78f9dd6492b567eaaa154d93bf19234b853b95555d8c1a7140e3c2749b0d80e98035bb637aeee92e770ab8780ffb6d2d4bc030f7137de2868d716ec413c0c72296fda66a37253ce3871bed9d8a0f2c84b597594a536d4855cdbbc2259e44960d4070b5f40adf75b562f76267ec5c6ed0eea3eb13c2b339794ca5a439d5c32ff1ef653fcea15e4ff081a6d5077eb52c78498f452b8f701d7c7526742ff40fa04925f32d22c5aeb62e478463f74507ad99e4f5cb9adb8c7e233341953348d54752562f0bc932a2961fd3e3bfb9168be9095450c45203329c0fd4340e15c358dab7a14aa15e4c51a85395e082110664bfd7ba3e191cd91b1fba98fecfc6c9ff838abaf03be2a3e1ea7a05edc45192afd11df8feda95cb246e12ee44b521ee464ab076a6e6de235f1f81dd06ed10abe5194945bc3b87a957f3c9ae4448bf09ae77ce79b02469d31ad322be7c205d1506f62c0f858d7903767c3f7b63208d0d2d0d899dbc42cbe673064e4b27c55f35b492e47744e80c29845a6bab1046ef8fc9523e3cd65895af6516a085fb8f83ee93bd6eabcb3cb07a1cc638f4cdd80383cf6ddf85c0a075f33a5c550c9faeac18cef2cf1d37bf7bb8cb68c70d7624acf49b3667b478f1ab870e779c747b508a13b74529e92a31ac1cb8794425d174df804dcbcc00a46d191f0c4b290e7bd40dcbd4e008e3fbd111257b0f3b2a5d8f687ca4c7ae8b5fadf61e0cdb98249b178b2077a8dcb0d5f10067f52c6e2a7d3d76520982391e1dbd5311335d7b63a7e562788cf569b72d050f8441b4ca6cff15149ea358c2cf6053358f83c5e39c5680f8f593d200dbdf4a1382737a352156f0a8d67784f92174eabddb8b1e5e14c73d3aaf1b91804b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">123456</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这篇文章被密码保护。</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线性代数学习笔记</title>
    <link href="http://summace.cc/Linear-Algebra/"/>
    <id>http://summace.cc/Linear-Algebra/</id>
    <published>2023-08-02T00:00:00.000Z</published>
    <updated>2023-08-18T01:40:33.355Z</updated>
    
    <content type="html"><![CDATA[<p>学数论学自闭了，感觉线性代数还可以。</p><p>供自己复习用。</p><span id="more"></span><h1><span id="矩阵">矩阵</span></h1><p>一个具有 <span class="math inline">\(n\)</span> 行 <span class="math inline">\(m\)</span> 列元素的矩形阵列，形如：</p><p><span class="math display">\[A=\begin{bmatrix}    a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,m}\\    a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; a_{2,m}\\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    a_{n,1} &amp; a_{n,2} &amp; \cdots &amp; a_{n,m}\\\end{bmatrix}\]</span></p><ul><li>主对角线：<span class="math inline">\(A_{i,i}\)</span> 的元素。</li><li>单位矩阵：主对角线为 <span class="math inline">\(1\)</span>，其余为<span class="math inline">\(0\)</span> 的矩阵，记为 <span class="math inline">\(I\)</span>。</li><li>方阵：行数和列数相等的矩阵。</li><li>同型矩阵：行数和列数分别相等的矩阵。</li></ul><h2><span id="矩阵的运算">矩阵的运算</span></h2><h3><span id="矩阵的加减">矩阵的加减</span></h3><p>只有同型矩阵才可以加减，直接将对应位置加减即可。</p><h3><span id="转置矩阵">转置矩阵</span></h3><p>将矩阵行列互换，记作 <span class="math inline">\(A^{T}\)</span>。</p><h3><span id="矩阵乘法">矩阵乘法</span></h3><p>设 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(N \times K\)</span> 的矩阵，<span class="math inline">\(B\)</span> 是 <span class="math inline">\(K\timesM\)</span> 的矩阵，则乘积 <span class="math inline">\(C\)</span>为：</p><p><span class="math display">\[C_{i,j}=\sum\limits_{i=1}^KA_{i,k}B_{k,j}\]</span></p><h3><span id="方阵的逆">方阵的逆</span></h3><p>若有方阵 <span class="math inline">\(P\)</span> 使方阵 <span class="math inline">\(A\times P=I\)</span>，则称方阵 <span class="math inline">\(P\)</span> 为方阵的逆矩阵。</p><p>逆矩阵不一定存在。</p><h1><span id="行列式">行列式</span></h1><h2><span id="积和式">积和式</span></h2><p>方阵 <span class="math inline">\(A\)</span>的积和式为不同行不同列所有排列 <span class="math inline">\(p_i\)</span>的乘积之和。显然，这样的排列有 <span class="math inline">\(n!\)</span>个。</p><h2><span id="行列式">行列式</span></h2><p>在积和式的基础上，记 <span class="math inline">\(\pi_i\)</span> 为<span class="math inline">\(p_i\)</span>中下标的逆序对个数，那么对于每个 <span class="math inline">\(p_i\)</span> 乘积，累加时赋上符号，若 <span class="math inline">\(\pi_i\)</span> 为偶数，则为正，否则为负。</p><p><span class="math display">\[\det(A)=\sum\limits_{i=1}^{n!}(-1)^{\pi_i}\prod\limits_{j=1}^{n}p_{i,j}\]</span></p><p>一些性质：</p><ul><li>转置矩阵的行列式不变。</li><li>交换任意两行（列）行列式取反。</li><li>某一行（列）乘 <span class="math inline">\(k\)</span>，行列式乘<span class="math inline">\(k\)</span>。</li><li>某一行整体加上另一行，行列式不变。</li></ul><h2><span id="伴随矩阵">伴随矩阵</span></h2><h3><span id="余子式">余子式</span></h3><p>矩阵 <span class="math inline">\(A\)</span> 第 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列的余子式：</p><p><span class="math display">\[M_{i,j}=\det A&#39;_{i,j}\]</span></p><p>其中 <span class="math inline">\(A&#39;_{i,j}\)</span> 表示删除矩阵<span class="math inline">\(A\)</span> 第 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列后所得矩阵。</p><h3><span id="代数余子式">代数余子式</span></h3><p>矩阵 <span class="math inline">\(A\)</span> 第 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列的代数余子式：</p><p><span class="math display">\[C_{i,j}=(-1)^{i+j}M_{i,j}\]</span></p><h3><span id="伴随矩阵">伴随矩阵</span></h3><p>矩阵 <span class="math inline">\(A\)</span> 的伴随矩阵 <span class="math inline">\(\text{adj} A\)</span> 为 <span class="math inline">\(A\)</span> 的余子矩阵的转置矩阵。</p><p><span class="math display">\[\text{adj} A=C^{T}\]</span></p><h3><span id="可逆矩阵">可逆矩阵</span></h3><p>对于可逆矩阵，<span class="math inline">\(A^{-1}=\dfrac{\text{adj}A}{\det A}\)</span>。</p><p>若矩阵不可逆，则 <span class="math inline">\(\det A=0\)</span>。</p><h1><span id="线性空间">线性空间</span></h1><p>若代数系统 <span class="math inline">\((V,+,\cdot,\mathbb{P})\)</span> ，其中 <span class="math inline">\(V\)</span> 为向量集，<span class="math inline">\((V,+)\)</span> 为阿贝尔群，<span class="math inline">\(\mathbb{P}\)</span> 为域，<span class="math inline">\(\cdot\)</span> 为数乘运算，满足以下条件：</p><ol type="1"><li>数乘：<span class="math inline">\(\mathbb{P}\)</span> 中元素 <span class="math inline">\(p\)</span> 与 <span class="math inline">\(V\)</span> 中元素 <span class="math inline">\(v\)</span> 运算结果 <span class="math inline">\(pv\)</span> 在 <span class="math inline">\(V\)</span> 中，且有意义，且满足封闭性。</li><li>数乘对向量和标量都满足加法分配律。</li><li>数乘满足结合律。</li><li>存在标量乘法单位元。</li></ol><p>则称其为线性空间。</p><h2><span id="线性相关与线性无关">线性相关与线性无关</span></h2><p>若向量组 <span class="math inline">\(a_i \in V\)</span> 和任意标量组<span class="math inline">\(k_i\in \mathbb{P}\)</span> 满足 <span class="math inline">\(\sumk_ia_i=\theta\)</span>，则称这组向量线性无关，否则称线性相关。</p><p>零向量与任意向量线性相关。</p><h2><span id="线性基">线性基</span></h2><p>线性空间 <span class="math inline">\(V\)</span>的一个极大线性无关组称为 <span class="math inline">\(V\)</span>的一组<strong>线性基</strong>，简称基。</p><p><span class="math inline">\(V\)</span> 的维数记为 <span class="math inline">\(\dim V\)</span>，为线性基元素个数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学数论学自闭了，感觉线性代数还可以。&lt;/p&gt;
&lt;p&gt;供自己复习用。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP算法与border浅记</title>
    <link href="http://summace.cc/KMP/"/>
    <id>http://summace.cc/KMP/</id>
    <published>2023-08-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:09:54.600Z</updated>
    
    <content type="html"><![CDATA[<p>终于完全明白了困扰多年的 KMP 算法，果然从 border理论理解才是最好的。</p><p>因此写下本文，供自己复习。</p><span id="more"></span><h1><span id="border">border</span></h1><p>首先给出 <span class="math inline">\(\text{border}\)</span>的定义：在字符串 <span class="math inline">\(S\)</span>中，最长的<strong>真</strong>公共前后缀。</p><p>显然，<span class="math inline">\(\text{border}\)</span> 的 <span class="math inline">\(\text{border}\)</span> 也是 <span class="math inline">\(S\)</span> 的一个 <span class="math inline">\(\text{border}\)</span>。</p><p>我们定义 <span class="math inline">\(\text{nxt}[i]\)</span> 为 <span class="math inline">\(S[1\dots i]\)</span> 的 <span class="math inline">\(\text{border}\)</span>，考虑如何快速求 <span class="math inline">\(\text{nxt}\)</span>。</p><p>假设我们现在已知 <span class="math inline">\(\text{nxt}[1\dotsn]\)</span>，想要求出 <span class="math inline">\(\text{nxt}[n+1]\)</span>。</p><p>考虑 <span class="math inline">\(S[n+1]\)</span> 和 <span class="math inline">\(S[\text{nxt}[n]+1]\)</span>是否匹配。如果匹配，那么显然。 <span class="math inline">\(\text{nxt}[n+1]=\text{nxt}[n]+1\)</span>，否则我们继续考虑它是否可以和<span class="math inline">\(\text{nxt}[\text{nxt}[n]]\)</span>匹配。我们一直匹配到成功即可。</p><p>这样可以均摊 <span class="math inline">\(O(n)\)</span> 求出 <span class="math inline">\(\text{nxt}\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&quot; &quot;</span> + S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nxt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = S.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; S[i] != S[j + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(S[i] == S[j + <span class="number">1</span>] &amp;&amp; j + <span class="number">1</span> &lt; i) nxt[i] = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="kmp">KMP</span></h1><p><span class="math inline">\(\text{KMP}\)</span>是用来快速匹配字符串的算法。</p><p>给定模式串 <span class="math inline">\(S\)</span>，文本串 <span class="math inline">\(T\)</span>，求 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(T\)</span> 中所有匹配。</p><p>记 <span class="math inline">\(S\)</span> 长度为 <span class="math inline">\(s\)</span>，<span class="math inline">\(T\)</span>长度为 <span class="math inline">\(t\)</span>。</p><p>我们将 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(\#\)</span> 和 <span class="math inline">\(T\)</span> 拼在一起，形成了 <span class="math inline">\(S\#T\)</span> 的新字符串。我们求出来这个字符串的<span class="math inline">\(\text{nxt}\)</span>。</p><p>之后我们从 <span class="math inline">\(s+1\)</span> 开始（即从 <span class="math inline">\(T\)</span> 开始）遍历 <span class="math inline">\(\text{nxt}\)</span>。如果 <span class="math inline">\(\text{nxt}[i] =s\)</span>，那么这是一个成功的匹配。</p><p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于完全明白了困扰多年的 KMP 算法，果然从 border
理论理解才是最好的。&lt;/p&gt;
&lt;p&gt;因此写下本文，供自己复习。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线段树浅记</title>
    <link href="http://summace.cc/Segment-Tree/"/>
    <id>http://summace.cc/Segment-Tree/</id>
    <published>2023-07-23T00:00:00.000Z</published>
    <updated>2023-09-02T02:07:02.743Z</updated>
    
    <content type="html"><![CDATA[<p>系统复盘了一下线段树，发现网上现有博客鲜有将线段树各种操作一步一步讲明白的，故结合自己理解写此文。</p><p>应该会持续更新。</p><span id="more"></span><h1><span id="目录">目录</span></h1><!-- toc --><ul><li><a href="#线段树">线段树</a><ul><li><a href="#结构">结构</a></li><li><a href="#信息的上传">信息的上传</a></li><li><a href="#建树">建树</a></li><li><a href="#单点修改">单点修改</a></li><li><a href="#区间查询">区间查询</a></li><li><a href="#区间修改与懒标记">区间修改与懒标记</a></li></ul></li><li><a href="#线段树的进阶用法">线段树的进阶用法</a><ul><li><a href="#维护区间平方和">维护区间平方和</a></li><li><a href="#区间乘与区间加">区间乘与区间加</a></li><li><a href="#区间开根">区间开根</a></li><li><a href="#维护前前缀和">维护前前缀和</a></li><li><a href="#区间加等差数列">区间加等差数列</a></li><li><a href="#维护区间最大子段和">维护区间最大子段和</a></li></ul></li><li><a href="#线段树的本质">线段树的本质</a></li><li><a href="#线段树的常用技巧">线段树的常用技巧</a><ul><li><a href="#动态开点">动态开点</a></li><li><a href="#标记永久化">标记永久化</a></li><li><a href="#线段树二分">线段树二分</a></li></ul></li><li><a href="#进阶线段树">进阶线段树</a><ul><li><a href="#值域线段树">值域线段树</a></li><li><a href="#扫描线">扫描线</a><ul><li><a href="#线段树维护矩形面积并">线段树维护矩形面积并</a></li><li><a href="#本质">本质</a></li></ul></li><li><a href="#李超线段树">李超线段树</a></li><li><a href="#zkw-线段树">zkw 线段树</a><ul><li><a href="#结构-1">结构</a></li><li><a href="#建树-1">建树</a></li><li><a href="#单点修改-区间查询">单点修改、区间查询</a></li><li><a href="#区间修改-区间查询">区间修改、区间查询</a></li></ul></li></ul></li><li><a href="#多线段树操作">多线段树操作</a><ul><li><a href="#线段树合并">线段树合并</a></li><li><a href="#线段树分裂">线段树分裂</a></li></ul></li><li><a href="#主席树">主席树</a><ul><li><a href="#简介">简介</a></li><li><a href="#结构-2">结构</a></li><li><a href="#操作">操作</a></li><li><a href="#区间修改">区间修改</a></li></ul></li><li><a href="#题目随解">题目随解</a></li></ul><!-- tocstop --><h1><span id="线段树">线段树</span></h1><p>先来看一个经典问题：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 x v</code>：给 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>考虑最朴素的暴力：对于 <span class="math inline">\(1\)</span>操作，直接在数组上更改。对于每次 <span class="math inline">\(2\)</span>操作，我们暴力遍历一遍整个数组。这样单次修改复杂度是 <span class="math inline">\(O(1)\)</span>，但是查询复杂度是 <span class="math inline">\(O(n)\)</span>，最坏时间复杂度 <span class="math inline">\(O(nq)\)</span>，比较爆炸。</p><p>线段树作为一种基础的高级数据结构，具有单次修改、查询均为 <span class="math inline">\(O(\log n)\)</span>的优秀复杂度。这时候运用线段树，就比较好解决这个问题了。</p><h2><span id="结构">结构</span></h2><p>我们先来说一下线段树的结构。</p><figure><img src="https://cdn.luogu.com.cn/upload/image_hosting/gmqvut8k.png" alt="线段树"><figcaption aria-hidden="true">线段树</figcaption></figure><p>考虑现在有一段长度为 <span class="math inline">\(5\)</span> 的区间<span class="math inline">\([1,5]\)</span>，我们递归地每次分成两半。</p><p>第一层：<span class="math inline">\([1,5]\)</span>，第二层：<span class="math inline">\([1,3],[4,5]\)</span>，以此类推……</p><p>现在 <span class="math inline">\(d_1\)</span> 就记录着区间 <span class="math inline">\([1,5]\)</span> 的信息，<span class="math inline">\(d_2\)</span> 记录着 <span class="math inline">\([1,3]\)</span>的信息，以此类推。这个信息可以是多种多样的，根据本题的题意，我们可以记录“区间和”这个信息。此时，<span class="math inline">\(d_1\)</span> 就表示着区间 <span class="math inline">\([1,5]\)</span> 的和为 <span class="math inline">\(60\)</span>。</p><p>显然，我们现在的 <span class="math inline">\(d\)</span>数组构成了一个二叉树型结构，<span class="math inline">\(d_1\)</span>的儿子是 <span class="math inline">\(d_2\)</span> 和 <span class="math inline">\(d_3\)</span>，<span class="math inline">\(d_2\)</span> 的儿子是 <span class="math inline">\(d_4\)</span> 和 <span class="math inline">\(d_5\)</span>。那么根据二叉树的性质，我们很容易可以知道，若父亲节点的编号是<span class="math inline">\(k\)</span>，那么它的左儿子的节点编号应该是<span class="math inline">\(2k\)</span>，右儿子的节点编号应该是 <span class="math inline">\(2k+1\)</span>。</p><p>这样，一颗线段树的基本结构就出来了。</p><p>考虑一下我们需要维护哪些信息？首先，区间和 <span class="math inline">\(sum\)</span>。其次，我们需要维护当前节点所维护区间的左右端点<span class="math inline">\(l,r\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>哎？你这个 <span class="math inline">\(tr\)</span> 数组怎么开了 <span class="math inline">\(4\)</span> 倍的空间啊？</p><p>我们考虑这颗线段树的结构，一个长度为 <span class="math inline">\(n\)</span> 的区间最多可以有 <span class="math inline">\(\log(n)\)</span> 层。求和的结果近似于 <span class="math inline">\(4n\)</span>，因此需要开够 <span class="math inline">\(4\)</span> 倍空间。</p><blockquote><p>注：无特殊说明外，本文 <span class="math inline">\(\log\)</span> 均为<span class="math inline">\(\log_2\)</span>。</p></blockquote><h2><span id="信息的上传">信息的上传</span></h2><p>然而，我们现在的线段树只是一颗线段树，跟原来的序列没有啥关系啊？</p><p>考虑这颗线段树的叶子节点。我们发现叶子节点维护的区间都只有一个数，那么这个就对应着我们原序列的值。也就是说，左右端点均为<span class="math inline">\(i\)</span> 的线段树节点，其区间和就是 <span class="math inline">\(a_i\)</span> 的值。</p><p>然后我们需要让整棵树都维护正确的信息，这时候就需要我们把信息由下到上地更新。我们记载的信息是区间和，那么显然，父亲节点的信息就是儿子节点信息之和，也就是说：<span class="math inline">\(tr[k].sum=tr[ls(k)].sum+tr[rs(k)].sum\)</span>。</p><blockquote><p>注：下文将用 <span class="math inline">\(tr\)</span> 代替 <span class="math inline">\(d\)</span>。</p></blockquote><p>这里的 <span class="math inline">\(ls(k) = 2k, rs(k) =2k+1\)</span>，分别表示了当前节点的左右儿子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="comment">//常用技巧，使用#define会让你的代码更美丽</span></span><br><span class="line"><span class="comment">//根据基本的位运算常识，k&lt;&lt;1=2k, k&lt;&lt;1|1=2k+1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="建树">建树</span></h2><p>著名感情学家鸭子曾经说过：我们要有所建树。不建树是一个线段树题目中常见的**错误。</p><p>考虑我们是怎么讲述一颗线段树的结构的？<span class="math inline">\(d_1\)</span>记录着整个区间的信息，然后每次将区间分成两半，分别记录着左右两半区间的信息……</p><p>那么参照这个思想，我们就可以建树了。从 <span class="math inline">\(d_1\)</span>出发，依次建立左右儿子的初始信息，然后 <span class="math inline">\(pushup\)</span>，把下层的节点信息上传到上层。对于叶子节点，此时显然一定有<span class="math inline">\(tr[k].l=tr[k].r\)</span>，<span class="math inline">\(tr[k].sum=a[l]\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].l = l;</span><br><span class="line">    tr[k].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度显然 <span class="math inline">\(O(n)\)</span>。</p><h2><span id="单点修改">单点修改</span></h2><p>好了，现在树也建好了，是时候干点操作相关的事情了。单点修改！</p><p>这个东西有点像二分。由于我们只修改一个点，那么我们只需要每次看看这个点在左右两半区间的那边，然后一直到叶子的时候把它修改了，再更新一下整棵树就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].l == tr[k].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">update</span>(ls, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们最多跳 <span class="math inline">\(\log(n)\)</span>次，因此单点修改的时间复杂度是 <span class="math inline">\(O(\logn)\)</span> 的。</p><h2><span id="区间查询">区间查询</span></h2><p>那么接下来解决最后一个问题：区间查询。</p><figure><img src="https://cdn.luogu.com.cn/upload/image_hosting/ybjuqqrm.png" alt="线段树"><figcaption aria-hidden="true">线段树</figcaption></figure><p>再看一眼这张图。如果我们要查询区间 <span class="math inline">\([2,5]\)</span>的值，那么比较理想的状态应该是什么？</p><p>应该是，我们每次找到可以被询问区间包含的<strong>极大</strong>区间，最后将所有区间的信息相加。</p><p>太抽象了？让我们具体看看。</p><p>从第一层开始：<span class="math inline">\([1,5]\)</span>的信息显然太大了，我们用不了，那么往下面找。</p><p>现在我们有区间 <span class="math inline">\([1,3]\)</span> 和 <span class="math inline">\([4,5]\)</span> 的信息。我们发现 <span class="math inline">\([2,5]\)</span> 完全包含 <span class="math inline">\([4,5]\)</span>，也就是说 <span class="math inline">\([4,5]\)</span>的信息可以被我们利用，那么就算上它的区间和。那啥叫极大呢？我们发现利用<span class="math inline">\([4,5]\)</span> 的信息显然比分别利用 <span class="math inline">\([4,4]\)</span> 和 <span class="math inline">\([5,5]\)</span>要更优。意思就是：我们能用父亲的信息，就不用儿子的信息。</p><p>继续，我们现在还差 <span class="math inline">\([2,3]\)</span>的信息没解决。由于右边已经完成了，那么我们直接在左边找就可以。第三层是<span class="math inline">\([1,2]\)</span> 和 <span class="math inline">\([3,3]\)</span>，其中我们可以用 <span class="math inline">\([3,3]\)</span> 的信息，把它加上。</p><p>然后我们继续往下找，发现了 <span class="math inline">\([1,1]\)</span>和 <span class="math inline">\([2,2]\)</span>，其中我们可以利用 <span class="math inline">\([2,2]\)</span> 的信息，那就把它加上。</p><p>最后，我们发现区间 <span class="math inline">\([2,5]\)</span>实际上被拆成了 <span class="math inline">\([2,2] \cup [3,3]\cup[4,5]\)</span>，我们所求的答案自然就是这几个节点的信息之和。</p><p>那么考虑一下我们应该怎么写代码：如果当前节点的区间被询问区间完全包含，那么直接加上这个区间的信息。否则，如果查询区间的左端点在左儿子内，就到左儿子内中继续查询；如果查询区间的右端点在右儿子内，就到右儿子内中继续查询。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r) <span class="keyword">return</span> tr[k].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += <span class="built_in">query</span>(ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += <span class="built_in">query</span>(rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来分析一下时间复杂度：由于线段树只有 <span class="math inline">\(\log(n)\)</span> 层，那么我们也只需要询问 <span class="math inline">\(O(\log n)\)</span> 次，单次区间查询时间复杂度是<span class="math inline">\(O(\log n)\)</span>。</p><h2><span id="区间修改与懒标记">区间修改与懒标记</span></h2><p>那么现在我们把这个问题进阶一下：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <span class="math inline">\([l,r]\)</span> 的每个元素加上 <span class="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>现在，我们由单点修改变成了区间修改。</p><p>问题在哪？我们每次修改，如果一个区间被修改区间包含，那么以它为根的整棵子树都要被修改，时间复杂度到了<span class="math inline">\(O(n)\)</span>，这是我们无法接受的。</p><p>哎？同样是涉及到区间，那为啥区间查询的复杂度很对，但是区间修改就很寄呢？</p><p>我们发现，区间查询的时候，如果一个节点被用到了，那么它的儿子就不会在被查询，因此时间复杂度可以到<span class="math inline">\(O(\logn)\)</span>。那我们能不能类比区间查询，让区间修改也这样呢？</p><p>这个时候就需要懒标记(lazy tag)出场了。</p><p>懒标记，顾名思义，是为了偷懒用的标记。</p><p>怎么偷懒呢？当我们遇到一个被修改区间完全包含的区间的时候，我们就给这个节点打上一个标记，意思是：我这个节点的后代应该被这个标记影响，但是我现在先不往下传。<del>（我知道你很急，但是你先别急）</del>到我什么时候要用到这个节点的后代的时候，我再把标记传下去。</p><p>这样的话，我们就可以保证区间修改的时间复杂度为 <span class="math inline">\(O(\log n)\)</span>。</p><p>那么具体怎么实现呢？</p><p>当我们区间修改遇到一个整的区间时，我们选择仅更改当前的节点的值，并给它打上懒标记。以区间和为例，我们更改当前节点的值显然应当是<span class="math inline">\(v*(tr[k].r-tr[k].l+1)\)</span>，此时我们把当前节点的<span class="math inline">\(tag\)</span> 加上 <span class="math inline">\(v\)</span>，表示我后面的后代应当被加 <span class="math inline">\(v\)</span>。</p><p>然后我们想想怎么把标记下放。显然我们只需要把标记分别赋给他的两个儿子，然后把当前节点的标记清零就可以了。考虑一下，那些操作需要把标记下放？</p><p>由于需要用到后代的操作都需要下方，所以显然查询和修改都需要提前下放标记。显然，标记的下放必须在操作之前。</p><p>那么我们就可以开始写代码了。首先先单独写一个下放标记的函数<code>pushdown</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[ls].tag += tr[k].tag;</span><br><span class="line">    tr[rs].tag += tr[k].tag;</span><br><span class="line">    tr[ls].sum += (tr[ls].r - tr[ls].l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    tr[rs].sum += (tr[rs].r - tr[rs].l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在更新一下查询和修改的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum += (tr[k].r - tr[k].l + <span class="number">1</span>) * v;</span><br><span class="line">        tr[k].tag += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[k].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += <span class="built_in">query</span>(ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += <span class="built_in">query</span>(rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="线段树的进阶用法">线段树的进阶用法</span></h1><p>目前我们已经解决了线段树维护区间和的问题。线段树维护区间极值也很简单，只需要在原来的代码上稍作修改即可。但是，作为十分美丽的数据结构，线段树可以维护的东西远不止这些。接下来让我们看看线段树更为进阶的用法。</p><h2><span id="维护区间平方和">维护区间平方和</span></h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <span class="math inline">\([l,r]\)</span> 的每个元素加上 <span class="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span> 的平方和，即 <span class="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这时候就需要我们思考，线段树要维护某些东西具体需要改什么。</p><p>原本有一段需要修改的区间 <span class="math inline">\(a_l, a_{l+1},..., a_r\)</span>。我们需要维护的东西是 <span class="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>。</p><p>考虑我们现在对这段东西整体加上 <span class="math inline">\(v\)</span>，那么我们的答案就变成了 <span class="math inline">\(\sum\limits_{i=l}^{r}(a_i+v)^2\)</span>。</p><p>运用我们初中就学过的完全平方公式：</p><p><span class="math inline">\(\sum\limits_{i=l}^{r}(a_i+v)^2 =\sum\limits_{i=l}^{r}(a_i^2+2a_iv+v^2) =\sum\limits_{i=l}^{r}a_i^2+2v\sum\limits_{i=l}^{r}a_i+(r-l+1)v^2\)</span></p><p>我们发现前面的 <span class="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>就是我们原先的值，而最后的 <span class="math inline">\((r-l+1)v^2\)</span> 可以直接算出来，中间的 <span class="math inline">\(2v\sum\limits_{i=l}^{r}a_i\)</span>只需要多维护一个区间和就可以了。</p><p>那么，这道题我们就需要维护两个值：区间平方和、区间和。修改的时候按照公式中的修改即可。</p><p>思考：区间方差。</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <span class="math inline">\([l,r]\)</span> 的每个元素加上 <span class="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span> 的方差。</p><p>方差：<span class="math inline">\(\sigma^2=\dfrac{1}{n}\sum\limits_{i=1}^{n}(x_i-\overlinex)^2\)</span></p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><h2><span id="区间乘与区间加">区间乘与区间加</span></h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <span class="math inline">\([l,r]\)</span> 的每个元素加上 <span class="math inline">\(v\)</span>；</p><p><code>2 l r v</code>：给区间 <span class="math inline">\([l,r]\)</span> 的每个元素乘上 <span class="math inline">\(v\)</span>；</p><p><code>3 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这不好做？我直接开两个 <span class="math inline">\(tag\)</span>，分别维护加法和乘法懒标记，结果一合并不就行了！</p><p>等等，你先别急。你乘法和加法分别统计真的对吗？</p><p>例如，我们当前的数是 <span class="math inline">\(2\)</span>，对当前的数分别 <span class="math inline">\(\times 3,+2,\times 4\)</span>，答案应当是 <span class="math inline">\((2\times 3+2)\times4=32\)</span>。但是如果我们分别计算 <span class="math inline">\(multitag=3\times4=12,plustag=2\)</span>，答案就会变成 <span class="math inline">\(2\times12+2=26\)</span> 或者 <span class="math inline">\((2+2)\times 12=48\)</span>。</p><p>这是因为我们加法和乘法之间是有运算顺序的，因此我们不能简单地直接计算。</p><p>那有没有什么办法呢？当然有！我们在小学就学过一个伟大的东西，叫做乘法的分配律！</p><p>假设我们当前的节点有 <span class="math inline">\(multitag\)</span> 和<span class="math inline">\(plustag\)</span> 两个 <span class="math inline">\(tag\)</span>，那么当前节点的值应当是 <span class="math inline">\((x\timesmultitag+plustag)\)</span>，现在对这个节点进行 <span class="math inline">\(\times v\)</span> 的操作就会变成 <span class="math inline">\((x\times multitag+plustag)\times v=x\timesmultitag\times v + plustag\times v\)</span>。</p><p>于是，我们正常维护 <span class="math inline">\(multitag\)</span>，并且额外更新 <span class="math inline">\(plustag\)</span>，这样就可以了。</p><h2><span id="区间开根">区间开根</span></h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：令区间 <span class="math inline">\([l,r]\)</span> 的每个元素 <span class="math inline">\(x\)</span> 变成 <span class="math inline">\(\lfloor\sqrt{x}\rfloor\)</span>；</p><p><code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5,1\leq a_i\leq10^{18}\)</span>。</p></blockquote><p>有没有发现这次的题目多了一个数据范围？</p><p>既然 <span class="math inline">\(a_i\leq10^{18}\)</span>，我们发现<strong>至多进行 <span class="math inline">\(6\)</span> 次 <span class="math inline">\(1\)</span> 操作</strong>，当前的数就会变成 <span class="math inline">\(1\)</span>。变成 <span class="math inline">\(1\)</span> 之后自然之后的操作都是无效的操作。</p><p>那么，我们在更改的时候可以暴力更改当前区间的数，并记录当前区间的最大值。如果最大值小于等于<span class="math inline">\(1\)</span>，那么就可以停止这个区间的更改了。</p><p>这样，查询的复杂度是不变的单次 <span class="math inline">\(O(\logn)\)</span>，我们来分析一下修改的时间复杂度。</p><p>不将值域局限在 <span class="math inline">\(10^{18}\)</span>内，我们考虑一个数会被更改多少次：</p><p><span class="math inline">\(a^{\left(\frac{1}{2}\right)^x}&lt;2\)</span>。</p><p>这是一个两层不等式，想得到 <span class="math inline">\(x\)</span>我们需要取两次对数，因此我们每个数最多会被更改 <span class="math inline">\(O(\log\log a)\)</span> （<span class="math inline">\(a\)</span> 为 <span class="math inline">\(a_i\)</span>的最大值）次。考虑我们暴力更改就相当于是单点修改，那么每对一个元素修改的复杂度就是<span class="math inline">\(O(\log n)\)</span> 的。我们一共有 <span class="math inline">\(n\)</span> 个元素，每个元素修改一次的复杂度是<span class="math inline">\(O(\log n)\)</span>，每个元素最多会被更改<span class="math inline">\(O(\log\log a)\)</span>次，那么，总的时间复杂度就是 <span class="math inline">\(O(n\logn\log\log a)\)</span>。单次的复杂度均摊是 <span class="math inline">\(O(\log n\log\log a)\)</span>的。可以通过本题。</p><h2><span id="维护前前缀和">维护前前缀和</span></h2><blockquote><p>前缀和：<span class="math inline">\(S_i=\sum\limits_{k=1}^{i}a_k\)</span>；</p><p>前前缀和：<span class="math inline">\(SS_i=\sum\limits_{k=1}^{i}S_i\)</span>。</p><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 x v</code>：将 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>；</p><p><code>2 x</code>：查询 <span class="math inline">\(SS_x\)</span>。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>我们现在有三个数组：原数组 <span class="math inline">\(a\)</span>，前缀和数组 <span class="math inline">\(S\)</span>，前前缀和数组 <span class="math inline">\(SS\)</span>。</p><p>对于 <span class="math inline">\(1\)</span> 操作，我们要用到的是<span class="math inline">\(a\)</span>。对于 <span class="math inline">\(2\)</span> 操作，我们要用到的是 <span class="math inline">\(SS\)</span>。那么，我们为什么不选择一个中间商<del>赚个差价</del>方便我们对两边都能维护到呢？</p><p>因此，我们可以维护前缀和数组 <span class="math inline">\(S\)</span>，对于操作 <span class="math inline">\(2\)</span>，答案即是从 <span class="math inline">\(1\)</span> 开始的区间和。对于操作 <span class="math inline">\(1\)</span>，我们只需要让从当前位置开始到 <span class="math inline">\(n\)</span> 的区间加上 <span class="math inline">\(v\)</span> 即可。</p><h2><span id="区间加等差数列">区间加等差数列</span></h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 l r d k</code>：令区间 <span class="math inline">\([l,r]\)</span> 的每个元素 <span class="math inline">\(a_i\)</span> 加上以 <span class="math inline">\(d\)</span> 为首项、<span class="math inline">\(k\)</span> 为公差的等差数列 <span class="math inline">\(\{c\}\)</span> 的 <span class="math inline">\(c_i\)</span>。 <code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span> 的和。 <span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>区间加的数不是同一个数，怎么办？</p><p>考虑一下等差数列的性质。我们没有必要知道每一个数是什么，我们只需要知道首项和公差，就可以推出数列的任意一项以及数列的和。那我们不妨用线段树维护加的等差数列的首项和公差。</p><h2><span id="维护区间最大子段和">维护区间最大子段和</span></h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 x v</code>：将 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span> 内的最大子段和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这咋做？</p><p>线段树保证复杂度的关键一步是要保证可以快速、正确地合并。这题单点修改是容易的，关键在于如何让信息快速合并。</p><p>我们思考一下合并区间最大子段和时，可能有哪些情况：</p><ol type="1"><li>全部在左半区间。</li><li>全部在右半区间。</li><li>横跨左右区间。</li></ol><p>我们显然是要维护当前区间的最大子段和的。对于 <span class="math inline">\(1\)</span> 情况和 <span class="math inline">\(2\)</span> 情况，直接合并就可以了。关键是 <span class="math inline">\(3\)</span> 情况该如何合并。</p><p>我们考虑横跨左右区间实际上就是左半区间右端点开始的区间最大子段和，和右半区间左端点开始的区间最大子段和合并。那我们不妨对每个节点多维护两个信息：以右端点开始的区间最大子段和（记作<span class="math inline">\(S[k]_r\)</span>），和以左端点开始的区间最大子段和（记作<span class="math inline">\(S[k]_l\)</span>）。这样，我们就可以做到快速算出区间最大子段和了。</p><p>不过问题在于，我们新维护的这两个值也需要考虑合并之后该怎么办。只考虑<span class="math inline">\(S[k]_l\)</span>，这个时候有两种情况：</p><ol type="1"><li><span class="math inline">\(S[k]_l\)</span> 是 <span class="math inline">\(S[ls(k)]_l\)</span>。</li><li><span class="math inline">\(S[k]_l\)</span>的右端点跨到了右区间，答案变成 <span class="math inline">\(sum_k+S[rs]_l\)</span>。</li></ol><p>而且只有这两种情况。（思考一下，为什么？）</p><p>现在所有问题已经解决，我们就可以快速维护了。</p><p>思考：<span class="math inline">\(1\)</span>操作改为区间加怎么做？</p><h1><span id="线段树的本质">线段树的本质</span></h1><p>我们发现，线段树可以维护许多东西：区间和、区间极值……通过一些手法，我们也可以维护诸如区间最大子段和的东西。</p><p>那么，究竟什么样的信息才可以被维护呢？</p><p>首先，这个信息必须是<strong>可被快速合并的</strong>。其次，这个信息必须<strong>满足结合律</strong>。因为我们在合并的时候其实是并不关心信息之间的顺序的，这就要求其必须满足结合律。那么可以看出，这些信息实际上构成了一个半群。</p><p>以上情况都是在单点修改的时候。那么区间修改呢？为什么刚刚线段树维护区间最大子段和没办法区间修改呢？</p><p>在区间修改的时候，为了保证线段树复杂度的正确性，我们势必要引入标记。那么，这个标记也必须满足一定的性质。</p><p>首先，这个标记必须是<strong>可被快速合并的</strong>。其次，这个标记必须<strong>满足结合律</strong>。第三，这个标记必须<strong>可被快速作用到信息上</strong>。可以看出，标记实际上构成了一个幺半群。</p><p>因此，我们在考虑线段树维护某些东西的时候，一方面要考虑如何维护信息，另一方面要考虑如何维护标记。</p><p>有关更多这部分的内容，可以看<a href="https://_rqy.blog.uoj.ac/blog/8105">_rqy的博客</a>。</p><h1><span id="线段树的常用技巧">线段树的常用技巧</span></h1><h2><span id="动态开点">动态开点</span></h2><p>有的时候，面对庞大的数据范围，我们没办法开如此大的空间。这个时候，我们就需要动态开点线段树了。</p><p>动态开点线段树，顾名思义，即对于整颗线段树，我们并不将它直接建出来，而是到用到某个节点了在进行新建。</p><p>因此，我们就直接不建树，在 update 和 query的时候，如果当前没有节点，那么我们就新建一个。</p><p>不过，显然此时我们再沿用之前 <span class="math inline">\(2k\)</span>为左儿子编号，<span class="math inline">\(2k+1\)</span>为右儿子编号的做法不再合适。我们需要额外记录当前节点左右儿子的编号。</p><p>考虑到一次操作最多会访问 <span class="math inline">\(O(\logn)\)</span> 个节点，那么总空间复杂度为 <span class="math inline">\(O(q\log n)\)</span>。</p><p>考虑到一颗线段树的节点数是 <span class="math inline">\(2n-1\)</span>，因此动态开点时只需开 <span class="math inline">\(2\)</span> 倍空间即可。</p><blockquote><p>思考：为什么普通线段树是 <span class="math inline">\(4\)</span>倍空间？</p><p>原因：在普通线段树 pushdown 的时候，叶子节点会多 pushdown一次，导致线段树层数 <span class="math inline">\(+1\)</span>，因此需要多开 <span class="math inline">\(2n\)</span> 个节点。</p></blockquote><p>因此我们只需要对应更改一下 pushdown 和 update 的代码即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg_Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum, tag;</span><br><span class="line">    <span class="type">int</span> lson, rson;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    tr[k].tag += v;</span><br><span class="line">    tr[k].sum += v * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f</span>(ls, l, mid, tr[k].tag);</span><br><span class="line">    <span class="built_in">f</span>(rs, mid + <span class="number">1</span>, r, tr[k].tag);</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f</span>(k, l, r, v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid+ <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们初始时需要建立第一个节点。值得注意的是：update 和 f 函数中的<span class="math inline">\(k\)</span>必须加取地址符，这是为了使儿子信息在父亲节点中被更新。</p><h2><span id="标记永久化">标记永久化</span></h2><p>当数据范围较大、或者 pushdown、pushup代价过高时，可以考虑标记永久化。</p><p>我们知道线段树一个重要的部分是懒标记，而 pushdown就是为了下放标记而存在的。而标记永久化则是不进行标记的下放，直接永久记录在该节点上。当我们需要访问某节点时，叠加所有在它到根节点路径的标记即可。</p><p>然而值得注意的是，并不是所有的标记都能永久化。除了要满足标记本身需要满足的条件之外，还需要满足<strong>交换律</strong>。</p><p>标记永久化并没有时空复杂度的提升，但是可以优化时间常数。某些情况下，正常下放标记不能保证正确性，因此必须标记永久化。</p><p>标记永久化可以保证了当前节点子树的更新，但是与之相对的，当前节点到根我们需要额外维护：从根到该节点，每次取当前节点维护区间与修改区间的交集，进行更新。</p><p>下面是动态开点+标记永久化的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].tag += v);</span><br><span class="line">    tr[k].sum += v * (<span class="built_in">min</span>(R, r) - <span class="built_in">max</span>(L, l) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[k].sum +(r - l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    <span class="type">int</span> res = (<span class="built_in">min</span>(R, r) - <span class="built_in">max</span>(L, l) + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res += <span class="built_in">query</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res += <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r , L, R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="线段树二分">线段树二分</span></h2><p>线段树本身看起来就是个很二分的结构。那么我们不妨直接利用这个结构特性来进行二分。</p><p>类比于我们在线段树基本操作中的单点修改，我们发现这个其实就是一个不断二分的过程。</p><p>这样的时间复杂度可以维持在 <span class="math inline">\(O(\logn)\)</span>。</p><h1><span id="进阶线段树">进阶线段树</span></h1><h2><span id="值域线段树">值域线段树</span></h2><p>还是先来看一个问题：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(q\)</span> 次询问。</p><p>每次询问给定 <span class="math inline">\(k\)</span>，求序列第 <span class="math inline">\(k\)</span> 小。</p><p><span class="math inline">\(1\leq n,q\leq 10^5,1\leq a_i\leq10^9\)</span>。</p></blockquote><p>想要解决这个问题，我们需要用到“值域线段树”。</p><p>值域线段树，也被称作“权值线段树”，但是值域线段树这个名字更加严谨一点。</p><p>佛说：诞生了数组之后，就诞生了桶。同样，诞生了线段树之后，就诞生了值域线段树。</p><p>具体来说，值域线段树也是一种线段树，但是它维护的范围从 <span class="math inline">\(n\)</span> 变成了整个值域（因此需要<a href="#动态开点">动态开点</a>），而维护的东西则是一段区间内数的出现次数。形象化地说，就是在桶上建立了一颗线段树。</p><p>那么想想如何查询第 <span class="math inline">\(k\)</span>小。通过刚才线段树二分的思想，我们每次将当前节点左右儿子的值与 <span class="math inline">\(k\)</span>比较，然后二分地寻找应该存在的地方。</p><figure><img src="https://cdn.luogu.com.cn/upload/image_hosting/zzzzpqlt.png" alt="值域线段树"><figcaption aria-hidden="true">值域线段树</figcaption></figure><p>如图，对于序列 <span class="math inline">\(\{1,2,3,4,2,3,4,3,4,4\}\)</span>，我们可以建立如上值域线段树。例如我们现在要查询<span class="math inline">\(k=5\)</span>，红色的节点和边就是我们查询的路径。值得注意的是，我们的<span class="math inline">\(k\)</span> 应该是在当前节点区间内的 <span class="math inline">\(k\)</span>，这意味着如果我们递归到了右子树，需要减去左子树的值。</p><p>类似地，值域线段树也支持单点修改，以及查询某个数出现个数等等。</p><p>注意到，普通值域线段树只支持全局查询。若需要区间查询，则需要对值域线段树进行可持久化，即<a href="#主席树">主席树</a>。</p><h2><span id="扫描线">扫描线</span></h2><p>具体来说，扫描线是一种思想，而不是一种数据结构。</p><p>扫描线比较经典的问题就是求矩形面积并了。</p><blockquote><p>给定若干四边平行于坐标轴的矩形。</p><p>求它们的面积并（重合部分只算一次）。</p><p><span class="math inline">\(n\leq 10^5,|x_i|,|y_i|\leq10^9\)</span>。</p></blockquote><h3><span id="线段树维护矩形面积并">线段树维护矩形面积并</span></h3><figure><img src="https://s2.loli.net/2023/08/31/qVf7EtHWwBbjXo2.gif" alt="扫描线"><figcaption aria-hidden="true">扫描线</figcaption></figure><p>如上图所示，我们将蓝绿两个矩形通过虚线分割成了三块。显然，答案应该是三段的线段长度<span class="math inline">\(len\)</span> 分别乘上这段竖着的长度之和<span class="math inline">\(sum\)</span>。</p><p>前者我们已经知道了，我们只需要快速维护后者即可。可以用线段树维护。</p><p>具体来说，我们通过一根红色的“扫描线”从下向上扫。记矩形的下边界为<span class="math inline">\(+1\)</span>，上边界为 <span class="math inline">\(-1\)</span>，同时维护 <span class="math inline">\(sum\)</span> 即可。</p><p>由于范围很大，因此需要离散化。如果你不想离散化，还可以使用动态开点+标记永久化，代码会更短。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].tag) tr[k].sum = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> tr[k].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].tag += v, <span class="built_in">pushup</span>(k, l, r));</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="本质">本质</span></h3><p>我们来思考一下扫描线的本质：考虑一下我们刚才引入的这条“扫描线”在干什么？在枚举。而我们为了达到同时枚举<span class="math inline">\(x,y\)</span> 的目的，在扫描 <span class="math inline">\(y\)</span> 的同时，快速更新 <span class="math inline">\(x\)</span> 的贡献。这就是扫描线思想。</p><p>也就是说，对于 <span class="math inline">\((x,y)\)</span>的枚举，我们可以枚举其中一维，并同时通过数据结构快速维护另一维，以求出答案。</p><h2><span id="李超线段树">李超线段树</span></h2><blockquote><p>要求在平面直角坐标系下维护两个操作：</p><ol type="1"><li><p>在平面上加入一条线段。记第 <span class="math inline">\(i\)</span>条被插入的线段的标号为 <span class="math inline">\(i\)</span>；</p></li><li><p>给定一个数 <span class="math inline">\(k\)</span>，询问与直线<span class="math inline">\(x = k\)</span>相交的线段中，交点纵坐标最大的线段的最小编号。</p></li></ol><p>强制在线。<span class="math inline">\(n\leq 10^5\)</span>。</p></blockquote><p>这个问题普通线段树无法解决，这个时候，李超线段树就派上用场了。李超树由浙江学军中学的李超发明，用于维护这样一类普通线段树无法维护的问题。</p><p>李超线段树维护 <span class="math inline">\(x=mid\)</span>时最大的线段信息。记我们现在的最优线段为 <span class="math inline">\(l\)</span>，新加入的线段（完全覆盖此区间）为 <span class="math inline">\(l&#39;\)</span>。那么，我们将 <span class="math inline">\(l\)</span> 与 <span class="math inline">\(l&#39;\)</span> 比较，若 <span class="math inline">\(l&#39;\)</span> 在 <span class="math inline">\(mid\)</span> 处更优，则交换 <span class="math inline">\(l\)</span> 与 <span class="math inline">\(l&#39;\)</span>。</p><p>接下来，对于 <span class="math inline">\(l&#39;\)</span> 在 <span class="math inline">\(mid\)</span> 处不比 <span class="math inline">\(l\)</span> 优的情况，有下列几种：</p><ol type="1"><li>在左端点 <span class="math inline">\(l&#39;\)</span> 优于 <span class="math inline">\(l\)</span>，则一定在左区间中产生交点，递归左子树。</li><li>在右端点 <span class="math inline">\(l&#39;\)</span> 优于 <span class="math inline">\(l\)</span>，则一定在右区间中产生交点，递归右子树。</li><li>在左右端点均不优，则不需要修改。</li></ol><figure><img src="https://s2.loli.net/2023/09/01/guCdZAKXMOS3ahG.png" alt="李超线段树"><figcaption aria-hidden="true">李超线段树</figcaption></figure><p>如上图，蓝线是我们的原来最优线段 <span class="math inline">\(l\)</span>，红线、绿线、紫线依次表示三种情况。</p><p>以红线为例：在 <span class="math inline">\(L\)</span> 时，<span class="math inline">\(l&#39;_L&gt;l_L\)</span>，说明 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(l&#39;\)</span> 一定在 <span class="math inline">\([L,mid]\)</span> 有交点，那么我们就递归 <span class="math inline">\([L,mid]\)</span> 的区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x - y &gt; eps) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y - x &gt; eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> dis)</span></span>&#123;<span class="keyword">return</span> a[k].b + a[k].k * dis;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;v = tr[k], mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> xmid = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, mid), <span class="built_in">calc</span>(v, mid));</span><br><span class="line">    <span class="keyword">if</span>(xmid == <span class="number">1</span> || (!xmid &amp;&amp; u &lt; v)) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="type">int</span> xl = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, l), <span class="built_in">calc</span>(v, l)), xr = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, r), <span class="built_in">calc</span>(v, r));</span><br><span class="line">    <span class="keyword">if</span>(xl == <span class="number">1</span> || (!xl &amp;&amp; u &lt; v)) <span class="built_in">modify</span>(ls, l, mid, u);</span><br><span class="line">    <span class="keyword">if</span>(xr == <span class="number">1</span> || (!xr &amp;&amp; u &lt; v)) <span class="built_in">modify</span>(rs, mid + <span class="number">1</span>, r, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)<span class="built_in">modify</span>(k, l, r, u);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, u);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询 <span class="math inline">\(x\)</span> 时，从根节点走到 <span class="math inline">\([x,x]\)</span> 的所有最优线段在 <span class="math inline">\(x\)</span>处的极值即为答案，类似于标记永久化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pdi <span class="title">pmax</span><span class="params">(pdi x, pdi y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.fi, y.fi) == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.fi, y.fi) == <span class="number">-1</span>) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.se &lt; y.se ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pdi <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; x || x &gt; r) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> res = <span class="built_in">calc</span>(tr[k], x);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> &#123;res, tr[k]&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pmax</span>(&#123;res, tr[k]&#125;, <span class="built_in">pmax</span>(<span class="built_in">query</span>(ls, l, mid, x), <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, x)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="zkw-线段树">zkw 线段树</span></h2><p>zkw线段树，即非递归式线段树，由张昆玮发明的一种更加快速、方便、易写的线段树。</p><h3><span id="结构">结构</span></h3><p>我们将线段树开成<strong>满二叉树</strong>。容易发现这样一些性质：</p><ol type="1"><li>记当前节点编号为 <span class="math inline">\(k\)</span>，则左儿子编号为 <span class="math inline">\(k&lt;&lt;1\)</span>，右儿子编号为 <span class="math inline">\(k&lt;&lt;1|1\)</span>。反之，父亲节点编号为 <span class="math inline">\(k&gt;&gt;1\)</span>。</li><li>前 <span class="math inline">\(n\)</span> 层节点数为 <span class="math inline">\(2^n-1\)</span>，第 <span class="math inline">\(n\)</span> 层节点数为 <span class="math inline">\(2^{n-1}\)</span>。</li><li>叶子是一段连续的编号，且与原序列可一一对应。</li></ol><p>一反之前线段树自上向下递归的方式，zkw线段树一般采用从叶子向根节点的非递归方式。</p><h3><span id="建树">建树</span></h3><p>根据刚才的性质，我们只需要把原序列填到这段叶子序列上即可。第一个叶子节点的编号可以<span class="math inline">\(O(\log n)\)</span> 地求出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(N = <span class="number">1</span>; N &lt;= n + <span class="number">1</span>; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tr[N + i] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) tr[i] = tr[i &lt;&lt; <span class="number">1</span>] + tr[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<span class="math inline">\(N\)</span> 为非叶子结点的个数。</p><h3><span id="单点修改-区间查询">单点修改、区间查询</span></h3><p>很简单，我们只需要找到对应的叶子节点，一路走到根节点修改即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(k += N; k; k &gt;&gt;= <span class="number">1</span>) tr[k] += v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际代码写起来只有一行，非常简短。</p><p>接下来思考区间查询。从叶子节点向上，我们怎么实现区间查询呢？</p><p>这里有一个非常巧妙的思想：从我们当前要查询的叶子区间的左右两个节点分别记一个<span class="math inline">\(l,r\)</span>值，然后不断向父亲节点跳，直到其父亲节点为同一个点为止。</p><p>在跳的过程中，若 <span class="math inline">\(l\)</span>为左儿子，则计算右儿子的贡献；若 <span class="math inline">\(r\)</span>为右儿子，则记录左儿子的贡献。</p><p>简单证明一下这么做的正确性：</p><p>会被计算贡献的只有 <span class="math inline">\((l,r)\)</span>的部分。在向上跳的过程中，<span class="math inline">\((l,r)\)</span>间显然不会出现不被计算的情况。<span class="math inline">\(l\)</span>若为左儿子，则其兄弟节点一定在 <span class="math inline">\((l,r)\)</span>中，否则其右侧的点一定会被上一层计算到。而线段树需要计算的节点显然只会在最两边，因此这样计算是正确的。</p><p>那么我们可以写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = N + l - <span class="number">1</span>, r = N + r + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(~l &amp; <span class="number">1</span>) ans += tr[l ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(r &amp; <span class="number">1</span>) ans += tr[r ^ <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中用到的位运算：</p><ol type="1"><li><code>l ^ r ^ 1</code>：若 <span class="math inline">\(l,r\)</span>互为兄弟，则一定为 <span class="math inline">\(2k\)</span> 与 <span class="math inline">\(2k+1\)</span>，其异或值 <span class="math inline">\(1\)</span>。</li><li><code>l &gt;&gt;= 1</code>：跳父节点。<code>r &gt;&gt;= 1</code>同理。</li><li><code>~l &amp; 1</code>：若 <span class="math inline">\(l\)</span>为左儿子，则末尾为 <span class="math inline">\(0\)</span>，否则为 <span class="math inline">\(1\)</span>，将末尾取反后再按位与 <span class="math inline">\(1\)</span>即可判断是否为左儿子。<code>r &amp; 1</code> 同理。</li></ol><h3><span id="区间修改-区间查询">区间修改、区间查询</span></h3><p>区间修改，就势必要打标记。如果我们不能下放标记，那该怎么办呢？</p><p><a href="#标记永久化">标记永久化</a>！</p><p>因此区间修改、区间查询的代码可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> numl = <span class="number">0</span>, numr = <span class="number">0</span>, num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = N + l - <span class="number">1</span>, r = N + r + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, num &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[l] += v * numl, tr[r] += v * numr;</span><br><span class="line">        <span class="keyword">if</span>(~l &amp; <span class="number">1</span>) tag[l ^ <span class="number">1</span>] += v, tr[l ^ <span class="number">1</span>] += v * num, numl += num;</span><br><span class="line">        <span class="keyword">if</span>(r &amp; <span class="number">1</span>) tag[r ^ <span class="number">1</span>] += v, tr[r ^ <span class="number">1</span>] += v * num, numr += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; l; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) tr[l] += v * numl, tr[r] += v * numr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> numl = <span class="number">0</span>, numr = <span class="number">0</span>, num = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = N + l - <span class="number">1</span>, r = N + r + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, num &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[l]) ans += tag[l] * numl;</span><br><span class="line">        <span class="keyword">if</span>(tag[r]) ans += tag[r] * numr;</span><br><span class="line">        <span class="keyword">if</span>(~l &amp; <span class="number">1</span>) ans += tr[l ^ <span class="number">1</span>], numl += num;</span><br><span class="line">        <span class="keyword">if</span>(r &amp; <span class="number">1</span>) ans += tr[r ^ <span class="number">1</span>], numr += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; l; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) ans += tag[l] * numl, ans += tag[r] * numr;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="多线段树操作">多线段树操作</span></h1><h2><span id="线段树合并">线段树合并</span></h2><p>线段树合并，顾名思义，将两颗线段树合并为一颗新的线段树。</p><p>线段树合并其实极为暴力。一般来说，对于两颗动态开点的值域线段树，我们可以从<span class="math inline">\(1\)</span>开始递归合并。若当前节点一颗为空，另一颗不为空，则直接返回不为空的节点。若递归到叶子节点，直接合并。最后更新即可。</p><p>时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p><p>例如，对于将两颗值域线段树按加法合并，可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(k) tr[k].lson</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(k) tr[k].rson</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b) <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[a].val += t[b].val;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ls</span>(a) = <span class="built_in">merge</span>(<span class="built_in">ls</span>(a), <span class="built_in">ls</span>(b), l, mid);</span><br><span class="line">    <span class="built_in">rs</span>(a) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(a), <span class="built_in">rs</span>(b), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你也可以选择新开一颗线段树合并进去。优点是不会破坏原来线段树的结构，缺点是需要较大的空间。</p><h2><span id="线段树分裂">线段树分裂</span></h2><p>线段树分裂是线段树合并的逆操作。</p><p>类似于 FHQ-Treap。先挖个坑。</p><h1><span id="主席树">主席树</span></h1><h2><span id="简介">简介</span></h2><p>主席树，全称可持久化值域线段树，因其发明者黄嘉泰名字首字母与某位历史上的主席相同，因此称为主席树。</p><p>主席树一般用于解决<strong>静态</strong>区间第 <span class="math inline">\(k\)</span> 小问题。</p><h2><span id="结构">结构</span></h2><p>如果是全局第 <span class="math inline">\(k\)</span>小问题，那么我们显然可以用<a href="#值域线段树">值域线段树</a>完成。</p><p>值域线段树维护的是区间内数字出现次数。这个是一个可减信息。那么运用前缀和的思想，我们分别建立出维护区间<span class="math inline">\([1,i]\)</span> 的值域线段树 <span class="math inline">\(T_i\)</span>，最后将查询到的信息相减不就好了？</p><p>等等。一颗线段树的空间复杂度就是 <span class="math inline">\(O(n\logn)\)</span> 的了，建 <span class="math inline">\(n\)</span>颗岂不是炸飞了？</p><p>我们考虑能否在建立 <span class="math inline">\(T_i\)</span>的时候充分利用 <span class="math inline">\(T_{i-1}\)</span> 的信息。由于<span class="math inline">\(T_{i-1}\rightarrow T_i\)</span>实际上相当于单点修改，因此我们只会影响到 <span class="math inline">\(O(\log n)\)</span> 个节点，只需要把这 <span class="math inline">\(O(\log n)\)</span> 个节点多开出来就可以了。</p><figure><img src="https://s2.loli.net/2023/09/01/3XampzrlZA4jKqN.jpg" alt="主席树"><figcaption aria-hidden="true">主席树</figcaption></figure><p>过于抽象？来看张图。</p><p>在这张图中，黑色节点与蓝色节点共同构成了 <span class="math inline">\(T_{i-1}\)</span>，黑色节点与红色节点共同构成了<span class="math inline">\(T_i\)</span>。一条红色箭头代表了该蓝色节点被影响后，重建出来的红色节点。如果我们忽视所有的虚线，那么得到的就是新线段树。</p><p>如果你的空间想象能力足够强大，那么你可以这么理解：线段树通常被画为二维平面的图像。而不同的版本意味着我们再引入一条垂直于平面的坐标轴“版本轴”，或者“时间轴”。对于影响到的节点，我们直接在新的版本平面内建立出来，而对于还可以利用的节点，我们连接向上一个版本平面的节点。</p><figure><img src="https://s2.loli.net/2023/09/01/1WbXFMpIDqfTS47.png" alt="立体主席树1"><figcaption aria-hidden="true">立体主席树1</figcaption></figure><figure><img src="https://s2.loli.net/2023/09/01/8TLzMn56NGHDpa9.png" alt="立体主席树2"><figcaption aria-hidden="true">立体主席树2</figcaption></figure><h2><span id="操作">操作</span></h2><p>查询的时候，我们在两颗线段树上分别查询就可以了，这个没有太大的问题。那么更新的时候呢？</p><p>那么，我们可以写出如下代码；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lson, rson;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt[MAXN &lt;&lt; <span class="number">5</span>], cnt; <span class="comment">//rt 表示每个版本的根</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(k), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(k), mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nk = ++cnt;</span><br><span class="line">    tr[nk] = tr[k], tr[nk].val++; <span class="comment">//建立新的节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> nk;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= mid) <span class="built_in">ls</span>(nk) = <span class="built_in">update</span>(<span class="built_in">ls</span>(nk), l, mid, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">rs</span>(nk) = <span class="built_in">update</span>(<span class="built_in">rs</span>(nk), mid + <span class="number">1</span>, r, v);</span><br><span class="line">    <span class="keyword">return</span> nk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x,y 分别表示两个版本的根节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = tr[<span class="built_in">ls</span>(y)].val - tr[<span class="built_in">ls</span>(x)].val;</span><br><span class="line">    <span class="keyword">if</span>(num &gt;= v) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(x), <span class="built_in">ls</span>(y), l, mid, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(x), <span class="built_in">rs</span>(y), mid + <span class="number">1</span>, r, v - num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="区间修改">区间修改</span></h2><p>对于一颗普通的可持久化线段树，如果我们要区间修改，貌似还有些麻烦。</p><p>保证线段树复杂度正确性的一个重要部分是懒惰标记 <span class="math inline">\(tag\)</span>。但是当一个节点被多个版本的父亲公用，就出现了问题：如果我们直接将标记打到儿子节点，那么多个版本就会受到影响，正确性是错的。</p><p>面对这种问题，一般有两种方法：</p><p>第一种：在 pushdown的时候，如果要下放的节点不在当前版本，那就在当前版本新建节点。由于每次至多新建两个节点，因此时间复杂度仍然是<span class="math inline">\(O(\log n)\)</span>；</p><p>第二种：运用标记永久化的思想，不进行标记下放。</p><p>一般来说，第二种更加方便、好写，但也有部分无法处理的情况。如果使用第一种方法，则update 和 query 时都要 pushdown 新建节点。</p><p>至此，线段树基本内容已经处理完毕。</p><h1><span id="题目随解">题目随解</span></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;系统复盘了一下线段树，发现网上现有博客鲜有将线段树各种操作一步一步讲明白的，故结合自己理解写此文。&lt;/p&gt;
&lt;p&gt;应该会持续更新。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>SDOI2023&lt;br&gt;游记</title>
    <link href="http://summace.cc/SDOI2023/"/>
    <id>http://summace.cc/SDOI2023/</id>
    <published>2023-05-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:20.285Z</updated>
    
    <content type="html"><![CDATA[<p>体验省选。</p><span id="more"></span><h1><span id="day-1">Day -1</span></h1><p>本来没想到可以来省选，毕竟 NOIP考的太拉了。甚至是正式选手，RMB-700。</p><p>周五中午从学校开润，下午到了平邑。</p><p>然后遇到了百年难得一遇的街区停电。</p><p>晚上去试机，Win7炸场，键盘拉跨，但是和美婷、庞队在一个考场，好耶。</p><h1><span id="day1">Day1</span></h1><p><span class="math inline">\(8:00\)</span>就进考场了，先敲了线段树和快读，不知道能不能用上。</p><p><span class="math inline">\(8:30\)</span> 开考，先瞄一眼题目。T1看起来可做，T2 图论一眼弃，T3 应该能做。</p><p>于是开始写 T1。发现这不是萌萌题吗，省选怎么会出这么简单的题。<span class="math inline">\(9:17\)</span> 过了 <span class="math inline">\(3\)</span> 个样例，润润润。</p><p>然后就直接开始看T3。想了想，感觉暴力能写，于是开始写暴力，差不多写了两百多行，突然发现暴力思路是寄的。寄寄寄。</p><p>因为本来也没有希望进队，写出来一题感觉十分满足，于是就检查了下T1，一直到 <span class="math inline">\(13:00\)</span> 收卷。</p><p>然后学校统一安排了午饭。这真的是我在学校里吃过的有史以来最丰盛的一次。就是队伍非常long long，排了很久。</p><p>下午摆摆摆。</p><h1><span id="day2">Day2</span></h1><p><span class="math inline">\(8:30\)</span> 开考，先瞄一眼题目。T1过河卒，感觉暴力可做。T2T3 看起来很难，先做 T1。</p><p>T1 的 <span class="math inline">\(20pts\)</span>是好拿的，很顺利拿下来了。</p><p>第二个 <span class="math inline">\(10pts\)</span> 就是红色和黑色1v1，手玩了半天没怎么会，先润。</p><p>然后发现第四个 <span class="math inline">\(20pts\)</span>是能拿的，于是敲了个大暴力。</p><p>T2 把最基本暴力分拿了。T3 想当然认为直接 <span class="math inline">\(1 0\)</span> 就行了，然后喜提 <span class="math inline">\(0pts\)</span>。</p><p>吃饭，润，美婷身份证丢了，于是陪着美婷润了两遍食堂-考场，很热。</p><p>然后就润回来了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;体验省选。&lt;/p&gt;</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>NOIP2022&lt;br&gt;爆零记</title>
    <link href="http://summace.cc/NOIP2022/"/>
    <id>http://summace.cc/NOIP2022/</id>
    <published>2022-12-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:13.975Z</updated>
    
    <content type="html"><![CDATA[<p>一次愉快的 NOIP，而又是与他们最后的诀别。</p><span id="more"></span><h1><span id="day-8">Day -8</span></h1><p>由于 CSP-S 和高一的同学们脱轨了，因此乖乖回去学whk。本来以为没啥希望了，结果晚上 🍬一通电话通知居然能去了。非常惊讶。但是一段时间没学 OI了，感觉更菜了。就当是体验一下。</p><h1><span id="day-7">Day -7</span></h1><p>要在下午 <span class="math inline">\(17:00\)</span> 之前到平邑，因此<span class="math inline">\(14:30\)</span>就要走。学校要求交艺术节作品，趁上午写了写结果写挂了，气急败坏。RP--。</p><p>然后下午睡了一路之后来到平邑，住在很豪华的全季酒店，感觉从来没住过如此豪华。酒店临着河（好像叫浚河，祊河支流），还算是河景房，环境非常优美。</p><p>睡得很安稳。</p><h1><span id="day-6">Day -6</span></h1><p>上午 vp 了一下 CF，没切出 F，RP--。</p><p>题目里面有道题叫做 The Humanoid，是 ZTMY 歌名，RP++。</p><p>酒店居然有咖啡机。喝了一杯，好苦。</p><h1><span id="day-5">Day -5</span></h1><p>写了几道线段树，感觉对线段树理解更深了一点。</p><p>写了几篇题解，但是发现自己换硬盘重装系统忘了把 Blog文件夹拷过来，只能等 m.2-&gt;usb 买来了在部署了，先写着。</p><p>鸭子可爱捏。</p><p>晚上和 <span class="citation" data-cites="chiptune">@chiptune</span>一起 vp 了一场 abc，没切出来 F，自闭了，RP--。</p><h1><span id="day-4">Day -4</span></h1><p>下雨了。</p><p>测了下分院帽，Slytherin。</p><p>下午 vp 了一场 div4，本来想涨涨信心，结果没 AK，自闭了，RP--。</p><p>鸭子给了一首<a href="https://music.163.com/#/song?id=557581315">好听的歌</a>，单循了，RP++。</p><p>感觉自己菜炸了，模板都不会了。</p><p>调整作息，<span class="math inline">\(22:00\)</span>就睡了，我真规律。</p><h1><span id="day-3">Day -3</span></h1><p>上午敲了敲板子，愣神。</p><p>感觉自己没救了。</p><p>鸭子又给了一首<a href="https://music.163.com/#/song?id=1347630432">好听的歌</a>，单循了，但是没有VIP，气得我满地乱爬。于是从 B 站下载音频上传到云盘，我真聪明。</p><p>写了个攒 RP 的程序，开始跑了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld, %lld, RP++\n&quot;</span>, i, <span class="built_in">clock</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梦神锐评：“你是真无聊。”</p><p>晚上头巨疼。不知道为什么。疼死我了。于是早早睡了。</p><p>有点后怕，别上考场再头疼。</p><h1><span id="day-2">Day -2</span></h1><p>🍬 给了一场 GMOJ 的比赛，难炸了，只拿了 B 题 20pts 暴力分。</p><p>查询小w精神状态，结果为：就你还想打 NOIP？</p><p>出考场了，5考场。</p><p>测了一下 mbti，ENFJ-A。</p><p>下午被精度给整自闭了。但是美婷姐姐理我了，很开心，RP++。</p><p>写游记了。</p><h1><span id="day-1">Day -1</span></h1><p>考前最后一天。上午意识到这一点有些紧张。</p><p>然后就肆无忌惮地摆了一天。看了看KMP、逆元，感觉还可以。</p><p>一直到晚上🍬开了个会，希望明天不要自闭吧。</p><p>鸭子请了一杯奶茶，芋泥+珍珠，很好喝。</p><p>领了前瞻的 300 原石，抽了一下，没想到 16抽就出了卢老爷，根据运气守恒定律，感觉明天会寄。</p><p>早点睡觉吧。还是有点紧张。</p><h1><span id="day-1">Day 1</span></h1><p>早上六点起床，早饭没吃凉的，吃的不多，有点担心会不会饿。但是实际上并没有。</p><p>然后就坐（站）着大巴去 pyyz。终于见到 ss,lz1,lzy,zzk,lmt了，很开心。</p><p>带着手机去结果根本没查码。</p><p>上考场先把快读和对拍敲了，结果两个都没用到。</p><p>考试还有个小风波，一开始给的密码不对，后来又给了，导致拖后了十分钟，不过在后面补上了。没想到是双重密码，pdf的密码是一开始给的。</p><p>解压包的密码是 <code>biu#2019miss</code>，是不是在暗示错过了 2019年？（2019刚好疫情开始捏。）</p><p>pdf 的密码是 <code>solo@2022</code>，是不是暗示 2022年单身啊呜呜。</p><p>先看一遍题。T1 感觉可做，T2 是啥啊，名字倒是挺好听的。T3一眼图论，一眼要跑 Tarjan，一眼我不会。T4 一眼大数据结构，一眼不会。</p><p>然后感觉先看看 T1。然后就想到可以对于每列 <span class="math inline">\(j\)</span> 的每行 <span class="math inline">\(i\)</span>预处理一下最长可以向上延伸多少，然后就可以想到对于每行 <span class="math inline">\(i\)</span>维护最多可以向右延伸多少，然后就可以想到统计。但是是 <span class="math inline">\(O(n^4)(假设n,m同阶)\)</span> 的。</p><p>然后稍微一考虑就能想到前缀和优化一下到 <span class="math inline">\(O(n^2)\)</span>，然后就过了 <span class="math inline">\(114\ 514\)</span> 的大样例。好像也没法对拍，大概是<span class="math inline">\(10:00\)</span>，润了。</p><p>然后看了看 T2，感觉是很牛逼的构造，不会。之后 T4暴力跑线段树维护最大值 <span class="math inline">\(O(Qn^2\log n)8pts\)</span> 跑路了。</p><p>之后一直在 T4 和 T2 纠结，感觉都拿不到分。已经有点慌了。</p><p>然后感觉 T2 <span class="math inline">\(k=2n-2\)</span>的部分分好像可做，想了很长时间感觉可以每个分配两种颜色，最后一个栈做闲余栈，写了写过了样例，自己造了几组也过了。</p><p>然后感觉很没有头猪。又一直在想 T2 <span class="math inline">\(k=2n-1,n=2\)</span> 的部分分，写了一个 <span class="math inline">\(8\)</span> 个 <code>if</code>的大分类讨论，一直调不过去。眼看还有 <span class="math inline">\(10min\)</span>，先把东西都整理到 E盘，然后最后两分钟突然调出来了，过了样例，赶紧复制到文件里。感觉差不多了。</p><p>估分 <span class="math inline">\(100+30+0+8=138pts\)</span>，但是T1、T2 都很不稳。</p><p>水杯还落到教室里了，意识到的时候已经走了好几公里了，遂作罢。</p><p>lmt 说能 <span class="math inline">\(255pts\)</span>，结果 T2假了，<span class="math inline">\(200pts\)</span> 左右。</p><p>感觉是打的最烂的一次比赛。</p><p>T2 果然是 zrf 投的题啊……果然恶心。</p><p>luogu 测了一下 T1，过了，感觉安心一点了。</p><p>luogu 和 infoj 测了所有的，一分没挂。感觉是打的最好的一次比赛。</p><h1><span id="days-later">Days Later</span></h1><p>T1 挂了，省二。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一次愉快的 NOIP，而又是与他们最后的诀别。&lt;/p&gt;</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LuoguP1133&lt;br&gt;教主的花园</title>
    <link href="http://summace.cc/LGP1133/"/>
    <id>http://summace.cc/LGP1133/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:00.184Z</updated>
    
    <content type="html"><![CDATA[<p>经典线性dp。</p><span id="more"></span><h1><span id="sol">Sol.</span></h1><p>典型的线性dp，首先考虑二维：</p><p>记 <span class="math inline">\(f_{i,j}\)</span> 表示当前为第 <span class="math inline">\(i\)</span> 位，放第 <span class="math inline">\(j\)</span> 种树的最大值。</p><p>然后我们发现我们没办法很好地表示树之间的高低关系，于是我们再加一维：</p><p>记 <span class="math inline">\(f_{i,j,0/1}\)</span> 表示当前为第<span class="math inline">\(i\)</span> 位，放第 <span class="math inline">\(j\)</span> 种树，当前树比上一位树 <span class="math inline">\(0(高)/1(低)\)</span> 的最大值。</p><p>我们可以很顺利地推出转移方程：</p><p><span class="math display">\[f_{i,j,0} = \max\limits_{k&lt;j}\{f_{i-1,k,1}\}\\f_{i,j,0} = \max\limits_{k&gt;j}\{f_{i-1,k,0}\}\]</span></p><p>如果这题只是一条线，那么这题到此为止就已经完成了。但是这道题是在环上，所以我们还要考虑如何处理头和尾。在记一维<span class="math inline">\(s\)</span> 表示第一位是那种树。即变成：</p><p>记 <span class="math inline">\(f_{i,j,s,0/1}\)</span> 表示当前为第<span class="math inline">\(i\)</span> 位，放第 <span class="math inline">\(j\)</span> 种树，第一位放 <span class="math inline">\(s\)</span> 种树，当前树比上一位树 <span class="math inline">\(0(高)/1(低)\)</span> 的最大值。</p><p><span class="math display">\[\text{if}\ \ 2\leq i&lt;n\begin{cases}    f_{i,j,s,0} = \max\limits_{k&lt;j}\{f_{i-1,k,s,1}\}\\    f_{i,j,s,1} = \max\limits_{k&gt;j}\{f_{i-1,k,s,0}\}\\\end{cases}\\\text{if}\ \ i=n\begin{cases}    f_{n,j,s,0} = \max\limits_{k&lt;j}\{f_{n-1,k,s,1}\}&amp; \text{if}\j&gt;s\\    f_{n,j,s,0} = \max\limits_{k&gt;j}\{f_{n-1,k,s,0}\}&amp; \text{if}\j&lt;s\\\end{cases}\]</span></p><h1><span id="code">Code</span></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN][<span class="number">4</span>], f[MAXN][<span class="number">4</span>][<span class="number">4</span>][<span class="number">2</span>]; <span class="comment">//f(i,j,s,0/1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i][<span class="number">1</span>], &amp;a[i][<span class="number">2</span>], &amp;a[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">f[<span class="number">1</span>][j][j][<span class="number">0</span>] = f[<span class="number">1</span>][j][j][<span class="number">1</span>] = a[<span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt;= <span class="number">3</span>; s++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= <span class="number">3</span>; k++) f[i][j][s][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j][s][<span class="number">1</span>], f[i - <span class="number">1</span>][k][s][<span class="number">0</span>] + a[i][j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--) f[i][j][s][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j][s][<span class="number">0</span>], f[i - <span class="number">1</span>][k][s][<span class="number">1</span>] + a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt;= <span class="number">3</span>; s++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s &lt; j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--) f[n][j][s][<span class="number">0</span>] = <span class="built_in">max</span>(f[n][j][s][<span class="number">0</span>], f[n - <span class="number">1</span>][k][s][<span class="number">1</span>] + a[n][j]);</span><br><span class="line">            <span class="keyword">if</span>(s &gt; j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= <span class="number">3</span>; k++) f[n][j][s][<span class="number">1</span>] = <span class="built_in">max</span>(f[n][j][s][<span class="number">1</span>], f[n - <span class="number">1</span>][k][s][<span class="number">0</span>] + a[n][j]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(f[n][j][s][<span class="number">0</span>], f[n][j][s][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典线性dp。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>LuoguP1253&lt;br&gt;扶苏的问题</title>
    <link href="http://summace.cc/LGP1253/"/>
    <id>http://summace.cc/LGP1253/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:02.927Z</updated>
    
    <content type="html"><![CDATA[<p>线段树。</p><span id="more"></span><h1><span id="sol">Sol.</span></h1><p>实际上相当于维护一颗线段树，支持区间覆盖、区间加和区间查询最大值。</p><p>维护最大值很好办，区间覆盖和区间加我们怎么维护呢？</p><p>首先，区间覆盖和区间加一定都分别需要记一个懒标记。我们把区间覆盖的懒标记记为<span class="math inline">\(ctag\)</span>，区间加的懒标记记为 <span class="math inline">\(atag\)</span>，那么我们如何把标记 <span class="math inline">\(\text{pushdown}\)</span> 呢？</p><p>首先，初始化要选择一个尽量不影响之后操作的值。<span class="math inline">\(atag\)</span> 显然选择 <span class="math inline">\(0\)</span> 即可。由于要更改的数字有正有负，<span class="math inline">\(ctag\)</span> 可以选取 <span class="math inline">\(-\infty\)</span>，在程序中我选用了 <span class="math inline">\(1e18+7\)</span> 作为 <span class="math inline">\(\text{INF}\)</span>。</p><p>考虑到如果我们当前节点有一个 <span class="math inline">\(atag\)</span> 标记，之后又打上了一个 <span class="math inline">\(ctag\)</span>标记，那么<strong>要覆盖的值会直接把要加的值覆盖</strong>，也就是说<span class="math inline">\(ctag\)</span> 会直接清除 <span class="math inline">\(atag\)</span>。而如果先打上 <span class="math inline">\(ctag\)</span>，再打上 <span class="math inline">\(atag\)</span>，则需要<strong>先把 <span class="math inline">\(ctag\)</span> 下放，再下放 <span class="math inline">\(atag\)</span></strong>。那么我们的 <span class="math inline">\(\text{pushdown}\)</span> 可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span> <span class="comment">//把下放的操作封装一下可以使代码更简洁</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx += v;</span><br><span class="line">    t[k].atag += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = v;</span><br><span class="line">    t[k].ctag = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpushdown</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">//ctag 的下放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].ctag == -INF) <span class="keyword">return</span>; <span class="comment">//如果没有标记，返回</span></span><br><span class="line">    t[ls].atag = t[rs].atag = <span class="number">0</span>; <span class="comment">//抹除 atag</span></span><br><span class="line">    <span class="built_in">cf</span>(ls, t[k].ctag), <span class="built_in">cf</span>(rs, t[k].ctag); <span class="comment">//ctag 下放</span></span><br><span class="line">    t[k].ctag = -INF; <span class="comment">//当前节点 ctag 清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apushdown</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">//atag 的下放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].atag == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//如果没有标记，返回</span></span><br><span class="line">    <span class="built_in">cpushdown</span>(k); <span class="comment">//先把 ctag 下放</span></span><br><span class="line">    <span class="built_in">af</span>(ls, t[k].atag), <span class="built_in">af</span>(rs, t[k].atag); <span class="comment">//atag 下放</span></span><br><span class="line">    t[k].atag = <span class="number">0</span>; <span class="comment">//当前节点 atag 清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">apushdown</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次 pushdown 操作包括 ctag 的下放和 atag 的下放，都要进行</span></span><br></pre></td></tr></table></figure><p>那么操作呢？区间加操作和之前一样即可，区间覆盖操作需要清除当前节点的<span class="math inline">\(atag\)</span>。</p><p>其他部分即为普通线段树模板。</p><h1><span id="code">Code</span></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxx;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> atag, ctag;</span><br><span class="line">&#125;t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = <span class="built_in">max</span>(t[ls].maxx, t[rs].maxx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx += v;</span><br><span class="line">    t[k].atag += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = v;</span><br><span class="line">    t[k].ctag = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].ctag == -INF) <span class="keyword">return</span>;</span><br><span class="line">    t[ls].atag = t[rs].atag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cf</span>(ls, t[k].ctag), <span class="built_in">cf</span>(rs, t[k].ctag);</span><br><span class="line">    t[k].ctag = -INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].atag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">af</span>(ls, t[k].atag), <span class="built_in">af</span>(rs, t[k].atag);</span><br><span class="line">    t[k].atag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">apushdown</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].l = l;</span><br><span class="line">    t[k].r = r;</span><br><span class="line">    t[k].atag = <span class="number">0</span>;</span><br><span class="line">    t[k].ctag = -INF;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].maxx = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">af</span>(k, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].atag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cf</span>(k, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">cover</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">cover</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r) <span class="keyword">return</span> t[k].maxx;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(ls, l, r));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(rs, l, r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">cover</span>(<span class="number">1</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;线段树。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>NOI2013&lt;br&gt;快餐店</title>
    <link href="http://summace.cc/LGP1399/"/>
    <id>http://summace.cc/LGP1399/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:04.979Z</updated>
    
    <content type="html"><![CDATA[<p>图片炸了，难过。本地也没有存。</p><span id="more"></span><h1><span id="sol">Sol.</span></h1><p>一道很经典的基环树上dp题。<del>调了一年</del>。</p><p>首先，如果没有环的话，这就是一道简单的求树上重心的题目。众所周知，树的重心一定在直径的中点上。</p><p>但是现在在一个基环树上做，应该怎么求呢？我们先画一个图：</p><!--more--><figure><img src="https://c2.im5i.com/2022/09/23/HW8Pz.png" alt="基环树"><figcaption aria-hidden="true">基环树</figcaption></figure><p>为了方便，我们先设边权全部为 <span class="math inline">\(1\)</span>。</p><p>首先，我们可以想到断一条环上的边，然后求断边后的树的直径。</p><blockquote><p>略证：考虑到直径一定不会经过一整个环，所以依次断边后求直径一定不会漏掉真正的直径。</p></blockquote><p>这样的复杂度是 <span class="math inline">\(O(n^2)\)</span>的，我们考虑一下如何优化。</p><p>在刚刚的过程中，我们从环上的第一条边一直到最后一条边依次断开，而我们每次断开都要重新计算一次直径，这中间显然是有重合的部分的，于是我们可以考虑用类似于dp 的东西优化。</p><p>考虑有两种情况:</p><ol type="1"><li>直径没有经过环；</li><li>直径经过了环。</li></ol><p>第一个情况很好搞，第二种情况略有麻烦，也是我们刚刚复杂度的瓶颈所在。</p><p>先上结论：</p><ul><li>记 <span class="math inline">\(pre_i\)</span> 表示 <span class="math inline">\(i\)</span>点之前某以环上节点为根节点的子树的直径加上该点距离环上 <span class="math inline">\(1\)</span> 号点的距离的最大值；</li><li>记 <span class="math inline">\(suf_i\)</span> 表示 <span class="math inline">\(i\)</span>点之后某以环上节点为根节点的子树的直径加上该点距离环上 <span class="math inline">\(m\)</span> 号点的距离的最大值；</li><li>记 <span class="math inline">\(pres_i\)</span> 表示 <span class="math inline">\(i\)</span>点之前环上某两节点的子树直径加上两点之间的距离的最大值；</li><li>记 <span class="math inline">\(sufs_i\)</span> 表示 <span class="math inline">\(i\)</span>点之后环上某两节点的子树直径加上两点之间的距离的最大值；</li><li>记 <span class="math inline">\(w_{(i,j)}\)</span> 表示 <span class="math inline">\(i,j\)</span> 两点的距离。</li></ul><p>那么第 <span class="math inline">\(i\)</span> 号点的答案即为 <span class="math inline">\(\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\)</span>。</p><p>最终答案即为 <span class="math inline">\(\min\limits_{i=1}^{m-1}\{\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\}\)</span></p><p>是不是到现在已经有些晕了？没关系，我们从图上举例说明一下。</p><figure><img src="https://c2.im5i.com/2022/09/23/HX5t8.png" alt="删边"><figcaption aria-hidden="true">删边</figcaption></figure><p>例如，我们现在有一只删了一条环边 <span class="math inline">\((4,5)\)</span> 的基环树。</p><p>我们仔细复盘一下刚刚的几句话。</p><p>先看 <span class="math inline">\(pre_i\)</span> 和 <span class="math inline">\(suf_i\)</span>。由于两个很像，所以重点解释 <span class="math inline">\(pre_i\)</span>。</p><blockquote><p>记 <span class="math inline">\(pre_i\)</span> 表示 <span class="math inline">\(i\)</span> 点之前 <span class="math inline">\(//\)</span> 某以环上节点为根节点的子树的直径 <span class="math inline">\(//\)</span> 加上该点距离环上 <span class="math inline">\(1\)</span> 号点的距离 <span class="math inline">\(//\)</span> 的最大值。</p></blockquote><p>形式化的来说，我们要找的就是：</p><p><span class="math inline">\(pre_i=\max\limits_{j=1}^{i}\{dep_j+w_{(1,j)}\}\)</span></p><p>来看张图。</p><figure><img src="https://c2.im5i.com/2022/09/23/H21O4.png" alt="pre和suf"><figcaption aria-hidden="true">pre和suf</figcaption></figure><p><em>可能有多种方案，图中仅展示一种。</em></p><p>图中绿色的部分即为 <span class="math inline">\(pre_4\)</span>，橙色的部分即为 <span class="math inline">\(suf_5\)</span>。</p><p>可以看出来 <span class="math inline">\(pre_i\)</span> 和 <span class="math inline">\(suf_i\)</span> 其实就是一棵子树的直径 <span class="math inline">\(+\)</span> 它前面（后面）的链的长度。</p><p>接下来再看看 <span class="math inline">\(pres_i\)</span> 和 <span class="math inline">\(sufs_i\)</span>，同样重点解释 <span class="math inline">\(pres_i\)</span>。</p><blockquote><p>记 <span class="math inline">\(pres_i\)</span> 表示 <span class="math inline">\(i\)</span> 点之前 <span class="math inline">\(//\)</span> 环上某两节点的子树直径 <span class="math inline">\(//\)</span> 加上两点之间的距离的最大值。</p></blockquote><p>形式化的来说，我们要找的就是：</p><p><span class="math inline">\(pres_i=\max\limits_{j=1}^{i}\{dep_i+dep_j+w_{(i,j)}\}\)</span></p><p>再来看张图。</p><figure><img src="https://c2.im5i.com/2022/09/23/H2fal.png" alt="pres和sufs"><figcaption aria-hidden="true">pres和sufs</figcaption></figure><p><em>可能有多种方案，图中仅展示一种。</em></p><p>图中蓝色的部分即为 <span class="math inline">\(pres_4\)</span>，黄色的部分即为 <span class="math inline">\(sufs_5\)</span>。</p><p>好，弄清楚这 <span class="math inline">\(4\)</span>个，我们来看看结果的式子：</p><blockquote><p>那么第 <span class="math inline">\(i\)</span> 号点的答案即为 <span class="math inline">\(\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\)</span>。</p></blockquote><p>我们考虑到删掉边 <span class="math inline">\((i,i+1)\)</span>的时候，直径有三种可能：</p><ol type="1"><li>直径在 <span class="math inline">\([1,i]\)</span> 之间；</li><li>直径在 <span class="math inline">\([i+1,m]\)</span> 之间；</li><li>直径跨过了边 <span class="math inline">\((1,m)\)</span>。</li></ol><p>对于第一种情况，我们惊喜地发现，<span class="math inline">\(pres_i\)</span> 即为我们所求。</p><p>对于第二种情况，我们再次惊喜地发现，<span class="math inline">\(sufs_{i+1}\)</span> 即为我们所求。</p><p>对于第三种情况，我们发现，由于 <span class="math inline">\(pre_i\)</span> 一直延伸到 <span class="math inline">\(i\)</span>，<span class="math inline">\(suf_{i+1}\)</span> 一直延伸到 <span class="math inline">\(m\)</span>，所以我们再加上 <span class="math inline">\(w_{(1,m)}\)</span> 即可，也就是 <span class="math inline">\(pre_i+suf_{i+1}+w_{(1,m)}\)</span>。</p><p>最后我们遍历一遍，统计最小值即可。</p><h1><span id="code">Code</span></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt, w;</span><br><span class="line">&#125;e[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], ent;</span><br><span class="line"><span class="type">int</span> fa[MAXN], tnt, dfn[MAXN], dis[MAXN];</span><br><span class="line"><span class="type">bool</span> iscyc[MAXN];</span><br><span class="line"><span class="type">int</span> cyc[MAXN], cnt, cycdis[MAXN];</span><br><span class="line">ll dep[MAXN];</span><br><span class="line">ll pre[MAXN], suf[MAXN], presub[MAXN], sufsub[MAXN];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++ent].to = v;</span><br><span class="line">    e[ent].w = w;</span><br><span class="line">    e[ent].nxt = head[u];</span><br><span class="line">    head[u] = ent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++tnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[v] = u;</span><br><span class="line">            dis[v] = e[i].w;</span><br><span class="line">            <span class="built_in">dfs1</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &gt; dfn[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(; v != u; v = fa[v])</span><br><span class="line">            &#123;</span><br><span class="line">                iscyc[v] = <span class="literal">true</span>;</span><br><span class="line">                cyc[++cnt] = v;</span><br><span class="line">                cycdis[cnt] = dis[v];</span><br><span class="line">            &#125;</span><br><span class="line">            iscyc[u] = <span class="literal">true</span>;</span><br><span class="line">            cyc[++cnt] = u;</span><br><span class="line">            cycdis[cnt] = e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!iscyc[v] &amp;&amp; v != father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">            ans = <span class="built_in">max</span>((ll)dep[u] + dep[v] + e[i].w, ans);</span><br><span class="line">            dep[u] = <span class="built_in">max</span>(dep[u], dep[v] + e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add_edge</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add_edge</span>(b, a, c);</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="built_in">dfs2</span>(cyc[i], <span class="number">0</span>);</span><br><span class="line">    ll sum = <span class="number">0</span>, maxdep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += cycdis[i - <span class="number">1</span>];</span><br><span class="line">        pre[i] = <span class="built_in">max</span>(pre[i - <span class="number">1</span>], dep[cyc[i]] + sum);</span><br><span class="line">        presub[i] = <span class="built_in">max</span>(presub[i - <span class="number">1</span>], sum + maxdep + dep[cyc[i]]);</span><br><span class="line">        maxdep = <span class="built_in">max</span>(maxdep, dep[cyc[i]] - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    sum = maxdep = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp = cycdis[cnt];</span><br><span class="line">    cycdis[cnt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += cycdis[i];</span><br><span class="line">        suf[i] = <span class="built_in">max</span>(suf[i + <span class="number">1</span>], dep[cyc[i]] + sum);</span><br><span class="line">        sufsub[i] = <span class="built_in">max</span>(sufsub[i + <span class="number">1</span>], sum + maxdep + dep[cyc[i]]);</span><br><span class="line">        maxdep = <span class="built_in">max</span>(maxdep, dep[cyc[i]] - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = presub[cnt];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">        res = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(presub[i], sufsub[i + <span class="number">1</span>]), pre[i] + suf[i + <span class="number">1</span>] + tmp), res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>, (<span class="type">double</span>)<span class="built_in">max</span>(ans, res) / <span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;图片炸了，难过。本地也没有存。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>HAOI2012&lt;br&gt;高速公路</title>
    <link href="http://summace.cc/LGP2221/"/>
    <id>http://summace.cc/LGP2221/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-24T00:06:49.141Z</updated>
    
    <content type="html"><![CDATA[<p>一道非常好的线段树题。</p><span id="more"></span><h1><span id="sol">Sol.</span></h1><p>优先想到线段树，考虑怎么维护。</p><p>记第 <span class="math inline">\(i\)</span> 到第 <span class="math inline">\(i+1\)</span> 条边为第 <span class="math inline">\(i\)</span> 条边，将问题转化成维护 <span class="math inline">\(n-1\)</span> 个数。</p><p>那么，我们维护一个前缀和 <span class="math inline">\(sum\)</span>，根据题意：</p><p><span class="math display">\[Ans=\frac{\sum\limits_{i=l}^{r}\sum\limits_{j=l}^{r}sum_j-sum_i}{\binom{r-l+1}{2}}(i\neqj)\]</span></p><p>下面的东西很好算，重点是上面的东西怎么维护。</p><p>我们把上面的东西记作 <span class="math inline">\(ans\)</span>，考虑枚举每条边被计算的次数，可以理解成枚举每个点左右两条路。</p><p>所以：</p><p><span class="math display">\[\begin{split}ans &amp;=\sum\limits_{i=l}^{r}a_i\times (r-i+1)(i-l+1)\\    &amp;=\sum\limits_{i=l}^{r}a_i\times (ir-lr+r-i^2+il-i+i-l+1)\\    &amp;=\sum\limits_{i=l}^{r}a_i\times (-i^2+(l+r)i-lr+r-l+1)\\    &amp;=-\sum\limits_{i=l}^{r}a_i\timesi^2+(l+r)\sum\limits_{i=l}^{r}a_i\timesi+(r-l-lr+1)\sum\limits_{i=l}^{r}a_i\end{split}\]</span></p><p>现在需要维护 <span class="math inline">\(sum_1=\sum_{i=l}^{r}a_i\times i^2\)</span>，<span class="math inline">\(sum_2=\sum_{i=l}^{r}a_i\times i\)</span>，<span class="math inline">\(sum_3=\sum_{i=l}^{r}a_i\)</span>。</p><p>即变成：</p><p><span class="math display">\[ans=-sum1+(l+r)sum2+(r-l-lr+1)sum3\]</span></p><p>考虑 <code>pushup</code> 的时候，直接相加就可以了。</p><p>考虑在区间 <span class="math inline">\([L,R]\)</span> 加上一个 <span class="math inline">\(x\)</span> 的时候怎么做：</p><p><span class="math display">\[\begin{split}sum_3&#39;&amp;= \sum\limits_{i=L}^{R}(a_i+x)\\&amp;= (R-L+1)x+\sum\limits_{i=L}^{R}a_i\\&amp;= (R-L+1)x+sum_3\\\Delta sum_3 &amp;= (R-L+1)x\end{split}\]</span></p><p>直接维护。</p><p><span class="math display">\[\begin{split}sum_2&#39;&amp;= \sum\limits_{i=L}^{R}i(a_i+x)\\&amp;= \sum\limits_{i=L}^{R}i\times a_i+\sum\limits_{i=L}^{R}ix\\&amp;= \sum\limits_{i=L}^{R}i\times a_i+x\sum\limits_{i=L}^{R}i\\&amp;= x\sum\limits_{i=L}^{R}i+sum_2\\\Delta sum_2 &amp;= x\sum\limits_{i=L}^{R}i\end{split}\]</span></p><p>维护区间和。</p><p><span class="math display">\[\begin{split}sum_1&#39;&amp;= \sum\limits_{i=L}^{R}i^2(a_i+x)\\&amp;= \sum\limits_{i=L}^{R}i^2\times a_i+\sum\limits_{i=L}^{R}i^2x\\&amp;= \sum\limits_{i=L}^{R}i^2\times a_i+x\sum\limits_{i=L}^{R}i^2\\&amp;= x\sum\limits_{i=L}^{R}i^2+sum_1\\\Delta sum_1 &amp;= x\sum\limits_{i=L}^{R}i^2\end{split}\]</span></p><p>维护区间平方和。</p><p>最后求期望约分即可。</p><h1><span id="code">Code</span></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans1, ans2, ans3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum1, sum2, sum3, sum4, sum5;</span><br><span class="line">            <span class="type">int</span> lazy;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">        &#125;tree[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].lazy += v;</span><br><span class="line">tree[k].sum1 += (tree[k].r - tree[k].l + <span class="number">1</span>) * v;</span><br><span class="line">            tree[k].sum2 += v * tree[k].sum5;</span><br><span class="line">            tree[k].sum3 += v * tree[k].sum4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].sum1 = tree[<span class="built_in">lc</span>(k)].sum1 + tree[<span class="built_in">rc</span>(k)].sum1;</span><br><span class="line">            tree[k].sum2 = tree[<span class="built_in">lc</span>(k)].sum2 + tree[<span class="built_in">rc</span>(k)].sum2;</span><br><span class="line">            tree[k].sum3 = tree[<span class="built_in">lc</span>(k)].sum3 + tree[<span class="built_in">rc</span>(k)].sum3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">lc</span>(k), tree[k].lazy);</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">rc</span>(k), tree[k].lazy);</span><br><span class="line">tree[k].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].lazy = <span class="number">0</span>;</span><br><span class="line">            tree[k].l = l;</span><br><span class="line">            tree[k].r = r;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[k].sum4 = l * l;</span><br><span class="line">                tree[k].sum5 = l;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">lc</span>(k), l, mid);</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r);</span><br><span class="line">tree[k].sum4 = tree[<span class="built_in">lc</span>(k)].sum4 + tree[<span class="built_in">rc</span>(k)].sum4;</span><br><span class="line">            tree[k].sum5 = tree[<span class="built_in">lc</span>(k)].sum5 + tree[<span class="built_in">rc</span>(k)].sum5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= tree[k].l &amp;&amp; tree[k].r &lt;= R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">f</span>(k, v);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(k);</span><br><span class="line"><span class="type">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(k), L, R, v);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(k), L, R, v);</span><br><span class="line"><span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= tree[k].l &amp;&amp; tree[k].r &lt;= R)</span><br><span class="line">            &#123;</span><br><span class="line">                ans1 += tree[k].sum1;</span><br><span class="line">                ans2 += tree[k].sum2;</span><br><span class="line">                ans3 += tree[k].sum3;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="built_in">pushdown</span>(k);</span><br><span class="line"><span class="type">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) <span class="built_in">query</span>(<span class="built_in">lc</span>(k), L, R);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) <span class="built_in">query</span>(<span class="built_in">rc</span>(k), L, R);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> l, r, v;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        r--;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;v);</span><br><span class="line">            t.<span class="built_in">update</span>(<span class="number">1</span>, l, r, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans1 = ans2 = ans3 = <span class="number">0</span>;</span><br><span class="line">            t.<span class="built_in">query</span>(<span class="number">1</span>, l, r);</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            a = (r - l + <span class="number">1</span> - r * l) * ans1 + (r + l) * ans2 - ans3;</span><br><span class="line">            b = (r - l + <span class="number">2</span>) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            c = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; l &lt;&lt; r &lt;&lt; b;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, a / c, b / c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道非常好的线段树题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>SDOI2006&lt;br&gt;保安站岗</title>
    <link href="http://summace.cc/LGP2458/"/>
    <id>http://summace.cc/LGP2458/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:35:02.578Z</updated>
    
    <content type="html"><![CDATA[<p>一道很经典的树形dp题目。</p><span id="more"></span><h1><span id="sol">Sol.</span></h1><p>很明显的树形dp，先把方程设出来：</p><p><span class="math inline">\(f_{x,0/1/2}\)</span> 表示当前节点为 <span class="math inline">\(x\)</span>，<span class="math inline">\(0(自己覆盖)/1(儿子覆盖)/2(父亲覆盖)\)</span>，且其子节点都已全部覆盖的最小权值。</p><p>很套路的树形dp方程，分别考虑如何转移：</p><p>记 <span class="math inline">\(son(i)\)</span> 表示 <span class="math inline">\(i\)</span> 的所有子节点，<span class="math inline">\(k_i\)</span> 表示控制 <span class="math inline">\(i\)</span> 点所需的代价。</p><h2><span id="1-f_x0自己覆盖">1. <span class="math inline">\(f_{x,0}\)</span>（自己覆盖）</span></h2><p><span class="math inline">\(f_{x,0} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1},f_{y,2}\}+k_x\)</span></p><p>解释：由于当前节点自己覆盖自己，所以不需考虑其他的节点，在所有子节点中找到最小值转移即可。</p><h2><span id="2-f_x1儿子覆盖">2. <span class="math inline">\(f_{x,1}\)</span>（儿子覆盖）</span></h2><p><span class="math inline">\(f_{x,1} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\}\)</span></p><p>解释：当当前节点被儿子覆盖时，说明当前节点不可能覆盖儿子节点，也就无法从<span class="math inline">\(f_{y,2}\)</span> 转移。</p><p>但是有一种这样的情况：当儿子节点全部选择 <span class="math inline">\(f_{y,1}\)</span>时，即儿子节点全部被它的儿子节点覆盖，在这种情况下 <span class="math inline">\(x\)</span> 节点无法被儿子节点覆盖。</p><p>所以我们在转移的时候记一个 <span class="math inline">\(q\)</span>表示是否全部选择的 <span class="math inline">\(f_{y,1}\)</span>，如果是，则强制选择一个节点让其选择<span class="math inline">\(f_{y,0}\)</span>。我们要向最小化代价，显然要让强制选择的节点<span class="math inline">\(f_{y,0}\)</span> 与 <span class="math inline">\(f_{y,1}\)</span>的差值最小。所以现在转移方程如下：</p><p><span class="math inline">\(f_{x,1} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\},\text{if all choose }f_{y,1},\text{then}+\min\limits_{y\inson(x)}\{f_{y,0}-f_{y,1}\}\)</span></p><h2><span id="3-f_x2父亲覆盖">3. <span class="math inline">\(f_{x,2}\)</span>（父亲覆盖）</span></h2><p><span class="math inline">\(f_{x,2} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\}\)</span></p><p>解释：这个就比较简单了，当当前节点被父亲覆盖，直接从可能的方式转移即可。</p><h1><span id="code">Code</span></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125;e[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], k[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = k[x];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, minn = INF;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">        f[x][<span class="number">0</span>] += <span class="built_in">min</span>(f[y][<span class="number">0</span>], <span class="built_in">min</span>(f[y][<span class="number">1</span>], f[y][<span class="number">2</span>]));</span><br><span class="line">        f[x][<span class="number">2</span>] += <span class="built_in">min</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> tmp = <span class="built_in">min</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">        f[x][<span class="number">1</span>] += tmp;</span><br><span class="line">        <span class="keyword">if</span>(tmp == f[y][<span class="number">0</span>]) flag = <span class="literal">false</span>;</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, f[y][<span class="number">0</span>] - f[y][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) f[x][<span class="number">1</span>] += minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">        k[x] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add_edge</span>(x, y);</span><br><span class="line">            <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道很经典的树形dp题目。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>USACO08FEB Hotel G</title>
    <link href="http://summace.cc/LGP2894/"/>
    <id>http://summace.cc/LGP2894/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:16:14.950Z</updated>
    
    <content type="html"><![CDATA[<p>经典线段树问题。</p><span id="more"></span><h1><span id="prob">Prob.</span></h1><p><span class="math inline">\(n\)</span> 个房间，两种操作：</p><ol type="1"><li><code>1 x</code>：在 <span class="math inline">\([1,n]\)</span>中寻找一段长度为 <span class="math inline">\(x\)</span>的空房区间。若存在，入住这些房间，并输出最小的左端点。若不存在，输出<span class="math inline">\(0\)</span>；</li><li><code>2 l r</code>：<span class="math inline">\([l,l+r-1]\)</span>退房。</li></ol><h1><span id="sol">Sol.</span></h1><p>这道题也算是线段树常规操作了。我们要维护连续的空房区间，想想要维护哪些值？</p><p>与分治的思想类似，一段空房区间可以全部在左半部分、全部在右半部分、或者左半部分和右半部分都有一部分。那么我们可以维护三个值：从<strong>左端点开始的</strong>最长空房区间长度、从<strong>右端点开始的</strong>最长空房区间长度、以及<strong>整个区间的</strong>最长空房区间长度。我们把它们分别记为<span class="math inline">\(lmax,rmax,maxx\)</span>。</p><p>那我们想想线段树的各个模块该如何写。</p><h2><span id="textpushup"><span class="math inline">\(\text{pushup}\)</span></span></h2><p>由于我们要维护三个值，那么上传的时候也要上传三个值。</p><p>分情况讨论：</p><h3><span id="lmax如何上传"><span class="math inline">\(lmax\)</span>如何上传？</span></h3><p>显然，当前节点的 <span class="math inline">\(lmax\)</span>直接选取左区间的 <span class="math inline">\(lmax\)</span>就可以了。但是这里有一种特殊情况：<strong>当左区间的 <span class="math inline">\(lmax\)</span> 等于整段左区间的长度时，<span class="math inline">\(lmax\)</span>可以继续延伸至右区间的左端。</strong>此时 <span class="math inline">\(lmax\)</span> 应该为左区间的 <span class="math inline">\(lmax\)</span> 加上有区间的 <span class="math inline">\(lmax\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t[ls].lmax == (t[ls].r - t[ls].l + <span class="number">1</span>)) t[k].lmax = t[ls].lmax + t[rs].lmax;</span><br><span class="line"><span class="keyword">else</span> t[k].lmax = t[ls].lmax;    </span><br></pre></td></tr></table></figure><h3><span id="rmax如何上传"><span class="math inline">\(rmax\)</span>如何上传？</span></h3><p>与 <span class="math inline">\(lmax\)</span> 类似，当右区间的 <span class="math inline">\(rmax\)</span> 等于整段右区间的长度时，<span class="math inline">\(rmax\)</span>可以继续延伸至左区间的右端。否则，选取右区间的 <span class="math inline">\(rmax\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t[rs].rmax == (t[rs].r - t[rs].l + <span class="number">1</span>)) t[k].rmax = t[rs].rmax + t[ls].rmax;</span><br><span class="line"><span class="keyword">else</span> t[k].rmax = t[rs].rmax;</span><br></pre></td></tr></table></figure><h3><span id="maxx如何上传"><span class="math inline">\(maxx\)</span>如何上传？</span></h3><p>显然，<span class="math inline">\(maxx\)</span>直接从左端点开始的长度、右端点开始的长度、以及左右都有的长度中选取最大值即可。左右都有的长度就是左区间的<span class="math inline">\(rmax\)</span> 加上右区间的 <span class="math inline">\(lmax\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t[k].maxx = <span class="built_in">max</span>(<span class="built_in">max</span>(t[ls].maxx, t[rs].maxx), t[ls].rmax + t[rs].lmax);</span><br></pre></td></tr></table></figure><p>那么，我们的 <span class="math inline">\(\text{pushup}\)</span>就可以这么写了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[ls].lmax == (t[ls].r - t[ls].l + <span class="number">1</span>)) t[k].lmax = t[ls].lmax + t[rs].lmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].lmax = t[ls].lmax;</span><br><span class="line">    <span class="keyword">if</span>(t[rs].rmax == (t[rs].r - t[rs].l + <span class="number">1</span>)) t[k].rmax = t[rs].rmax + t[ls].rmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].rmax = t[rs].rmax;</span><br><span class="line">    t[k].maxx = <span class="built_in">max</span>(<span class="built_in">max</span>(t[ls].maxx, t[rs].maxx), t[ls].rmax + t[rs].lmax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="textpushdown"><span class="math inline">\(\text{pushdown}\)</span></span></h2><p>当然，区间修改就一定要打懒标记。虽然这道题目的修改不是常规的数值修改，我们仍然要打<span class="math inline">\(tag\)</span>。</p><p>注意到修改操作有两种：开房和退房。那么我们的 <span class="math inline">\(tag\)</span> 可以分别用 <span class="math inline">\(0/1/2\)</span> 表示 无标记/开房/退房。</p><p>那么当 <span class="math inline">\(tag=1\)</span>时，整段区间都不可用，<span class="math inline">\(lmax=rmax=maxx=0\)</span>。</p><p>当 <span class="math inline">\(tag=2\)</span>时，整段区间都可用，<span class="math inline">\(lmax=rmax=maxx=len\)</span>，<span class="math inline">\(len\)</span> 为区间长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].tag == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//无标记返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">1</span>) <span class="comment">//开房标记，整段区间不可用</span></span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">1</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = <span class="number">0</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">2</span>) <span class="comment">//退房标记，整段区间都可用</span></span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">2</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = t[ls].r - t[ls].l + <span class="number">1</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = t[rs].r - t[rs].l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t[k].tag = <span class="number">0</span>; <span class="comment">//别忘了清零标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="textbuild"><span class="math inline">\(\text{build}\)</span></span></h2><p>这个和常规操作没什么不同，只是由于初始全部都是空房，把所有 <span class="math inline">\(lmax,rmax,maxx\)</span>赋为当前区间长度就可以了。</p><h2><span id="textupdate"><span class="math inline">\(\text{update}\)</span></span></h2><p>修改操作有两个：开房和退房。但是大体上没什么不同，可以只用一个函数解决。</p><p>当是开房操作时，整段区间不可用，<span class="math inline">\(lmax=rmax=maxx=0\)</span>，打上 <span class="math inline">\(1\)</span> 标记。</p><p>当是退房操作时，整段区间都可用，<span class="math inline">\(lmax=rmax=maxx=len\)</span>，打上 <span class="math inline">\(2\)</span> 标记。</p><p>函数添加一个参数 <span class="math inline">\(type\)</span>，<span class="math inline">\(1/2\)</span> 分别表示 开房/退房 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = <span class="number">0</span>;</span><br><span class="line">            t[k].tag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = t[k].r - t[k].l + <span class="number">1</span>;</span><br><span class="line">            t[k].tag = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = t[k].l + t[k].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, type);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, type);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="textquery"><span class="math inline">\(\text{query}\)</span></span></h2><p>查询时，要从三部分查询：全部在左区间找、在中间找、全部在右区间找。</p><p>这里有一个优先级的问题：由于我们要输出最小的编号，那么应该是左区间→中间→右区间的顺序。</p><p>所以，如果左儿子的 <span class="math inline">\(maxx&gt;=len(len为要查询的长度)\)</span>，那么就从左儿子里找。否则，如果左儿子的<span class="math inline">\(rmax\)</span> 加上右儿子的 <span class="math inline">\(lmax\)</span> 大于等于 <span class="math inline">\(len\)</span>（也就是跨左右儿子的空房区间），那么直接输出这段的左端点。否则，去右儿子里找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].l == t[k].r) <span class="keyword">return</span> t[k].l;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(t[ls].maxx &gt;= len) <span class="keyword">return</span> <span class="built_in">query</span>(ls, len); <span class="comment">//去左儿子里找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[ls].rmax + t[rs].lmax &gt;= len) <span class="keyword">return</span> t[ls].r - t[ls].rmax + <span class="number">1</span>; <span class="comment">//去中间找，答案就是左儿子 rmax 的左端点，可以用左儿子的右端点 - rmax长度 + 1 表示</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs, len); <span class="comment">//去右儿子里找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="code">Code</span></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, tag;</span><br><span class="line">    <span class="type">int</span> lmax, rmax, maxx;</span><br><span class="line">&#125;t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[ls].lmax == (t[ls].r - t[ls].l + <span class="number">1</span>)) t[k].lmax = t[ls].lmax + t[rs].lmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].lmax = t[ls].lmax;</span><br><span class="line">    <span class="keyword">if</span>(t[rs].rmax == (t[rs].r - t[rs].l + <span class="number">1</span>)) t[k].rmax = t[rs].rmax + t[ls].rmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].rmax = t[rs].rmax;</span><br><span class="line">    t[k].maxx = <span class="built_in">max</span>(<span class="built_in">max</span>(t[ls].maxx, t[rs].maxx), t[ls].rmax + t[rs].lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].tag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">1</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = <span class="number">0</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">2</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = t[ls].r - t[ls].l + <span class="number">1</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = t[rs].r - t[rs].l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].tag = <span class="number">0</span>;</span><br><span class="line">    t[k].l = l, t[k].r = r;</span><br><span class="line">    t[k].maxx = t[k].lmax = t[k].rmax = (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = <span class="number">0</span>;</span><br><span class="line">            t[k].tag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = t[k].r - t[k].l + <span class="number">1</span>;</span><br><span class="line">            t[k].tag = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = t[k].l + t[k].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, type);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, type);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].l == t[k].r) <span class="keyword">return</span> t[k].l;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(t[ls].maxx &gt;= len) <span class="keyword">return</span> <span class="built_in">query</span>(ls, len);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[ls].rmax + t[rs].lmax &gt;= len) <span class="keyword">return</span> t[ls].r - t[ls].rmax + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">1</span>].maxx &lt; len) <span class="comment">//如果整段区间都没有大于等于 len 的空房区间，那么输出 0</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> ans = <span class="built_in">query</span>(<span class="number">1</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, ans, ans + len - <span class="number">1</span>, <span class="number">1</span>); <span class="comment">//别忘了开上房</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, l, l + r - <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//退房</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="ext">Ext.</span></h2><p>讲个笑话，这道题我调了三次的原因；</p><ol type="1"><li>没建树 <del>（lmt：我们要有所建树！）</del>；</li><li><code>Shift</code> 没按上 <del>（导致 93行加号打成了等号）</del>；</li><li>从 <span class="math inline">\(l\)</span> 开 <span class="math inline">\(r\)</span> 个房，不是从 <span class="math inline">\(l\)</span> 开到 <span class="math inline">\(r\)</span> <del>（所以在 Prob. 里面特意说了是 [l,r-l+1]）</del>。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典线段树问题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>CTSC2012&lt;br&gt;电阻网络</title>
    <link href="http://summace.cc/LGP4020/"/>
    <id>http://summace.cc/LGP4020/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-24T08:49:54.779Z</updated>
    
    <content type="html"><![CDATA[<p>在各学科交叉应用的潮流下，一道具有超前预见性的好题。</p><span id="more"></span><h1><span id="solution">Solution</span></h1><h2><span id="前置知识">前置知识</span></h2><h3><span id="欧姆定律">欧姆定律</span></h3><p>在同一电路中，通过某段导体的电流跟这段导体两端的电压成正比，跟这段导体的电阻成反比。</p><p><span class="math display">\[I=\frac{U}{R}\]</span></p><p>其中 <span class="math inline">\(I\)</span> 为电流，<span class="math inline">\(U\)</span> 为电压，<span class="math inline">\(R\)</span> 为电阻。</p><h3><span id="基尔霍夫第一定律">基尔霍夫第一定律</span></h3><p>会合于任意节点的电流和等于零。</p><p><span class="math display">\[\sum I=0\]</span></p><h2><span id="solution">Solution</span></h2><p>本题中全部为相同电阻，所以答案与电阻大小无关，记电阻大小为 <span class="math inline">\(R\)</span>，钦定一个叶子节点为根。</p><p>考虑第 <span class="math inline">\(i\)</span> 个节点，记 <span class="math inline">\(i\)</span> 的父亲为 <span class="math inline">\(fa\)</span>，儿子集合为 <span class="math inline">\(son\)</span>，<span class="math inline">\(fa\rightarrow i\)</span> 的电流为 <span class="math inline">\(I_i\)</span>。</p><p>则从 <span class="math inline">\(fa\)</span> 到 <span class="math inline">\(i\)</span>的过程中，电势差的产生可以看作两部分，一部分是电阻导致的电势的下降，一部分是电源导致的电势的上升，这两部分之和等于电势差。即：</p><p><span class="math display">\[\varphi_i=\varphi_{fa}-I_iR+E_i\]</span></p><p>移项得：</p><p><span class="math display">\[I_i=\frac{\varphi_{fa}-\varphi_i+E_i}{R}\]</span></p><p>这是 <span class="math inline">\(i\)</span>祖先方向的电流，同理，对于儿子方向的任意 <span class="math inline">\(x\in son\)</span>，我们有：</p><p><span class="math display">\[\varphi_x=\varphi_{i}-I_xR+E_x\]</span></p><p>得：</p><p><span class="math display">\[I_x=\frac{\varphi_{i}-\varphi_x+E_x}{R}\]</span></p><p>求和得：</p><p><span class="math display">\[\sum\limits_{x\inson}I_x=\sum\limits_{x\inson}\frac{\varphi_{i}-\varphi_x+E_x}{R}\]</span></p><p>根据基尔霍夫第一定律：</p><p><span class="math display">\[I_i=\sum\limits_{x\inson}I_x\]</span></p><p>即：</p><p><span class="math display">\[\frac{\varphi_{fa}-\varphi_i+E_i}{R}=\sum\limits_{x\inson}\frac{\varphi_{i}-\varphi_x+E_x}{R}\]</span></p><p>继续化简：</p><p><span class="math display">\[\varphi_{fa}-\varphi_i+E_i=\sum\limits_{x\inson}(\varphi_{i}-\varphi_x+E_x)\]</span></p><p><span class="math display">\[\varphi_{fa}-\varphi_i+E_i=|son|\varphi_i-\sum\limits_{x\inson}(\varphi_x-E_x)\]</span></p><p><span class="math display">\[(|son|+1)\varphi_i=\varphi_{fa}+E_i+\sum\limits_{x\inson}(\varphi_x-E_x)\]</span></p><p>注意到 <span class="math inline">\(|son|\)</span>是儿子集合，相当于当前节点向儿子方向的度数；<span class="math inline">\(1\)</span> 相当于当前节点向父亲方向的度数，所以<span class="math inline">\(|son|+1\)</span> 实际上相当于节点 <span class="math inline">\(i\)</span> 的度数，记为 <span class="math inline">\(\deg_i\)</span>。</p><p><span class="math display">\[\deg_i\varphi_i=\varphi_{fa}+E_i+\sum\limits_{x\inson}(\varphi_x-E_x)\]</span></p><p>设 <span class="math inline">\(\varphi_i=K_i\varphi_{fa}+B_i\)</span>，其中 <span class="math inline">\(K_i,B_i\)</span> 都是只与 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(son\)</span> 有关的常量。</p><p>把 <span class="math inline">\(\varphi_x\)</span>用刚刚的形式表示出来：</p><p><span class="math display">\[\varphi_x=K_x\varphi_{i}+B_x\]</span></p><p>代入原式：</p><p><span class="math display">\[\varphi_i=\frac{\varphi_{fa}+E_i+\sum\limits_{x\inson}(K_x\varphi_{i}+B_x-E_x)}{\deg_i}\]</span></p><p>把这个式子表示成刚刚的形式：</p><p><span class="math display">\[\deg_i\varphi_i=\varphi_{fa}+E_i+\sum\limits_{x\inson}(K_x\varphi_{i}+B_x-E_x)\]</span></p><p><span class="math display">\[\deg_i\varphi_i=\varphi_{fa}+E_i+\varphi_i\sum\limits_{x\inson}K_x+\sum\limits_{x\in son}(B_x-E_x)\]</span></p><p><span class="math display">\[\varphi_i(\deg_i-\sum\limits_{x\inson}K_x)=\varphi_{fa}+E_i+\sum\limits_{x\in son}(B_x-E_x)\]</span></p><p><span class="math display">\[\varphi_i=\frac{1}{\deg_i-\sum\limits_{x\inson}K_x}\varphi_{fa}+\frac{\sum\limits_{x\inson}(B_x-E_x)+E_i}{\deg_i-\sum\limits_{x\in son}K_x}\]</span></p><p>我们发现此时已经表示成 <span class="math inline">\(\varphi_i=K_i\varphi_{fa}+B_i\)</span>的形式了。那么：</p><p><span class="math display">\[K_i=\frac{1}{\deg_i-\sum\limits_{x\inson}K_x}\]</span></p><p><span class="math display">\[B_i=\frac{\sum\limits_{x\inson}(B_x-E_x)+E_i}{\deg_i-\sum\limits_{x\inson}K_x}=K_i(\sum\limits_{x\in son}(B_x-E_x)+E_i)\]</span></p><p>因为我们要求 <span class="math inline">\(i\)</span>到地面，所以特判一下叶子。叶子度数为 <span class="math inline">\(2\)</span>，一条边连向地面，地面电势为 <span class="math inline">\(0\)</span>。</p><h1><span id="code">Code</span></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="type">int</span> rt, n, m;</span><br><span class="line"><span class="type">int</span> deg[MAXN], fa[MAXN];</span><br><span class="line"><span class="type">double</span> k[MAXN], b[MAXN], sumb[MAXN], ph[MAXN], sumph[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt] = (Edge)&#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    edge[++cnt] = (Edge)&#123;u, head[v]&#125;;</span><br><span class="line">    head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    <span class="type">double</span> sumk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v != f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">init</span>(v, u);</span><br><span class="line">            sumk += k[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k[u] = <span class="number">1.0</span> / (deg[u] - sumk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sumb[fa[u]] -= b[u];</span><br><span class="line">        b[u] = (sumb[u] + sumph[u] - ph[u]) * k[u];</span><br><span class="line">        sumb[fa[u]] += b[u];</span><br><span class="line">        <span class="built_in">add</span>(fa[u], e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[v] == u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">        e = -e;</span><br><span class="line">    &#125;</span><br><span class="line">    ph[u] -= e;</span><br><span class="line">    sumph[v] -= e;</span><br><span class="line">    <span class="built_in">add</span>(u, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> k[u] * <span class="built_in">query</span>(fa[u]) + b[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v);</span><br><span class="line">        deg[u]++, deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_edge</span>(i, <span class="number">0</span>);</span><br><span class="line">            deg[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">1</span>) deg[i] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, <span class="built_in">query</span>(u));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u, v, e;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;e);</span><br><span class="line">            <span class="built_in">modify</span>(u, v, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在各学科交叉应用的潮流下，一道具有超前预见性的好题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>初赛知识点整理第2版</title>
    <link href="http://summace.cc/Pre2/"/>
    <id>http://summace.cc/Pre2/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:16:07.063Z</updated>
    
    <content type="html"><![CDATA[<p>NOIP 初赛知识点整理 第2版。</p><p>温馨提示：不保证对，但也不保证错。</p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=1819306496&amp;auto=1&amp;height=66"></iframe><h1><span id="一-noi-史">一、NOI 史</span></h1><ol type="1"><li>NOI 于 <span class="math inline">\(1984\)</span> 年首次举行。</li><li>NOIP 于 <span class="math inline">\(1995\)</span> 年首次举行。</li><li>NOIP 于 <span class="math inline">\(2019\)</span> 年暂停。</li><li>CSP 于 <span class="math inline">\(2019\)</span> 年首次举行。</li><li>NOIP 于 <span class="math inline">\(2020\)</span> 年恢复。</li></ol><h1><span id="二-计算机发展史">二、计算机发展史</span></h1><ul><li><span class="math inline">\(1944\)</span>年，<strong>美籍匈牙利</strong>数学家<strong>冯·诺依曼</strong>提出计算机基本结构和工作方式的设想，为计算机的诞生和发展提供了理论基础。</li><li><span class="math inline">\(1946\)</span> 年，世界上第一台电子计算机<strong>ENIAC</strong> 在美国宾夕法尼亚大学诞生。</li></ul><table><thead><tr class="header"><th style="text-align: center;">代别</th><th style="text-align: center;">年代</th><th style="text-align: center;">电子元件</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">第一代</td><td style="text-align: center;"><span class="math inline">\(1946-1958\)</span></td><td style="text-align: center;">电子管</td></tr><tr class="even"><td style="text-align: center;">第二代</td><td style="text-align: center;"><span class="math inline">\(1959-1964\)</span></td><td style="text-align: center;">晶体管</td></tr><tr class="odd"><td style="text-align: center;">第三代</td><td style="text-align: center;"><span class="math inline">\(1965-1970\)</span></td><td style="text-align: center;">集成电路</td></tr><tr class="even"><td style="text-align: center;">第四代</td><td style="text-align: center;"><span class="math inline">\(1970-\text{今}\)</span></td><td style="text-align: center;">大规模、超大规模集成电路</td></tr></tbody></table><h1><span id="三-计算机著名人物及奖项">三、计算机著名人物及奖项</span></h1><h2><span id="艾伦麦席森图灵alanmathison-turing英国人">艾伦·麦席森·图灵(AlanMathison Turing，英国人)</span></h2><p>被称为计算机科学之父，人工智能之父。图灵对于人工智能的发展有诸多贡献，例如图灵曾写过一篇名为《计算机器和智能》的论文，提问“机器会思考吗？”（CanMachinesThink?），作为一种用于判定机器是否具有智能的测试方法，即图灵测试。至今，每年都有试验的比赛。此外，图灵提出的著名的图灵机模型为现代计算机的逻辑工作方式奠定了基础。</p><h2><span id="约翰冯诺依曼johnvon-neumann美籍匈牙利人">约翰·冯·诺依曼(Johnvon Neumann，美籍匈牙利人)</span></h2><p>被后人称为“现代计算机之父”、“博弈论之父”。1945年6月，冯·诺伊曼与戈德斯坦、勃克斯等人，联名发表了一篇长达101页纸的报告，即计算机史上著名的“101页报告”，是现代计算机科学发展里程碑式的文献。明确规定用二进制替代十进制运算，并将计算机分成5大组件，这一卓越的思想为电子计算机的逻辑结构设计奠定了基础，已成为计算机设计的基本原则。1951年，EDVAC计算机宣告完成。</p><h2><span id="图灵奖acm-am-turing-award">图灵奖(ACM A.M Turing Award)</span></h2><p>美国计算机协会（ACM）于1966年设立的奖项，专门奖励对计算机事业作出重要贡献的个人。其名称取自世界计算机科学的先驱、英国科学家、曼彻斯特大学教授艾伦·图灵（A.M.Turing），这个奖设立目的之一是纪念这位现代计算机科学的奠基者。获奖者必须是在计算机领域具有持久而重大的先进性的技术贡献。大多数获奖者是计算机科学家。图灵奖是计算机界最负盛名的奖项，有“计算机界诺贝尔奖”之称。</p><h1><span id="四-linux-基本操作">四、Linux 基本操作</span></h1><h2><span id="目录切换命令-cd">目录切换命令 <code>cd</code></span></h2><ul><li><code>cd xxx/</code> 切换到该目录下 <code>xxx</code> 目录</li><li><code>cd …/</code> 切换到上一层目录</li><li><code>cd /</code> 切换到系统根目录</li><li><code>cd ~</code> 切换到用户主目录</li></ul><h2><span id="目录操作命令">目录操作命令</span></h2><ul><li><code>mkdir xxx</code> 新建名为 <code>xxx</code> 的文件夹（可能需要<code>sudo</code>）</li><li><code>ls xxx</code> 显示 <code>xxx</code> 下所有文件和目录</li><li><code>ls -a</code> 显示所有文件和目录（包括隐藏文件）</li><li><code>ls -l</code> 显示所有文件和目录（包括详细信息）</li><li><code>find xxx -name 'yyy'</code> 寻找 <code>xxx</code> 目录下名为<code>yyy</code> 相关的文件</li><li><code>mv xxx yyy</code> 重命名（目录文件均可）</li><li><code>cp -r xxx yyy</code> 把 <code>xxx</code> 拷贝到<code>yyy</code> 位置</li><li><code>rm [-rf] xxx</code> 删除 <code>xxx</code></li></ul><h2><span id="文件操作命令">文件操作命令</span></h2><ul><li><code>touch xxx</code> 新建 <code>xxx</code> 文件</li><li><code>cat xxx</code> 显示 <code>xxx</code> 文件</li><li><code>vim xxx</code> 修改 <code>xxx</code> 文件</li></ul><h1><span id="五-计算机基础架构">五、计算机基础架构</span></h1><p>现代计算机基本为冯·诺依曼架构，即硬件部分分为五部分：运算器、控制器、存储器、输入设备、输出设备。</p><h2><span id="运算器">运算器</span></h2><p>计算机硬件中的运算器主要功能是对数据和信息进行运算和加工。运算器包括以下几个部分：通用寄存器、状态寄存器、累加器和关键的算术逻辑单元。运算器可以进行算术计算（加减乘除）和逻辑运算（与或非）。</p><h2><span id="控制器">控制器</span></h2><p>控制器和运算器共同组成了中央处理器<span class="math inline">\((CPU)\)</span>。控制器可以看作计算机的大脑和指挥中心，它通过整合分析相关的数据和信息，可以让计算机的各个组成部分有序地完成指令。</p><h2><span id="存储器">存储器</span></h2><p>顾名思义，存储器就是计算机的记忆系统，是计算机系统中的记事本。而和记事本不同的是，存储器不仅可以保存信息，还能接受计算机系统内不同的信息并对保存的信息进行读取。存储器由主存和辅存组成，主存就是通常所说的内存，分为<span class="math inline">\(RAM\)</span> 和 <span class="math inline">\(ROM\)</span>两个部分。辅存即外存，但是计算机在处理外存的信息时，必须首先经过内外存之间的信息交换才能够进行。</p><h1><span id="六-计算机硬件系统">六、计算机硬件系统</span></h1><h2><span id="cpu中央处理器"><span class="math inline">\(CPU\)</span>(中央处理器)</span></h2><p>由运算器、控制器和一些寄存器组成；作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。<span class="math inline">\(CPU\)</span>的主要性能指标是主频和字长。</p><h3><span id="主频">主频</span></h3><p>主频是指计算机 <span class="math inline">\(CPU\)</span>的时钟频率，它在很大程度上决定了计算机的运算速度。一般时钟频率越高，运算速度就越快。主频的单位一般是<span class="math inline">\(MHz\)</span>（兆赫）或 <span class="math inline">\(GHz\)</span>（吉赫）。</p><h3><span id="字长">字长</span></h3><p>字长是指一台计算机所能处理的二进制代码的位数。计算机的字长直接影响到它的精度、功能和速度。字长愈长，能表示的数值范围就越大，计算出的结果的有效位数也就越多；字长愈长，能表示的信息就越多，机器的功能就更强。常用的有<span class="math inline">\(32\)</span> 位、<span class="math inline">\(64\)</span> 位字长。</p><h2><span id="存储器">存储器</span></h2><p>存储器的主要功能是用来保存各类程序的数据信息。存储器可分为主存储器和辅助存储器两类。</p><h3><span id="主存储器">主存储器</span></h3><p>主存储器（也称为内存储器），属于主机的一部分。用于存放系统当前正在执行的数据和程序，属于临时存储器。</p><p>它和 <span class="math inline">\(CPU\)</span>一起构成了计算机的主机部分，它存储的信息可以被 <span class="math inline">\(CPU\)</span>直接访问。内存由半导体存储器组成，存取速度较快，但一般容量较小。</p><p>内存储器通常可以分为随机存储器 <span class="math inline">\(RAM\)</span>、只读存储器 <span class="math inline">\(ROM\)</span> 和高速缓冲存储器 <span class="math inline">\(Cache\)</span> 三种。</p><ul><li><span class="math inline">\(RAM(Random\ Access\ Memory)\)</span>是一种读写存储器，其内容可以随时根据需要读出，也可以随时重新写入新的信息。当电源电压去掉时，RAM中保存的信息都将全部丢失。</li><li><span class="math inline">\(ROM(Read-Only\ Memory)\)</span>是一种内容只能读出而不能写入和修改的存储器，其存储的信息是在制作该存储器时就被写入的。在计算机运行过程中，<span class="math inline">\(ROM\)</span>中的信息只能被读出，而不能写入新的内容。计算机断电后，<span class="math inline">\(ROM\)</span>中的信息不会丢失。它主要用于检查计算机系统的配置情况并提供最基本的输入/输出<span class="math inline">\((I/O)\)</span>控制程序。</li><li><span class="math inline">\(Cache\)</span>是高速缓冲存储器。由于计算机的 <span class="math inline">\(CPU\)</span>速度的不断提高，RAM的速度很难满足高速 <span class="math inline">\(CPU\)</span>的要求，所以在读/写系统内存都要加入等待的时间，这对高速 <span class="math inline">\(CPU\)</span> 来说是一种极大的浪费。<span class="math inline">\(Cache\)</span> 是指在 <span class="math inline">\(CPU\)</span>与内存之间设置的一级或两级高速小容量存储器，固化在主板上。在计算机工作时，系统先将数据由外存读入<span class="math inline">\(RAM\)</span> 中，再由 <span class="math inline">\(RAM\)</span> 读入 <span class="math inline">\(Cache\)</span> 中，然后 <span class="math inline">\(CPU\)</span> 直接从 <span class="math inline">\(Cache\)</span> 中取数据进行操作。</li></ul><h3><span id="辅助存储器">辅助存储器</span></h3><p>辅助存储器（也称外存储器），它属于外部设备。用于存放暂不用的数据和程序，属于永久存储器。</p><p>它的容量一般都比较大，而且大部分可以移动，便于在不同计算机之间进行信息交流。在微型计算机中，常用的外存有软盘、硬盘、闪存和光盘。</p><ul><li><strong>软盘存储器</strong>由软盘、软盘驱动器和软盘适配器三部分组成。软盘是活动的存储介质，软盘驱动器是读写装置，软盘适配器是软盘驱动器与主机连接的接口。软盘驱动器安装在主机箱内，软盘驱动器插槽暴露在主机箱的前面板上，可方便地插入或取出软盘。 </li><li><strong>硬盘存储器</strong>是由电机和硬盘组成的，一般置于主机箱内。硬盘是涂有磁性材料的磁盘组件，用于存放数据。硬盘的机械转轴上串有若干个盘片，每个盘片的上下两面各有一个读/写磁头，与软盘磁头不同，硬盘的磁头不与磁盘表面接触，它们在离盘片面百万分之一英寸的气垫上。硬盘是一个非常精密的机械装置，磁道间只有百万分之几英寸的间隙，磁头传动装置必须把磁头快速而准确地移到指定的磁道上。 </li><li><strong>闪存</strong>又名优盘，是在存储速度与容量上介于软盘与硬盘之间的一种外部存储器。  </li><li><strong>光盘</strong>的存储介质不同于磁盘，它属于另一类存储器。由于光盘的容量大、存取速度较快、不易受干扰等特点，其应用越来越广泛。光盘根据其制造材料和记录信息方式的不同一般分为三类：只读光盘、一次写入型光盘和可擦写光盘。</li></ul><h1><span id="七-计算机语言">七、计算机语言</span></h1><p>计算机语言可以分为三类：机器语言、汇编语言、高级语言。</p><h2><span id="机器语言">机器语言</span></h2><p>计算机最早的语言处理程序是机器语言，它是计算机能直接识别的语言，而且速度快。机器语言是用二进制代码来编写计算机程序，因此又称二进制语言。</p><h2><span id="汇编语言">汇编语言</span></h2><p>由于机器语言的记忆困难，汇编语言开始用一些符号代替机器指令。但是用汇编语言编写的源程序不能被计算机直接识别，必须使用特定程序将用汇编语言写的源程序翻译和连接成能被计算机直接识别的二进制代码。</p><h2><span id="高级语言">高级语言</span></h2><h3><span id="翻译方式">翻译方式</span></h3><p>计算机并不能直接地接受和执行用高级语言编写的源程序，源程序在输入计算机时，通过程序翻译成机器语言形式的目标程序，通常有两种方式，即编译方式和解释方式。</p><ul><li>编译方式：编译方式的翻译工作由编译程序来完成，它先将整个源程序都转换成二进制代码，生成目标程序，把目标程序和可执行程序连接。</li><li>解释方式：源程序进入计算机时，解释程序边扫描边解释，对源程序的语句解释一条，执行一条，不产生目标程序。</li></ul><h3><span id="面向对象与面向过程">面向对象与面向过程</span></h3><ul><li><p>面向过程 <span class="math inline">\((Procedure\Oriented)\)</span>：把事情拆分成几个步骤（相当于拆分成一个个的方法和数据），然后按照一定的顺序执行。</p></li><li><p>面向对象 <span class="math inline">\((Object\Oriented)\)</span>：面向对象会把事物抽象成对象的概念，先抽象出对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法。</p></li></ul><h3><span id="常见语言">常见语言</span></h3><table><thead><tr class="header"><th style="text-align: center;">语言</th><th style="text-align: center;">面向对象/面向过程</th><th style="text-align: center;">翻译方式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">面向过程</td><td style="text-align: center;">编译方式</td></tr><tr class="even"><td style="text-align: center;">C++</td><td style="text-align: center;">半面向对象</td><td style="text-align: center;">编译方式</td></tr><tr class="odd"><td style="text-align: center;">Java</td><td style="text-align: center;">面向对象</td><td style="text-align: center;">不属于（更接近于解释方式）</td></tr><tr class="even"><td style="text-align: center;">Python</td><td style="text-align: center;">面向对象</td><td style="text-align: center;">解释方式</td></tr><tr class="odd"><td style="text-align: center;">Pascal</td><td style="text-align: center;">面向对象</td><td style="text-align: center;">编译方式</td></tr><tr class="even"><td style="text-align: center;">Fortran</td><td style="text-align: center;">面向过程</td><td style="text-align: center;">编译方式</td></tr></tbody></table><h1><span id="八-网络及网络协议">八、网络及网络协议</span></h1><p>所谓计算机网络，就是利用通信线路和设备，把分布在不同地理位置上的多台计算机连接起来。计算机网络是现代通信技术与计算机技术相结合的产物。</p><figure><img src="https://z3.ax1x.com/2021/09/07/hT3wND.jpg" alt="协议"><figcaption aria-hidden="true">协议</figcaption></figure><h2><span id="网络协议">网络协议</span></h2><p>网络中计算机与计算机之间的通信依靠协议进行。协议是计算机收、发数据的规则。</p><ol type="1"><li><p>HTTP协议：基于TCP协议，超文本传输协议，对应于应用层，用于如何封装数据。也就是在底层是基于socket，http只不过是在收发数据的时候定义了很多规则，http头信息之类。</p></li><li><p>TCP/IP协议：关注的是客户端与服务器之间的数据传输是否成功（三次握手，传输失败会重发）。传输层协议，主要解决数据如何在网络中传输.</p></li><li><p>TCP/UDP协议:传输控制协议，对应于传输层，主要解决数据在网络中的传输。</p></li><li><p>IP 协议：对应于网络层，同样解决数据在网络中的传输。</p></li><li><p>TCP 协议：对应于传输层，是基于网络层的IP协议。</p></li><li><p>socket：属于传输层协议，是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p></li></ol><h3><span id="电子邮件协议全部隶属于tcpip协议">电子邮件协议(全部隶属于TCP/IP协议)</span></h3><ol type="1"><li>SMTP 协议：简单邮件传输协议(TCP25端口)；</li><li>POP3 协议：POP邮局协议第三版本(TCP110端口)；</li><li>IMAP 协议：互联网信息访问协议(TCP143端口)；</li></ol><h2><span id="网络简述">网络简述</span></h2><ol type="1"><li>LAN：局域网</li><li>WAN：广域网</li><li>MAN：城域网</li><li>WLAN：无线局域网</li><li>WWAN：无线广域网</li><li>WMAN：无线城域网</li></ol><h1><span id="九-进制转换">九、进制转换</span></h1><h2><span id="概述">概述</span></h2><p>常见进制有十进制、八进制、二进制、十六进制。</p><p><span class="math inline">\(N\)</span>进制逢<span class="math inline">\(N\)</span>进一，十六进制 <span class="math inline">\(10-15\)</span> 分别用 <span class="math inline">\(A-F\)</span> 表示。</p><p><span class="math inline">\(N\)</span>进制的数一般用 <span class="math inline">\((\overline{qwq})_{N}\)</span> 表示。</p><h2><span id="十进制转x进制">十进制转<span class="math inline">\(X\)</span>进制</span></h2><p>短除法。</p><h2><span id="x进制转十进制"><span class="math inline">\(X\)</span>进制转十进制</span></h2><p><span class="math inline">\((N)_{X}\)</span> 转为 <span class="math inline">\((M)_{10}\)</span>。</p><p>记 <span class="math inline">\(N_i\)</span> 表示 <span class="math inline">\((N)_{X}\)</span> 从低位向高位第 <span class="math inline">\(i\)</span> 位的数，<span class="math inline">\(SW_N\)</span> 为 <span class="math inline">\((N)_{X}\)</span> 的数位数。</p><p><span class="math inline">\(M = \sum\limits_{i=1}^{SW_N} N_i\timesX^{i-1}\)</span></p><h1><span id="十-信息编码">十、信息编码</span></h1><h2><span id="二进制编码">二进制编码</span></h2><ul><li>原码（原码表示法）：十进制数直接转换来的二进制数。值得注意的是，原码的最高位是符号位：整数为<span class="math inline">\(0\)</span>，负数为 <span class="math inline">\(1\)</span>。 <span class="math inline">\(x=1100110\)</span>，则<span class="math inline">\([x]原=01100110\)</span>； <span class="math inline">\(x=-1100111\)</span>，则<span class="math inline">\([x]原=11100111\)</span>。</li><li>反码：正数的反码是本身，负数的反码是其除符号位之外的所有位按位取反的结果。<span class="math inline">\(x=1100110\)</span>，则<span class="math inline">\([x]反=01100110\)</span>； <span class="math inline">\(x=-1100111\)</span>，则<span class="math inline">\([x]反=10011000\)</span>。</li><li>补码：正数的补码是其本身，复数的补码是其反码加一。 <span class="math inline">\(x=1100110\)</span>，则<span class="math inline">\([x]补=01100110\)</span>； <span class="math inline">\(x=-1100111\)</span>，则<span class="math inline">\([x]补=10011001\)</span>。</li></ul><h2><span id="textascii码"><span class="math inline">\(\text{ASCII}\)</span>码</span></h2><p><span class="math inline">\(\text{ASCII}\)</span>编码是由美国国家标准委员会制定的一种包括数字、字母、通用符号和控制符号在内的字符编码集，全称叫美国国家信息交换标准代码。</p><figure><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.51wendang.com%2Fpic%2F7f94132e26a37161b8794dd4%2F1-1355-png_6_0_0_0_0_959_1355_959_1355-959-0-0-959.jpg&amp;refer=http%3A%2F%2Fimg.51wendang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664800854&amp;t=7ad119d038c8e89713f2b37400ee1179" alt="ASCII"><figcaption aria-hidden="true">ASCII</figcaption></figure><h1><span id="十一-计算机安全常识">十一、计算机安全常识</span></h1><p>计算机病毒是一种人为制造的能够侵入计算机系统并给计算机带来故障的程序或指令集合。</p><p>计算机病毒具有传播性、潜伏性、破坏性与隐蔽性的特点。</p><h1><span id="十二-运算相关知识">十二、运算相关知识</span></h1><h2><span id="逻辑运算">逻辑运算</span></h2><ol type="1"><li><p>逻辑与：<span class="math inline">\(\&amp;\&amp;\)</span> 或<span class="math inline">\(∧\)</span>，同 <span class="math inline">\(T\)</span> 则 <span class="math inline">\(T\)</span>，否则为 <span class="math inline">\(F\)</span>。</p></li><li><p>逻辑或：<span class="math inline">\(||\)</span> 或 <span class="math inline">\(∨\)</span>，有 <span class="math inline">\(T\)</span> 则 <span class="math inline">\(T\)</span>，否则为 <span class="math inline">\(F\)</span>。</p></li><li><p>逻辑非：<span class="math inline">\(!\)</span> 或 <span class="math inline">\(┐\)</span>，为 <span class="math inline">\(T\)</span> 则 <span class="math inline">\(F\)</span>，反之亦然。</p></li><li><p>逻辑异或：^ 或 <span class="math inline">\(⊕\)</span>，同为 <span class="math inline">\(F\)</span>，异为 <span class="math inline">\(T\)</span>。</p></li></ol><h2><span id="位运算">位运算</span></h2><ol type="1"><li>按位与：<span class="math inline">\(\&amp;\)</span>，类似于逻辑与。</li><li>按位或：<span class="math inline">\(|\)</span>，类似于逻辑或。</li><li>按位反：~，类似于逻辑非。</li><li>左移：<span class="math inline">\(&lt;&lt;\)</span>，左移 <span class="math inline">\(x\)</span> 位相当于乘 <span class="math inline">\(2^x\)</span>。</li><li>右移：<span class="math inline">\(&gt;&gt;\)</span>，右移 <span class="math inline">\(x\)</span> 位相当于除 <span class="math inline">\(2^x\)</span>。</li></ol><h1><span id="十三-图论相关">十三、图论相关</span></h1><h2><span id="概念">概念</span></h2><ul><li><strong>图(Graph)</strong> 是一个二元组 <span class="math inline">\(G=(V(G),E(G))\)</span>，其中 <span class="math inline">\(V(G)\)</span> 为点集，<span class="math inline">\(E(G)\)</span> 为边集。</li><li><strong>无向图(Undirected Graph)</strong>，边是双向的。</li><li><strong>有向图(Directed Graph)</strong>，边是单向的。</li><li><strong>自环(Loop)</strong>，对于某条边 <span class="math inline">\(e=(u,u)\)</span>，则称其为一个自环。</li><li><strong>重边(Multiple Edge)</strong>，图中存在两个相同的边。</li><li><strong>简单图(Simple Graph)</strong>，一个图中没有自环和重边。</li><li><strong>完全图(CompleteGraph)</strong>，任意两点都有边相连。若一个图的点为 <span class="math inline">\(n\)</span>，则边的个数为 <span class="math inline">\(\frac{n(n-1)}{2}\)</span></li><li><strong>平面图</strong>，没有边相交的图。四个点的完全图是一个平面图，五个点完全图任意去掉一条边都是平面图。</li><li><strong>连通图(Connected Graph)</strong>，任意两点都可以到达。</li><li><strong>有向无环图(DAG)</strong>，顾名思义。它可以拓扑排序。</li><li><strong>树(Tree)</strong>，无向无环连通图，且 <span class="math inline">\(n\)</span> 个节点的树有 <span class="math inline">\(n-1\)</span> 条边。</li><li><strong>森林(forest)</strong>：每个连通分量（连通块）都是树的图。按照定义，棵树也是森林。</li><li><strong>结点的深度(depth)</strong>：到根结点的路径上的边数。</li><li><strong>树的高度(height)</strong>：所有结点的深度的最大值。</li><li><strong>叶结点（leaf node）</strong>：没有子结点的结点。</li><li><strong>父亲（parentnode）</strong>：对于除根以外的每个结点，定义为从该结到根路径上的第二个结点。</li><li><strong>祖先（ancestor）</strong>：一个结点到根结点的路径上，<strong>包括它本身</strong>的所有节点。</li></ul><h1><span id="十四-排列组合">十四、排列组合</span></h1><h2><span id="加法原理与乘法原理">加法原理与乘法原理</span></h2><ul><li>加法原理：有 <span class="math inline">\(n\)</span> 类元素，第 <span class="math inline">\(i\)</span> 类有 <span class="math inline">\(c_i\)</span>个元素，每类选一个元素，求方案数。</li><li>乘法原理：有 <span class="math inline">\(n\)</span> 组元素，第 <span class="math inline">\(i\)</span> 组有 <span class="math inline">\(c_i\)</span>个元素，每组选一个元素，求方案数。</li><li>加法原理实际上是分类，乘法原理实际上是分步。</li></ul><h2><span id="排列与组合">排列与组合</span></h2><h3><span id="排列">排列</span></h3><p>在 <span class="math inline">\(n\)</span>个数中<strong>有序</strong>选择 <span class="math inline">\(k\)</span>个数，方案数记为：</p><p><span class="math inline">\(A_{n}^{k}=\frac{n!}{(n-k)!}\)</span></p><h3><span id="组合">组合</span></h3><p>在 <span class="math inline">\(n\)</span>个数中<strong>无序</strong>选择 <span class="math inline">\(k\)</span>个数，方案数记为：</p><p><span class="math inline">\(C_{n}^{k}=\frac{n!}{k!(n-k)!}\)</span></p><p>在竞赛中也常记为：</p><p><span class="math inline">\({n\choose k} =\frac{n!}{k!(n-k)!}\)</span></p><p>组合数的一些性质：</p><ul><li><span class="math inline">\({n\choose k}={n\choose n-k}\)</span>考虑从 <span class="math inline">\(n\)</span> 个中选 <span class="math inline">\(k\)</span> 个相当于从 <span class="math inline">\(n\)</span> 个中不选 <span class="math inline">\(n-k\)</span> 个。</li><li>递推计算：<span class="math inline">\({n\choose k}={n-1\choosek}+{n-1\choose k-1}\)</span> 从 <span class="math inline">\(n\)</span>个物品里面选 <span class="math inline">\(k\)</span> 个出来，考虑第 <span class="math inline">\(n\)</span> 个选不选。如果选就变成了从 <span class="math inline">\(n−1\)</span> 个里选 <span class="math inline">\(k-1\)</span>；否则就是从 <span class="math inline">\(n-1\)</span> 个里选 <span class="math inline">\(k\)</span>。</li><li>二项式定理：<span class="math inline">\((a+b)^n=\sum\limits_{i=0}^{n}{n\choosei}a^ib^{n-i}\)</span></li><li><span class="math inline">\(\sum\limits_{i=0}^{n}{n\choosei}=2^n\)</span></li><li><span class="math inline">\({a+b\choosek}=\sum\limits_{i=0}^{k}{a\choose i}{b\choose k-i}\)</span></li></ul><h2><span id="答题方法">答题方法</span></h2><h3><span id="枚举法">枚举法</span></h3><p>最基本的方法，当题目范围不大的时候可以考虑枚举。</p><h3><span id="插板法">插板法</span></h3><p>例：学校师生合影，共 <span class="math inline">\(8\)</span>个学生，<span class="math inline">\(4\)</span>个老师，要求老师在学生中间，且老师互不相邻，共有多少种不同的合影方式？</p><p>解：先排学生共有 <span class="math inline">\(A_{8}^{8}\)</span>种排法，然后把老师插入学生之间的空档，共有 <span class="math inline">\(7\)</span> 个空档可插，选其中的 <span class="math inline">\(4\)</span> 个空档,共 <span class="math inline">\(A_{7}^{4}\)</span>种选法。根据乘法原理，共有的不同坐法 <span class="math inline">\(A_{8}^{8}A_{7}^{4}\)</span> 种。</p><h3><span id="捆绑法">捆绑法</span></h3><p>例：<span class="math inline">\(5\)</span> 个男生 <span class="math inline">\(3\)</span> 个女生排成一排，<span class="math inline">\(3\)</span>个女生要排在一起，有多少种不同的排法？</p><p>解：因为女生要排在一起，所以可以将 <span class="math inline">\(3\)</span> 个女生看成是一个人，与 <span class="math inline">\(5\)</span> 个男生作全排列，有 <span class="math inline">\(A_{6}^{6}\)</span> 种排法，其中女生内部也有 <span class="math inline">\(A_{3}^{3}\)</span> 种排法，根据乘法原理，共有<span class="math inline">\(A_{6}^{6}A_{3}^{3}\)</span>种不同的排法。</p><h3><span id="对等法">对等法</span></h3><p>例：学校安排考试科目 <span class="math inline">\(9\)</span>门，语文要在数学之前考，有多少种不同的安排顺序?</p><p>解：不加任何限制条件，整个排法有 <span class="math inline">\(A_{9}^{9}\)</span>种，“语文安排在数学之前考”与“数学安排在语文之前考”的排法是相等的，所以语文安排在数学之前考的排法共<span class="math inline">\(\frac{1}{2}A_{9}^{9}\)</span>种。</p><h2><span id="卡特兰数">卡特兰数</span></h2><p>卡特兰数的定义如下：</p><p><span class="math inline">\(C_0=0,C_1=1\)</span></p><p><span class="math inline">\(C_n=\sum\limits_{i=0}^{n-1}C_iC_{n-i-1}(n\geq2)\)</span></p><p>非递推式：</p>$C_n={2n\choose n}-{2n\choose n+1}=\frac{{2n\choose n}}{n+1}$<p>卡特兰数的组合意义：</p><ol type="1"><li><span class="math inline">\(n\)</span> 个点的二叉树</li><li><span class="math inline">\(n+1\)</span> 个点的区分儿子顺序的树</li><li><span class="math inline">\(2n+1\)</span>个点的二叉树，满足没有儿子个数为 <span class="math inline">\(1\)</span>的节点</li><li>长度为 <span class="math inline">\(2n\)</span> 的合法括号匹配</li><li>长度为 <span class="math inline">\(2n\)</span>的字符串的数量，其中有 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(0\)</span>，<span class="math inline">\(n\)</span>个 <span class="math inline">\(1\)</span>，且对于任意的 <span class="math inline">\(i\)</span>，<span class="math inline">\(0\)</span>的数量都不少于 <span class="math inline">\(1\)</span> 的。</li><li><span class="math inline">\(2\times n\)</span> 的杨表数量。</li></ol><p>证明略。</p><h2><span id="容斥原理">容斥原理</span></h2><p><span class="math inline">\(\left|\bigcup\limits_{i=1}^{n}S_i\right|=\sum\limits_{m=1}^n(-1)^{m-1}\sum\limits_{a_i&lt;a_{i+1}}\left|\bigcap\limits_{i=1}^mS_{a_i}\right|\)</span></p><p>简单的小应用：</p><p><span class="math inline">\(|A\cup B\cup C|=|A|+|B|+|C|-|A\capB|-|B\cap C|-|C\cap A|+|A\cap B\cap C|\)</span></p><h1><span id="十五-时空复杂度相关">十五、时空复杂度相关</span></h1><ul><li>时间复杂度：算法的时间复杂度<span class="math inline">\(\text{(TimeComplexity)}\)</span>是指算法所需要的计算工作量，用算法所执行的基本运算次数来度量。</li><li>空间复杂度：算法的空间复杂度<span class="math inline">\(\text{(SpaceComplexity)}\)</span>是指执行这个算法所需要的内存空间。</li></ul><h2><span id="主定理">主定理</span></h2><p>在算法分析中，主定理 <span class="math inline">\(\text{(mastertheorem)}\)</span> 提供了用渐近符号（大 <span class="math inline">\(O\)</span>符号）表示许多由分治法得到的递推关系式的方法。</p><h3><span id="支配理论">支配理论</span></h3><p>假设有递归关系式：</p>$$T(n)=aT\left(\frac{n}{b}\right)+f(n),其中a\geq 1,b> 1$$<p>其中：</p><ul><li><span class="math inline">\(n\)</span> 为问题规模；</li><li><span class="math inline">\(a\)</span> 为递归的子问题数量；</li><li><span class="math inline">\(\frac{n}{b}\)</span>为每个子问题的规模（假设每个子问题的规模基本相同）；</li><li><span class="math inline">\(f(n)\)</span>为递归以外进行的计算工作。</li></ul><h3><span id="情形一">情形一</span></h3><p>若 <span class="math inline">\(f(n)&lt;n^{\log_ba}\)</span>（多项式的小于），即 <span class="math inline">\(\exist\epsilon&gt;0,有f(n)=\Theta(n^{\log_{b}a-\epsilon})\)</span>，则<span class="math inline">\(T(n)=\Theta(n^{\log_{b}a})\)</span></p><h3><span id="情形二">情形二</span></h3><p>若 <span class="math inline">\(f(n)=n^{\log_b a}\)</span>，即 <span class="math inline">\(\exist \epsilon\geq0,有f(n)=\Theta(n^{\log_{b}a}\log^\epsilon n)\)</span>，则<span class="math inline">\(T(n)=\Theta(n^{\log_{b}a}\log^{\epsilon+1}n)\)</span></p><h3><span id="情形三">情形三</span></h3><p>若 <span class="math inline">\(f(n)&gt;n^{\log_ba}\)</span>（多项式的大于），即 <span class="math inline">\(\exist\epsilon&gt;0,有f(n)=\Omega(n^{\log_{b}a+\epsilon})\)</span>，同时存在常数 <span class="math inline">\(c&lt;1\)</span> 以及充分大的 <span class="math inline">\(n\)</span>，满足 <span class="math inline">\(af\left(\frac{n}{b}\right)\leqcf(n)\)</span>，则<span class="math inline">\(T(n)=\Theta(f(n))\)</span></p><h2><span id="常见排序算法与其时空复杂度">常见排序算法与其时空复杂度</span></h2><table><thead><tr class="header"><th style="text-align: center;">排序方法</th><th style="text-align: center;">时间复杂度</th><th style="text-align: center;">辅助存储空间复杂度</th><th style="text-align: center;">稳定性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">插入排序</td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;">冒泡排序</td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="odd"><td style="text-align: center;">选择排序</td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="even"><td style="text-align: center;">快速排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)-O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(\logn)-O(n)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="odd"><td style="text-align: center;">希尔排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="even"><td style="text-align: center;">堆排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="odd"><td style="text-align: center;">归并排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;">基数排序</td><td style="text-align: center;"><span class="math inline">\(O(d(n+r))\)</span></td><td style="text-align: center;"><span class="math inline">\(O(rd+1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="odd"><td style="text-align: center;">桶排序</td><td style="text-align: center;"><span class="math inline">\(O(\max\{value\})\)</span></td><td style="text-align: center;"><span class="math inline">\(O(\max\{value\})\)</span></td><td style="text-align: center;">稳定</td></tr></tbody></table><h1><span id="十六-后记">十六、后记</span></h1><h2><span id="说些什么">说些什么</span></h2><p>又是一年初赛季，回首过去的一篇<a href="https://w-rb.github.io/Pre/">NOIP初赛知识点整理</a>和过去忐忑的初赛经历，发现很多不足之处，遂写下本篇。仓促之下写完，也许未来还会有修修补补，也祝我们都能在初赛中取得好成绩。</p><h2><span id="参考与鸣谢">参考与鸣谢</span></h2><h3><span id="参考">参考</span></h3><ul><li><a href="https://blog.csdn.net/KImdaML/article/details/116570033">Linux的基础操作_KIMdamI</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC">约翰·冯·诺依曼_WikiPedia</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5">艾伦·图灵_WikiPedia</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96">图灵奖_WikiPedia</a></li><li><a href="https://blog.csdn.net/m0_63725962/article/details/123057876">面向对象和面向过程（总结版）_程序员这么可爱</a></li><li><a href="https://oi-wiki.org/graph/tree-basic/">树_OI-Wiki</a></li><li><a href="https://oi-wiki.org/graph/concept/">图_OI-Wiki</a></li><li>《信息学奥赛一本通 初赛篇》</li><li>历届 NOIP/CSP 初赛原题。</li><li>RainAir's PPT</li></ul><h3><span id="鸣谢">鸣谢</span></h3><ul><li><span class="math inline">\(\text{EXODUS}\)</span>对本文的审查。</li><li><span class="math inline">\(\text{lwj}\)</span> 对本文的勘误。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;NOIP 初赛知识点整理 第2版。&lt;/p&gt;
&lt;p&gt;温馨提示：不保证对，但也不保证错。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>初赛知识点整理</title>
    <link href="http://summace.cc/Pre/"/>
    <id>http://summace.cc/Pre/</id>
    <published>2021-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:03:43.095Z</updated>
    
    <content type="html"><![CDATA[<p>NOIP 初赛知识点整理。</p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=1498613705&amp;auto=1&amp;height=66"></iframe><h1><span id="一-信息学史">一、信息学史</span></h1><ol type="1"><li>第一台电子计算机：<span class="math inline">\(\text{ENIAC}\)</span>，美国宾夕法尼亚大学，1946年2月14日。</li><li><span class="math inline">\(\text{NOI}\)</span> 于<strong>1984年</strong> 首次举行。</li><li><span class="math inline">\(\text{NOIP}\)</span> 于<strong>1995年</strong> 首次举行。</li><li><span class="math inline">\(\text{NOIP}\)</span> 于<strong>2019年</strong> 暂停。</li><li><span class="math inline">\(\text{CSP}\)</span> 于<strong>2019年</strong> 首次举行。</li><li><span class="math inline">\(\text{NOIP}\)</span> 于<strong>2020年</strong> 恢复。</li><li><strong>2022年</strong>后，<span class="math inline">\(\text{NOI}\)</span> 系列赛事将停止对<strong>Pascal，C</strong> 语言的支持，仅允许使用 <strong>C++</strong>语言。</li></ol><h1><span id="二-信息学著名人物与奖项">二、信息学著名人物与奖项</span></h1><ol type="1"><li>图灵：艾伦·麦西森·图灵(Alan Mathison Turing)，被称为<strong>计算机科学之父</strong>、<strong>人工智能之父</strong>。</li><li>图灵奖：计算机界最高奖。</li><li>冯·诺依曼：约翰·冯·诺依曼(John vonNeumann)，<strong>现代计算机之父</strong>，<strong>博弈论之父</strong>，奠基现代计算机基本结构(冯·诺依曼体系计算机)。</li><li>姚期智，唯一一位华籍图灵奖获得者，清华大学人工智能姚班教授。</li></ol><h1><span id="三-现代计算机基础结构">三、现代计算机基础结构</span></h1><h2><span id="冯诺依曼架构">冯·诺依曼架构</span></h2><p>五大部分：</p><h3><span id="运算器">运算器</span></h3><p>计算机硬件中的运算器主要功能是对数据和信息进行运算和加工。运算器包括以下几个部分：通用寄存器、状态寄存器、累加器和关键的算术逻辑单元。运算器可以进行算术计算（加减乘除）和逻辑运算（与或非）。</p><h3><span id="控制器">控制器</span></h3><p>控制器和运算器共同组成了中央处理器（CPU）。控制器可以看作计算机的大脑和指挥中心，它通过整合分析相关的数据和信息，可以让计算机的各个组成部分有序地完成指令。</p><h3><span id="存储器">存储器</span></h3><p>顾名思义，存储器就是计算机的记忆系统，是计算机系统中的记事本。而和记事本不同的是，存储器不仅可以保存信息，还能接受计算机系统内不同的信息并对保存的信息进行读取。存储器由主存和辅存组成，主存就是通常所说的内存，分为RAM和ROM两个部分。辅存即外存，但是计算机在处理外存的信息时，必须首先经过内外存之间的信息交换才能够进行。</p><h3><span id="输入设备">输入设备</span></h3><p>略。</p><h3><span id="输出设备">输出设备</span></h3><p>略。</p><h2><span id="计算机硬件系统">计算机硬件系统</span></h2><h3><span id="中央处理器cpu">中央处理器(CPU)</span></h3><p>作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。由运算器和控制器组成。</p><p>目前知名品牌有 <span class="math inline">\(\text{Intel}\)</span> 和<span class="math inline">\(\text{AMD}\)</span>。</p><h3><span id="存储器">存储器</span></h3><h4><span id="只读存储器rom">只读存储器(ROM)</span></h4><p>以非破坏性读出方式工作，只能读出无法写入信息。信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器。</p><p>简要：断电不消失数据。</p><h4><span id="随机存储器ram">随机存储器(RAM)</span></h4><p>是与CPU直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。RAM工作时可以随时从任何一个指定的地址写入（存入）或读出（取出）信息。它与ROM的最大区别是数据的易失性，即一旦断电所存储的数据将随之丢失。RAM在计算机和数字系统中用来暂时存储程序、数据和中间结果。</p><p>简要：断电消失数据。</p><h1><span id="四-网络及网络协议">四、网络及网络协议</span></h1><figure><img src="https://z3.ax1x.com/2021/09/07/hT3wND.jpg" alt="协议"><figcaption aria-hidden="true">协议</figcaption></figure><h2><span id="协议简述">协议简述</span></h2><ol type="1"><li><p>HTTP协议：基于TCP协议，超文本传输协议，对应于应用层，用于如何封装数据.。也就是在底层是基于socket，http只不过是在收发数据的时候定义了很多规则，http头信息之类。</p></li><li><p>TCP/IP协议：关注的是客户端与服务器之间的数据传输是否成功（三次握手，传输失败会重发）。传输层协议，主要解决数据如何在网络中传输；</p></li><li><p>TCP/UDP协议:传输控制协议，对应于传输层，主要解决数据在网络中的传输。</p></li><li><p>IP 协议：对应于网络层，同样解决数据在网络中的传输。</p></li><li><p>TCP协议：对应于传输层，是基于网络层的IP协议。</p></li><li><p>socket：属于传输层协议，是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p></li></ol><h3><span id="电子邮件协议全部隶属于tcpip协议">电子邮件协议(全部隶属于TCP/IP协议)</span></h3><ol type="1"><li>SMTP协议：简单邮件传输协议(TCP25端口)；</li><li>POP3协议：POP邮局协议第三版本(TCP110端口)；</li><li>IMAP协议：互联网信息访问协议(TCP143端口)；</li></ol><h2><span id="网络简述">网络简述</span></h2><ol type="1"><li>LAN：局域网</li><li>WAN：广域网</li><li>MAN：城域网</li><li>WLAN：无线局域网</li><li>WWAN：无线广域网</li><li>WMAN：无线城域网</li></ol><h1><span id="五-计算机基本常识">五、计算机基本常识</span></h1><h2><span id="存储单位换算">存储单位换算</span></h2><p><span class="math inline">\(1PB=1024TB\)</span>;</p><p><span class="math inline">\(1TB=1024GB\)</span>;</p><p><span class="math inline">\(1GB=1024MB\)</span>;</p><p><span class="math inline">\(1MB=1024KB\)</span>;</p><p><span class="math inline">\(1KB=1024B\)</span>;</p><p><span class="math inline">\(1B=8bit\)</span>;</p><h2><span id="进制转换">进制转换</span></h2><p>短除法。</p><h2><span id="编程语言">编程语言</span></h2><h3><span id="低级语言">低级语言</span></h3><p>汇编语言，机器语言</p><h3><span id="高级语言">高级语言</span></h3><h4><span id="面向对象">面向对象</span></h4><p><strong>C++,Java,EIFFEL,Simula 67</strong>等。</p><h4><span id="面向过程">面向过程</span></h4><p><strong>C,Fortran</strong>等。</p><h1><span id="六-二进制相关知识">六、二进制相关知识</span></h1><h2><span id="原码-补码-反码">原码、补码、反码</span></h2><ol type="1"><li>原码(原码表示法)：十进制数直接转换来的二进制数。值得注意的是，原码的最高位是符号位：整数为<span class="math inline">\(0\)</span>，负数为 <span class="math inline">\(1\)</span>。</li><li>补码：正数的补码是其本身，复数的补码是其反码加一。</li><li>反码：正数的反码是本身，负数的反码是<strong>其除符号位之外的所有位按位取反的结果</strong>。</li></ol><h1><span id="七-运算相关知识">七、运算相关知识</span></h1><h2><span id="数学运算">数学运算</span></h2><p>略。</p><h2><span id="逻辑运算">逻辑运算</span></h2><ol type="1"><li><p>逻辑与：<span class="math inline">\(\&amp;\&amp;\)</span> 或<span class="math inline">\(∧\)</span>，同 <span class="math inline">\(T\)</span> 则 <span class="math inline">\(T\)</span>，否则为 <span class="math inline">\(F\)</span>。</p></li><li><p>逻辑或：<span class="math inline">\(||\)</span> 或 <span class="math inline">\(∨\)</span>，有 <span class="math inline">\(T\)</span> 则 <span class="math inline">\(T\)</span>，否则为 <span class="math inline">\(F\)</span>。</p></li><li><p>逻辑非：<span class="math inline">\(!\)</span> 或 <span class="math inline">\(┐\)</span>，为 <span class="math inline">\(T\)</span> 则 <span class="math inline">\(F\)</span>，反之亦然。</p></li><li><p>逻辑异或：<span class="math inline">\(\text{^}\)</span> 或 <span class="math inline">\(⊕\)</span>，同为 <span class="math inline">\(F\)</span>，异为 <span class="math inline">\(T\)</span>。</p></li></ol><h2><span id="位运算">位运算</span></h2><ol type="1"><li>按位与：<span class="math inline">\(\&amp;\)</span>，类似于逻辑与。</li><li>按位或：<span class="math inline">\(|\)</span>，类似于逻辑或。</li><li>按位反：<span class="math inline">\(~\)</span>，类似于逻辑非。</li><li>左移：<span class="math inline">\(&lt;&lt;\)</span>，左移 <span class="math inline">\(x\)</span> 位相当于乘 <span class="math inline">\(2^x\)</span>。</li><li>右移：<span class="math inline">\(&gt;&gt;\)</span>，右移 <span class="math inline">\(x\)</span> 位相当于除 <span class="math inline">\(2^x\)</span>。</li></ol><h1><span id="八-图论理论知识">八、图论理论知识</span></h1><h2><span id="概念">概念</span></h2><p><strong>图(Graph)</strong> 是一个二元组 <span class="math inline">\(G=(V(G),E(G))\)</span>，其中 <span class="math inline">\(V(G)\)</span> 为点集，<span class="math inline">\(E(G)\)</span> 为边集。</p><p><strong>无向图(Undirected Graph)</strong>，边是双向的。</p><p><strong>有向图(Directed Graph)</strong>，边是单向的。</p><p><strong>自环(Loop)</strong>，对于某条边 <span class="math inline">\(e=(u,u)\)</span>，则称其为一个自环。</p><p><strong>重边(Multiple Edge)</strong>，图中存在两个相同的边。</p><p><strong>简单图(Simple Graph)</strong>，一个图中没有自环和重边。</p><p><strong>完全图(CompleteGraph)</strong>，任意两点都有边相连。若一个图的点数为 <span class="math inline">\(n\)</span>，则边的个数为 <span class="math inline">\(\frac{n(n-1)}{2}\)</span></p><p><strong>平面图</strong>，没有边相交的图。四个点的完全图是一个平面图，五个点的完全图任意去掉一条边都是平面图。</p><p><strong>连通图(Connected Graph)</strong>，任意两点都可以到达。</p><p><strong>有向无环图(DAG)</strong>，顾名思义。它可以拓扑排序。</p><p><strong>树(Tree)</strong>，无向无环连通图，且 <span class="math inline">\(n\)</span> 个节点的树有 <span class="math inline">\(n-1\)</span> 条边。</p><p><strong>森林(forest)</strong>：每个连通分量（连通块）都是树的图。按照定义，一棵树也是森林。</p><p><strong>结点的深度(depth)</strong>：到根结点的路径上的边数。</p><p><strong>树的高度(height)</strong>：所有结点的深度的最大值。</p><p><strong>叶结点（leaf node）</strong>：没有子结点的结点。</p><p><strong>父亲（parentnode）</strong>：对于除根以外的每个结点，定义为从该结点到根路径上的第二个结点。</p><p><strong>祖先（ancestor）</strong>：一个结点到根结点的路径上，<strong>包括它本身</strong>的所有节点。</p><p>其余参考<a href="https://oi-wiki.org/graph/tree-basic/">OI-Wiki:树</a>，<a href="https://oi-wiki.org/graph/concept/">OI-Wiki:图</a>。</p><p><del>图论怎么这么多基础概念</del>。</p><h2><span id="二叉树">二叉树</span></h2><p>先序遍历：根—左—右。</p><p>中序遍历：左—根—右。</p><p>后序遍历：左—右—根</p><h1><span id="九-基础数据结构理论知识">九、基础数据结构理论知识</span></h1><h2><span id="栈">栈</span></h2><p><strong>先进后出(FILO,First In LastOut)</strong>，可以想象成一个竖立的木桶。</p><p>后缀表达式：可以用栈实现。</p><h2><span id="队列">队列</span></h2><p><strong>先进先出(FIFO,First In FirstOut)</strong>，可以想象成一个队列。</p><p>双端队列、优先队列、单调队列略。</p><h2><span id="链表">链表</span></h2><p>访问元素时间复杂度为 <span class="math inline">\(O(n)\)</span>，但是删除元素时间复杂度为 <span class="math inline">\(O(1)\)</span>。</p><h1><span id="十-排列组合">十、排列组合</span></h1><h2><span id="排列数">排列数</span></h2><p>从 <span class="math inline">\(n\)</span> 个不同的元素中任取 <span class="math inline">\(m\)</span> 个元素的所有排列的个数，记作 <span class="math inline">\(P_{n}^{m}\)</span>。</p><p><span class="math display">\[P_{n}^{m} =\frac{n!}{(n-m)!}\]</span></p><h2><span id="组合数">组合数</span></h2><p>从 <span class="math inline">\(n\)</span> 个不同元素中，任取 <span class="math inline">\(m\)</span> 个元素并成一组，记作 <span class="math inline">\(C_{n}^{m}\)</span>。</p><p><span class="math display">\[C_{n}^{m} =\frac{n!}{m!(n-m)!}\]</span></p><h2><span id="加法原理和乘法原理">加法原理和乘法原理</span></h2><p>感性理解。</p><h2><span id="题目中的技巧">题目中的技巧</span></h2><h3><span id="插入法">插入法</span></h3><p>例：学校师生合影，共 <span class="math inline">\(8\)</span>个学生，<span class="math inline">\(4\)</span>个老师，要求老师在学生中间，且老师互不相邻，共有多少种不同的合影方式？</p><p>解：先排学生共有 <span class="math inline">\(P_{8}^{8}\)</span>种排法，然后把老师插入学生之间的空档，共有 <span class="math inline">\(7\)</span> 个空档可插，选其中的 <span class="math inline">\(4\)</span> 个空档,共 <span class="math inline">\(P_{7}^{4}\)</span>种选法。根据乘法原理，共有的不同坐法 <span class="math inline">\(P_{8}^{8}P_{7}^{4}\)</span> 种。</p><h3><span id="捆绑法">捆绑法</span></h3><p>例：<span class="math inline">\(5\)</span> 个男生 <span class="math inline">\(3\)</span> 个女生排成一排，<span class="math inline">\(3\)</span>个女生要排在一起，有多少种不同的排法？</p><p>解：因为女生要排在一起，所以可以将 <span class="math inline">\(3\)</span> 个女生看成是一个人，与 <span class="math inline">\(5\)</span> 个男生作全排列，有 <span class="math inline">\(P_{6}^{6}\)</span> 种排法，其中女生内部也有 <span class="math inline">\(P_{3}^{3}\)</span> 种排法，根据乘法原理，共有<span class="math inline">\(P_{6}^{6}P_{3}^{3}\)</span>种不同的排法。</p><h3><span id="剩余法">剩余法</span></h3><p>反过来。</p><h3><span id="对等法">对等法</span></h3><p>例：学校安排考试科目 <span class="math inline">\(9\)</span>门，语文要在数学之前考，有多少种不同的安排顺序?</p><p>解：不加任何限制条件，整个排法有 <span class="math inline">\(P_{9}^{9}\)</span>种，“语文安排在数学之前考”与“数学安排在语文之前考”的排法是相等的，所以语文安排在数学之前考的排法共<span class="math inline">\(\frac{1}{2}P_{9}^{9}\)</span>种。</p><h1><span id="十一-时空复杂度相关">十一、时空复杂度相关</span></h1><h2><span id="时间复杂度">时间复杂度</span></h2><p>时间复杂度的计算，简而言之就是计算循环层数。</p><p>例如对于下列代码段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    ans++;</span><br></pre></td></tr></table></figure><p>这里套用了两层到 <span class="math inline">\(n\)</span>的循环，所以说时间复杂度为 <span class="math inline">\(O(n^2)\)</span>。</p><p>常见的时间复杂度计算：</p><ul><li>二分类：<span class="math inline">\(O(\log n)\)</span>；</li><li>搜索类：<span class="math inline">\(O(感性理解)\)</span>；</li><li>乱搞类：<span class="math inline">\(O(能过)\)</span>。</li></ul><p>值得注意的是，计算时间复杂度一般忽略其中的常数因子。</p><p>如：一个算法的时间复杂度为 <span class="math inline">\(O(2n)\)</span>，则一般写成 <span class="math inline">\(O(n)\)</span>。</p><p>这也是 OIer 常说的 <strong>大常数</strong>的由来。常数因子有时也可能导致 <span class="math inline">\(TLE\)</span>，这就是 <strong>卡常</strong>的由来。</p><p><del>扯远了</del></p><p>其余更多复杂的时间复杂度可以参考<strong>《具体数学》渐进式</strong>。</p><h2><span id="空间复杂度">空间复杂度</span></h2><p>类似于时间复杂度，即数组的大小。</p><p>例如对于下列代码段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[n];</span><br><span class="line"><span class="type">int</span> b[n][n];</span><br></pre></td></tr></table></figure><p><code>a</code>数组的空间复杂度是 <span class="math inline">\(O(n)\)</span>，<code>b</code>数组的空间复杂度是<span class="math inline">\(O(n^2)\)</span>。</p><h2><span id="常见基础算法的时空复杂度">常见基础算法的时空复杂度</span></h2><p>为了方便，前面均为时间复杂度，后面均为空间复杂度。</p><p>有些算法不提供空间复杂度，用 <span class="math inline">\(-\)</span>表示。</p><ol type="1"><li><span class="math inline">\(Dijkstra(无优化)\)</span>：<span class="math inline">\(O(n^2),-\)</span>；</li><li><span class="math inline">\(Dijkstra(堆优化)\)</span>：<span class="math inline">\(O(n+m)\log n,-\)</span>；</li><li><span class="math inline">\(SPFA\)</span>：<span class="math inline">\(\text{Worst}O(|V|\cdot|E|),-\)</span>；</li><li><span class="math inline">\(Floyd\)</span>：<span class="math inline">\(O(n^3),-\)</span>；</li><li><span class="math inline">\(0/1背包\)</span>：<span class="math inline">\(O(VN),O(VN)\)</span>;</li><li><span class="math inline">\(KMP\)</span>：<span class="math inline">\(O(m+n)\)</span>。</li></ol><h2><span id="排序算法的时间复杂度与稳定性">排序算法的时间复杂度与稳定性</span></h2><table><thead><tr class="header"><th style="text-align: center;">排序方法</th><th style="text-align: center;">时间复杂度</th><th style="text-align: center;">稳定性</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">插入排序</td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;">稳定</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">冒泡排序</td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;">稳定</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">选择排序</td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">快速排序</td><td style="text-align: center;"><span class="math inline">\(期望O(n\logn)\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">希尔排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">堆排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">归并排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;">稳定</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">基数排序</td><td style="text-align: center;"><span class="math inline">\(O(d(n+r))\)</span></td><td style="text-align: center;">稳定</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">桶排序</td><td style="text-align: center;"><span class="math inline">\(O(\max\{value\})\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><del>猴子排序</del></td><td style="text-align: center;"><span class="math inline">\(O(1)-O(∞)\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><del>欧皇排序</del></td><td style="text-align: center;"><span class="math inline">\(O(\text{NULL})\)</span></td><td style="text-align: center;">稳定</td><td style="text-align: center;"></td></tr></tbody></table><h1><span id="十二-概率与期望">十二、概率与期望</span></h1><p><del>不会</del></p><h1><span id="十三-阅读程序与补全程序相关">十三、阅读程序与补全程序相关</span></h1><ol type="1"><li>先看有没有注释，<del>没有注释的都是屑</del>；</li><li>猜测变量名称，猜测变量的作用；</li><li>自己阅读每个语句，理解其作用；</li><li>理解代码段的作用；</li><li>根据样例猜测作用；</li><li>手玩几组数据，模拟代码作用；</li><li>认真审题，细致思考。</li></ol><h1><span id="十四-总结">十四、总结</span></h1><p>个人认为前面的计算机基础知识背背即可，重点放在<strong>排列组合题</strong> 和 <strong>阅读/补全程序题</strong>上，多刷初赛原题。</p><p>考场上不要慌张，时间充足，充分利用时间，多检查几遍，<del>不会的看顺眼的蒙</del>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NOIP 初赛知识点整理。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
