<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏花盛开，佑浅浅而归</title>
  
  <subtitle>夏佑随记</subtitle>
  <link href="http://summace.cc/atom.xml" rel="self"/>
  
  <link href="http://summace.cc/"/>
  <updated>2023-10-03T02:33:50.009Z</updated>
  <id>http://summace.cc/</id>
  
  <author>
    <name>夏佑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Prüfer 序列学习笔记</title>
    <link href="http://summace.cc/Prufer/"/>
    <id>http://summace.cc/Prufer/</id>
    <published>2023-10-02T16:00:00.000Z</published>
    <updated>2023-10-03T02:33:50.009Z</updated>
    
    <content type="html"><![CDATA[<p>如何优美地数树 ~ Prüfer 序列学习笔记</p><span id="more"></span><h1 id="prüfer-序列">Prüfer 序列</h1><p>首先定义<strong>无向树的 Prüfer 序列</strong>：</p><p>对于一颗无向树，考虑按照下列步骤建立 Prüfer 序列：</p><ol type="1"><li>删去当前编号最小的叶子节点，并在序列中加入其父亲节点；</li><li>重复 <span class="math inline">\(n-2\)</span>次直到剩下两个节点。</li></ol><p>最终得到的序列就是该无向树的 Prüfer 序列。</p><p>用堆暴力构造是 <span class="math inline">\(O(n\log n)\)</span>的，有一个线性构造办法：</p><p>记录指针 <span class="math inline">\(p\)</span> 和每个点的度数 <spanclass="math inline">\(\deg_i\)</span>，按照以下步骤建立序列：</p><ol type="1"><li>若 <span class="math inline">\(p\)</span> 为叶子节点，删除节点 <spanclass="math inline">\(p\)</span>（不改变指针 <spanclass="math inline">\(p\)</span> 的位置）；</li><li>判断是否产生新的叶子节点。若产生，则判断新叶子节点编号 <spanclass="math inline">\(q\)</span> 与 <spanclass="math inline">\(p\)</span> 的大小关系。若 <spanclass="math inline">\(q&lt;p\)</span>，则立即删除 <spanclass="math inline">\(q\)</span>，重复步骤 <spanclass="math inline">\(2\)</span>；否则不进行操作；</li><li>自增 <span class="math inline">\(p\)</span> 直到变为步骤 <spanclass="math inline">\(1\)</span>。</li></ol><p>正确性是显然的，时间复杂度 <spanclass="math inline">\(O(n)\)</span>。</p><p>根据 Prüfer 序列可以唯一地重建树。方法与建立类似。</p><p>Prüfer序列实际上与无向树构成了<strong>双射关系</strong>，用处就是数树。</p><p>性质：结点 <span class="math inline">\(i\)</span>在序列中出现的次数是 <span class="math inline">\(\deg_i-1\)</span>。</p><h1 id="cayley-公式">Cayley 公式</h1><p><strong>Cayley 公式</strong>：<span class="math inline">\(n\)</span>个标号点形成的树的数量为 <spanclass="math inline">\(n^{n-2}\)</span>。</p><p>等价于：完全图 <span class="math inline">\(K_n\)</span>的生成树个数为 <span class="math inline">\(n^{n-2}\)</span>。</p><p>用 Prüfer 序列可以方便地证明 Cayley 公式.</p><p>证明：任意一个长度为 <span class="math inline">\(n-2\)</span>的，值域为 <span class="math inline">\([1,n]\)</span> 的 Prüfer序列都是原图的一棵生成树。证毕。</p><h1 id="广义-cayley-公式">广义 Cayley 公式</h1><p><strong>广义 Cayley 公式</strong>：<spanclass="math inline">\(n\)</span> 个标号点形成一个有 <spanclass="math inline">\(k\)</span> 颗树的森林，使给定的 <spanclass="math inline">\(k\)</span> 个点中任两点不属于同一棵树的方案数为<span class="math inline">\(k\cdot n^{n-k-1}\)</span>。</p><p>证明：不妨钦定给定的 <span class="math inline">\(k\)</span>个点分别为 <span class="math inline">\(k\)</span>颗树的根。我们建立一个虚根 <spanclass="math inline">\(I\)</span>，钦定其编号为 <spanclass="math inline">\(n+1\)</span>，并分别钦定 <spanclass="math inline">\(k\)</span> 个点编号为 <spanclass="math inline">\(n-k+1\sim n\)</span>。</p><p>由于 Prüfer 序列每次删叶子节点，因此这 <spanclass="math inline">\(k\)</span>个点一定是最后被删除的，并且加入序列的数一定是 <spanclass="math inline">\(n+1\)</span>。也就是说，Prüfer 序列最后 <spanclass="math inline">\(k-1\)</span> 个点一定是 <spanclass="math inline">\(n+1\)</span>。</p><p>编号为 <span class="math inline">\(n-k-2\)</span>的节点，其父亲一定只能是这 <span class="math inline">\(k\)</span>个点。剩余的 <span class="math inline">\(n-k-1\)</span>个点，其父亲可以是 <span class="math inline">\([1,n]\)</span>中任意节点。</p><p>因此最终的方案数就是 <span class="math inline">\(k\cdotn^{n-k-1}\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何优美地数树 ~ Prüfer 序列学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="http://summace.cc/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="组合数学" scheme="http://summace.cc/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="图论" scheme="http://summace.cc/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CF442D Adam and Tree</title>
    <link href="http://summace.cc/CF442D/"/>
    <id>http://summace.cc/CF442D/</id>
    <published>2023-09-30T16:00:00.000Z</published>
    <updated>2023-10-01T12:23:54.440Z</updated>
    
    <content type="html"><![CDATA[<p>有生之年独立做出来的黑题（至少现在是）。</p><span id="more"></span><p>首先，一定有一种最优情况使得一条颜色的路径不会同时包含某个节点的多于一个儿子。</p><p>证明：如果有存在同时包含某个节点多于一个儿子的路径，那么由于我们只关心某个节点到根节点的颜色数量，而不关心总颜色数量，因此将这条路径拆成两条即可。</p><p>然后考虑设 <span class="math inline">\(f_u\)</span> 表示以 <spanclass="math inline">\(u\)</span>为根的子树，包括其连向父亲的那条边的最优解。</p><p>考虑到我们现在要给 <span class="math inline">\(u\rightarrowfa_u\)</span>染色，那么我们应当将其染成儿子的最大值的颜色。因为这样一定可以尽量减少对答案的贡献。那么儿子的次大值就会加上<span class="math inline">\(1\)</span>。因此我们同时维护最大值 <spanclass="math inline">\(max1\)</span>，次大值 <spanclass="math inline">\(max2\)</span>，可以得到转移方程：</p><p><span class="math display">\[f_u=\max\{max1_u, max2_u+1\}\]</span></p><p>考虑这样暴力转移是 <span class="math inline">\(O(n)\)</span>的，总时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><p>我们加入这样一个优化：如果加入一个节点，向上更新的过程中，发现已经无法更新该节点，那么就直接停止更新。这样的时间复杂度是<span class="math inline">\(O(n\log n)\)</span> 的。</p><p>为什么呢？因为可以发现，我们每次更新的一定是一条链。而我们染色的过程类似于重链剖分，一个节点到根的过程经过的链的数量是<span class="math inline">\(O(\log n)\)</span> 的，因此总时间复杂度<span class="math inline">\(O(n\log n)\)</span>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(max1[fa[u]] &lt; f[u])</span><br><span class="line">    &#123;</span><br><span class="line">        max2[fa[u]] = max1[fa[u]];</span><br><span class="line">        max1[fa[u]] = f[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max2[fa[u]] &lt; f[u])</span><br><span class="line">    &#123;</span><br><span class="line">        max2[fa[u]] = f[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">max</span>(max1[fa[u]], max2[fa[u]] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(f[fa[u]] == ans) <span class="keyword">return</span>;</span><br><span class="line">    f[fa[u]] = ans;</span><br><span class="line">    <span class="built_in">dfs</span>(fa[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        fa[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, max1[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;有生之年独立做出来的黑题（至少现在是）。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>哈希学习笔记（NJU）</title>
    <link href="http://summace.cc/Hashing-Sketching/"/>
    <id>http://summace.cc/Hashing-Sketching/</id>
    <published>2023-09-25T16:00:00.000Z</published>
    <updated>2023-09-26T12:08:23.372Z</updated>
    
    <content type="html"><![CDATA[<p>南京大学研究生课程 Advanced Algorithm。</p><span id="more"></span><h1 id="birthday-paradox">Birthday Paradox</h1><p>在一个 <span class="math inline">\(m&gt;57\)</span>人的班里，有两个人生日相同的概率 <spanclass="math inline">\(&gt;99\%\)</span>。</p><p>形式化地说：<span class="math inline">\(n\)</span> 个球放进 <spanclass="math inline">\(m\)</span> 个箱子。定义事件 <spanclass="math inline">\(\mathscr{E}\)</span>：每个箱子有 <spanclass="math inline">\(\leq 1\)</span> 个球。</p><p><span class="math display">\[\Pr[\mathscr{E}]=\prod\limits_{i=0}^{n-1}\left(1-\dfrac{i}{m}\right)\approxe^{-n^2/2m}\]</span></p><p><span class="math display">\[\text{when}\ n=\sqrt{2m\ln\dfrac{1}{p}}\Rightarrow\Pr[\mathscr{E}]=(1\pmo(1))p\]</span></p><h1 id="hashing">Hashing</h1><h2 id="simple-uniform-hash-assumption">Simple Uniform HashAssumption</h2><p>完美哈希。使用随机哈希函数。简称 SUHA。</p><p><span class="math inline">\(m=n^2\)</span> 的空间，可以做到冲突概率<span class="math inline">\(&lt;\dfrac{1}{2}\)</span>（生日悖论）的概率完美哈希。</p><h2 id="k-universal-hash-family">k-Universal Hash Family</h2><p>称哈希函数 <span class="math inline">\(U\rightarrow [m]\)</span> 的family <span class="math inline">\(\mathscr{H}\)</span> 是 k-universal的，当对于一些不同的 <span class="math inline">\(x_1\cdots x_k\inU\)</span>，满足：</p><p><span class="math display">\[\Pr\limits_{h\in \mathscr{H}}[h(x_1)=\cdots =h(x_k)]\leq \dfrac{1}{m^{k-1}}\]</span></p><h2 id="linear-congruential-hashing">Linear Congruential Hashing</h2><p>线性同余哈希：<span class="math inline">\(h_{a,b}(x)=((ax+b)\bmodp)\bmod m\)</span></p><h2 id="back-to-birthday-paradox">Back to Birthday Paradox</h2><p>用 2-universal hashing 解释。</p><p>总 collision pairs：</p><p><span class="math display">\[Y=\sum\limits_{i&lt;j}I[X_i=X_j]\]</span></p><p>其线性期望</p><p><span class="math display">\[\mathbb{E}[Y]=\sum\limits_{i&lt;j}\Pr[X_i=X_j]\leq {n\choose2}\dfrac{1}{m}\]</span></p><blockquote><p>Markov's Inequality：</p><p><span class="math display">\[\Pr[X\geq t]\leq\dfrac{\mathbb{E}[X]}{t}\]</span></p></blockquote><p><span class="math display">\[\Pr[\lnot \mathscr{E}]=\Pr[Y\geq 1]\leq \mathbb{E}[Y]\leq \mathbb{E}\(\text{when}\ n\leq\sqrt{2m\epsilon})\]</span></p><p>因此可以将 SUHA 换为线性同余函数。</p><p>不完美哈希概率 <span class="math inline">\(\leq\dfrac{n(n-1)}{2m}&lt;1\)</span>。因此一定可以找一个哈希方式 <spanclass="math inline">\(h\in \mathscr{H}\)</span> 使得其成为完美哈希，且<span class="math inline">\(\mathscr{H}\)</span> 很小。</p><p>但是空间仍为平方级别。</p><h2 id="fks-prefect-hashing">FKS Prefect Hashing</h2><p>用一个 primary hashing 随机哈希将 <spanclass="math inline">\(N\)</span> 个元素分为 <spanclass="math inline">\(n\)</span> 个 buckets，每个 bucket开一个平方空间的完美哈希表。</p><p>时间复杂度是显然的 <spanclass="math inline">\(O(1)\)</span>，空间呢？</p><p><span class="math inline">\(n\)</span> 个球放进 <spanclass="math inline">\(n\)</span> 个buckets，其平方和为线性的。为什么？因为 collision pairs的期望是线性的。因此期望空间花费为 <spanclass="math inline">\(O(n)\)</span>。</p><p>形式化地说：</p><p><span class="math display">\[\mathbb{E}\left[\sum\limits_{i=1}^{n}|B_i|^2\right]=\dfrac{n(n-1)}{m}+n\leq2n\]</span></p><p>总空间 <span class="math inline">\(O(n\log N)\)</span> bits。</p><h1 id="bloom-filters">Bloom Filters</h1><p>布隆过滤器。用于近似查询。</p><p><span class="math inline">\(k\)</span> 个随机独立哈希函数 <spanclass="math inline">\(h_1\sim h_k:U\rightarrow [m]\)</span>。</p><p>共用一个 bit 串，每次插入映射 <span class="math inline">\(k\)</span>个位置。</p><p>查询时候查询 <span class="math inline">\(k\)</span> 个映射，如果有<spanclass="math inline">\(0\)</span>，则一定不在集合中。否则有概率误判。</p><p>显然，<span class="math inline">\(x\in S\)</span> 总正确。</p><p>错误概率：</p><p><span class="math display">\[\begin{align}\Pr[\forall 1\leq j\leq k:v[h_j(x)]=1]&amp;\leq (1-(1-1/m)^{kn})^k\\&amp;\approx(1-e^{-kn/m})^k\\&amp;=2^{-c\ln 2}\leq (0.6185)^c\end{align}\]</span></p><p>选取 <span class="math inline">\(k=c\ln 2\)</span>。空间 <spanclass="math inline">\(m=cn\)</span> bits，时间 <spanclass="math inline">\(k=c\ln 2\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;南京大学研究生课程 Advanced Algorithm。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="哈希" scheme="http://summace.cc/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="概率论" scheme="http://summace.cc/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>概率论学习笔记（NJU）</title>
    <link href="http://summace.cc/Probability-Theory/"/>
    <id>http://summace.cc/Probability-Theory/</id>
    <published>2023-09-25T16:00:00.000Z</published>
    <updated>2023-09-26T12:54:21.973Z</updated>
    
    <content type="html"><![CDATA[<p>南京大学本科课程概率论。</p><span id="more"></span><h1 id="全概率公式">全概率公式</h1><p>记 <span class="math inline">\(A_i,B\)</span> 为事件，<spanclass="math inline">\(B\)</span> 为结果，<spanclass="math inline">\(A_i\)</span> 为条件，则有全概率公式：</p><p><span class="math display">\[P(B)=\sum\limits_{i=1}^{n}P(BA_i)=\sum\limits_{i=1}^{n}P(A_i)P(B|A_i)\]</span></p><p>其中，<span class="math inline">\(P(AB)\)</span> 表示满足条件 <spanclass="math inline">\(A\land B\)</span> 的概率，<spanclass="math inline">\(P(B|A)\)</span> 表示条件 <spanclass="math inline">\(A\)</span> 下发生 <spanclass="math inline">\(B\)</span> 的概率。</p><h1 id="贝叶斯公式">贝叶斯公式</h1><p>遵循上述约定，若有 <spanclass="math inline">\(P(B)&gt;0\)</span>，则有贝叶斯公式：</p><p><span class="math display">\[P(A_i|B)=\dfrac{P(A_iB)}{P(B)}=\dfrac{P(A_i)P(B|A_i)}{\sum\limits_{j=1}^{n}P(A_j)P(B|A_j)}\]</span></p><p>其中 <span class="math inline">\(P(A|B)\)</span> 表示事件 <spanclass="math inline">\(B\)</span> 由 <spanclass="math inline">\(A\)</span> 引发的概率。</p><p>特别地，若 <span class="math inline">\(n=1\)</span>，则有：</p><p><span class="math display">\[P(A|B)=\dfrac{P(AB)}{P(B)}=\dfrac{P(A)P(B|A)}{P(A)P(B|A)+P(\overline{A})P(B|\overline{A})}\]</span></p><p>其中 <span class="math inline">\(\overline{A}\)</span> 表示 <spanclass="math inline">\(A\)</span> 的反事件。</p><p>全概率公式和贝叶斯公式均需要得知 <spanclass="math inline">\(P(A_i)\)</span> 与 <spanclass="math inline">\(P(B|A_i)\)</span>，不同之处在于全概率公式是通过这些概率推出<span class="math inline">\(B\)</span>的概率，即由因推果。而贝叶斯公式则是在已知 <spanclass="math inline">\(B\)</span> 发生的概率下，求出 <spanclass="math inline">\(A_i\)</span> 对其的影响，即由果推因。</p><p>由此观之，全概率公式与贝叶斯公式呈现因果颠倒的关系。</p><p>我们称 <span class="math inline">\(P(A_i)\)</span> 为先验概率，称<span class="math inline">\(P(A_i|B)\)</span> 为后验概率，<spanclass="math inline">\(P(B)\)</span> 为证据概率，<spanclass="math inline">\(P(B|A_i)\)</span>为似然度，则贝叶斯公式可用下式表示：</p><p><span class="math display">\[\text{后验概率}=\dfrac{\text{先验概率}}{\text{证据概率}}\times\text{似然度}\]</span></p><p>许多算法为提高后验概率，会尽量提高似然度。</p><p>贝叶斯公式存在的争议：先验概率可能不存在或者存在主观性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;南京大学本科课程概率论。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="概率论" scheme="http://summace.cc/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    <category term="数学" scheme="http://summace.cc/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>AGC020D Min Max Repetition</title>
    <link href="http://summace.cc/AGC020D/"/>
    <id>http://summace.cc/AGC020D/</id>
    <published>2023-09-24T16:00:00.000Z</published>
    <updated>2023-09-25T01:40:50.855Z</updated>
    
    <content type="html"><![CDATA[<p>有生之年想出来的 AGC 构造题，值得记一下。</p><span id="more"></span><p><a class="link"  href="https://atcoder.jp/contests/agc020/tasks/agc020_d" >Link</a></p><blockquote><p>多组询问。每个询问给定四个整数 <spanclass="math inline">\(A,B,C,D\)</span>，求一个满足这个条件的字符串：</p><ol type="1"><li><p>长度为 <span class="math inline">\(A+B\)</span>，由 <spanclass="math inline">\(A\)</span> 个字符 <spanclass="math inline">\(\mathtt{A}\)</span> 和 <spanclass="math inline">\(B\)</span> 个字符 <spanclass="math inline">\(\mathtt{B}\)</span> 构成。</p></li><li><p>在此基础上，连续的相同字符个数的最大值最小。</p></li><li><p>在此基础上，字典序最小。</p></li></ol><p>输出这个字符串的第 <span class="math inline">\(C\)</span> 位到第<span class="math inline">\(D\)</span> 位。</p></blockquote><p>不妨先考虑一下，<span class="math inline">\(A=B\)</span>的时候我们会如何安排。显然，由于要满足条件 <spanclass="math inline">\(2\)</span>，我们一定会交叉放置。而由于条件 <spanclass="math inline">\(3\)</span>，我们会安排成 <spanclass="math inline">\(\underbrace{\mathtt{AB\cdotsAB}}_{若干个\mathtt{AB}}\)</span>。</p><p>现在如果我们放了上述个 <spanclass="math inline">\(\mathtt{A,B}\)</span>，还多出若干个 <spanclass="math inline">\(\mathtt{A}\)</span>，那么多出的 <spanclass="math inline">\(\mathtt{A}\)</span> 就一定会插入到前半部分的 <spanclass="math inline">\(\mathtt{AB}\)</span> 中，形成 <spanclass="math inline">\(\mathtt A\underbrace{\cdots}_{若干个\mathtt{A}}\mathtt B\)</span>。经过这样操作之后，我们发现我们条件 <spanclass="math inline">\(2\)</span> 的需求放宽了，也就是说我们原本的某些<span class="math inline">\(\mathtt{B}\)</span>可以向后调整。最终，整个序列会变成这样：</p><p><span class="math display">\[\mathtt{(A\cdots B)\cdots|A\cdots AB\cdots B|(B\cdots A)\cdots}\]</span></p><p>其中 <span class="math inline">\(\cdots\)</span>表示前部分的反复。</p><p>容易得到 <spanclass="math inline">\(k=\lceil\dfrac{a+b}{\min(a,b)+1}\rceil\)</span>，<spanclass="math inline">\(k\)</span> 是的连续相同字符个数，</p><p>那么我们可以二分出来中间的 <spanclass="math inline">\(\mathtt{A\cdots AB\cdots B}\)</span> 的 <spanclass="math inline">\(\mathtt{AB}\)</span>中界，然后就可以按照构造的方式输出。发现如果我们当前还剩 <spanclass="math inline">\(a\)</span> 个 <span class="math inline">\(\mathttA\)</span>，<span class="math inline">\(b\)</span> 个 <spanclass="math inline">\(\mathtt B\)</span>，我们需要满足 <spanclass="math inline">\(b&gt;ak\)</span>。输出的时候分为左右两边判断即可。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = A - mid / (k + <span class="number">1</span>) * k - mid % (k + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> b = B - mid / (k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> b &lt;= a * k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(A, B, C, D);</span><br><span class="line">    k = (A + B) / (<span class="built_in">min</span>(A, B) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = A + B + <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a = A - l / (k + <span class="number">1</span>) * k - l % (k + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> b = B - l / (k + <span class="number">1</span>);</span><br><span class="line">    r = l + <span class="number">1</span> + b - a * k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C; i &lt;= D; i++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= l) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (i % (k + <span class="number">1</span>)) ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ((i - r) % (k + <span class="number">1</span>)) ? <span class="string">&#x27;B&#x27;</span> : <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;有生之年想出来的 AGC 构造题，值得记一下。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="二分" scheme="http://summace.cc/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="构造" scheme="http://summace.cc/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>NOIP 摆烂日志</title>
    <link href="http://summace.cc/training/"/>
    <id>http://summace.cc/training/</id>
    <published>2023-09-21T16:00:00.000Z</published>
    <updated>2023-10-05T08:08:08.471Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="出错。">  <script id="hbeData" type="hbeData" data-hmacdigest="c2001c0ac1769c53ff2406af24455b8dff47b6b2e33cb254dabd5c7b601f69ad">5aa0328b97108558c86b2b536108318893d9eba501c3fe88bc1723179fe487199986a82e7ddc4f12d91e44f9f6e28d68e4c0a0ecdbe16177e10ff750695ba285ecec038f8bfc95c15698a421937066abcd869db20dd5e9ef8013d9c5ed1f02429e0fa2113d0758991d464327429e3aeb6196128463485e8e463ee670ec2b774be20d9f0043cf3bc74c4ae7ff2a10cec8dd27bd0378f9f5e2b647d5d7a3a6020bed49e33d41c24ddf0fe92bb4688fe4c56ab8bed5f956daf137f247e703fbb54cfdf353173812c3f250776b94031d497a2b64e22bb17ceb79c4e6edce1cf47e6fdea92369f7f723f54f690a79aefcfee975855dfd215c696b8603fa0289027b043d317f3a0dd3d132405a7ad2f90c4a0cbde9b73f3b3724bee54635d31fc3477570e25e34a9685327731972777e145c4ea231a2a5191324b10de6b5427163db629b23ff08d789458e3e3ffc276070dd62d936df4e0f15612fa1b044a4de3f972fc724cccfe4083caba78b80bfbfb8df4fabd6e104504f19f665f8f663d58036a0de59d12edd0584019cdea8ccaaec6bfeff3c9eb55923b5d30701d4a291c799f3e975675e480fb7d06a79a962b031dcd7279c9c614129e5a0413a391ce969bfdedfbbd2581a4134d6be535812af4da1ad301f0cae7874875853803b9dc05a28feafdf4e76927acfea2707dc48758acba2599e74d4fa3809919ce8e2d9f309985478080cda49dc28ed82e9ec3b6e3b6988db4b5cf56f865c8baeb92162fa273e5aa30108798b177586969577ab3d82ad644b6b74bf4b56e516c132b53e60f225b3a1bb06af091fa2edc747394801503654bb242a8c1ebe36f361bf022b5e025e7808aaddba0f1382e323b90f295f5bd04997fd1c5013eb3c5f0d5ee9bfc316d5d0450c282de652bbc74a11ca2188942a30c3c4be7daf16c3dad42e5ce8458945f5f9c41c9ff1e474360930e70f73a27cda41695ecd2a417246d1e72510a15ff058552d7c05887b3e2a9d235dc639e1865ddb06cb50f767a3e95b12b0f0a6a45f20336af882a7ae58308df268c16b9bc6d223862e3fb486d9299136155ebb63575206d253889f323807cc38828121318f3fb0ce1701bf60b4e6794d4b6287c877d108068a1d0db7a3449c6f98eaf4d4d3fc884e0e25dc80827b4c527854f7af08ae8a6c8315d9137b1d73e56812824ad78f3d2e4de1642171587cdfe7d71f0959b192146b815ba9384e09fa7714ea80377d7e0dc44842d3ed5833ac027edbcb0b29d1952e6f577f0359a80bd184abeaba0820e554c3dd5159f5a8707a6f9f5593114eefecbb02ef628e4b5d20fad5f9a0716508c7cd6dbeaf77f45f0cd53a9bfc52d8acb9c76af34b022d4ba59b85a145720f49cbef3d23c0485ba3cca1327cb1feb20c947fd4d26294c089b1f2e93e295427c6d66a88d6ca1513dafcb7b378b0e447b2195fc80242a6098effc62b44f9f4919d7477b8be33e065ca7db63b2cbfa85c2102891c5a8f9e8b250d88c41a551129878fc20bd6b5281081d91704da9f567d84957b9725da5aae5ad671ac90d2cffd5141bcd52f7f93825d86c0b25b8f553b2af2d8171351bd0147eba56d8bf958439cf0c51407a1b43f20216c325973d73d0daf64b0af35c44ab105603f5c97f20a0153a17dc73aa5346ab7856d5cbef367ceada94158de14cc504cd1b78a8b94c5493a27dc12289b0d8fc4126587431d3277da63e32aa8cb22c3886a3fd19c5d94668248c010b1eacd69aba80b77aaec4dba398bc30f0465ecd33073cf72fb5321b54f279c80e1d2eaf30a580c70fdf5f163f687500bedbb4fa726c49490798e5719b170fee7dcd6269fa53968a50ea8917ba9b1d4b0df271b973c186536de2f7b5166c6534ade53b8295ebe856fffa9af014e8d3b9f8dbb71c394a0de061d04f42be1fe902b5384f8c7b18919af44a2180185567852eb32fe6678d685ecb819ff7557f684a514171423cf490e40690733e485b663bfcc804c40cb6ae2a1adf075e96891fa398aa872ebeb753550fab3f07f996dbf6105b768b66fce41f8658e419a464578059d23a2569843acddeeac2d14e1039e57d1a69078e8f3ecfe41a76d602fdf5a1ac5febb7ff1f64f4808c883db0ce78c032c592cd4f92d7ae13f5675225680b3a663667301cc92e75962c366b370b0228240be791c37260f7631cdd947906c067b024e17d21c1ed04af501c4d5a805085c2a0c9a484e9f1d6a82e0e552996e77e0fceada0d05bf0b3d89c40c3bc8af77e3e7296aad9d70dd25f64d2fe9d8ee3a7da856f185eb92259bd0fc99005a9e16397c3190aa49a226731483dff90d25289c1d5a31ddb8bf033bb0491dccba83de5577a39a63caeb70d98260daae9549de6a4a68c49a2ca49411076daee3ed99fbb1ac56335366cca96e6083d8594d9031fa97e582405dc4661ee531ffbd10227b0c745386feceff526201dfd97cf377cb9a95510eed5591f0707da253d1f51ed9f1472202b9603adec7aac66c86bbc43422f9c1c9792973e1bfaf0c9c9201694eda5e38263ac4e1816e33d4edce1dda5f633f383ca22a0c11005d728295b0808d8a272611b7d76927681ea8f647ad80d906e26e5cbab4d9339831d1a0cb00796d102795e72dcc1cf1ae89ae326b7ab8264eb2a1d82d908b74716eecac831b746a9f98da1aa6074ff6a41792d2772c0de77f5e644ecbfeba70bd447c5c1c6a9a9d0f4c2e547c056638688c219ce15e897ff7cbabae436261ceb8d88d23a46f03dccd284faf700b6710c4d8e3cbedaaa8226e989b347bfa7eeb83faf80b03f556ac840bb7ee6fe32e659acc37e015738e6b8f0b4c602cbecb7d9d11749726bf39f3273e7523ede454fc1a77c1bc74a3233e456c06f86842c16cea4fde0cc0256b5869c797f80b783d8c4b2a3587d77e1b95926ddbaa1d50d0ab6517aac1ff9e85d3fcfa911253a1de451e87eaca17197e3bd7a2c5cfd4909f29463379399d0cab93d285dcd507daa37f3bea41ad37813df69f628695f96b00b10228f39c76e076f188f1987193773856f3471aa00a470fbb9c6ffbc4d0fa8a5abfb5e3913ff1a9e19a3d66b8c6f3dd2ccd9c5f82926671c77a045db25a4812d84bb49d5c4d8ddfccdd7b7bdf136d6535ac3b4015cf3a6c71fff9506536065a79721fe201300bbb6c846cb595d3d8c9d873403beb0496b9b51575b205226fe9767133a8886acbc5dc4c5325a8de7f6632c684ced9216d815af90ad45540e8001cecd3b40a2afb2a620f217fcb201b84a863b6677b8a443649c9cdb48e24b3d86bea765f6267ecdecd445d01dbf3a5a399fe9882b6e1f7bd6a4718c6181c0b422220d9bb916483b87353a2e1febf38f0a0728d679e5c103c30e53753de2de5b5f14d104bea7ec62850ce851262b02bd95bb0225c524398013a60b4236d56bb5e8f8d7cda7c3117289afd4820a94976c63f133c1f33ec545700316b86e62787eebb0799838e75c54e0af3e18e24792c4715f4ddc50cd45f51dd57b2903ed998cad0f4e26e7541f5443f86090e72b3aca75f561473ea0e96da1aff1a04b745199f55a48d8202c56953b1193755dcfc7a3e6b9b585c90f6bc7c1601217a9c0b0ac1b3badb131bf20a5fa1e58c2c3140ae07efd9f389730de10a3eee78ee21d0237d9b2b057e83d6eb7ba7139770deefc02bf180a77503a056faebe30b23e8cd9779da70046b1e175a148bdc40418c3c75e0f55b75114fbf0a7cf6f6b361553f99bb3eb45007904bd337fea4fc4e4649ca8757dc6c3c59634685550078e56de984269b6781db7acf4452bddd2fa750bbefac858714ea5231a9b6a740fb3c4c8dd3f1a91a99376441972608f362ee315764dbd610838f810cfa721300339d6b410dc18e6c6f822f19f91756b0cde1e61cfe0eb8d16da784efc71736e88f59243e2f8a92946a800daa165f4d9de635192723d51b96e129a48da22ef09710639429d97662473fe1394a415914c515cd32c165cf6f5d11e6708cf7ca601ef7cde55a60541102e87f2a3c28d85d33987d8c090b8319c288753472d0fc01fe8acc2518e42fe19307cd10bd8e75c598472e9b7de5abe98eaaf5f402ab29c13bb10dc4b3ddcfac02930b09c9d4c3059646625b1ffbba4d293d74a819ec0d8d9da89aecb1890be4d86b059aeb7213c3095d3b4bfa78b7cad9f24aa447c43e336ab93790f7c31c0c3ee7f4d4eb5a802f235972bafe769b6f347b82f4536103c3f77a74645c59c0f784c2f3c80ee7549f533ea2435d33a224caa728d4b18bf5eb9f7c2fc06147fe08fb57ce51dbfc9839db524cf2f04f2ed635519aad5c64747a6218b664ab9e99bb80954444131eaa22bf6093329934ac35bacfa08e741a344a65366f79d476672d8be4951f9441ebf06e9e43a1a0b5e8c3e82fada2abab042694bb577f7c13536f2093d5758e3b9cfff1bc2956b9f55b5aa0efa3cb55314fa2f7279d4a7dc93a8a2085dfa577406b0b9c87f02639449827015b537779a78e20cfee53bc81f1df98a5744346e12f5b0a8cc62d120042a88a9519f35c703bbd5f87f72c136fd839927bf026da969c7f4391bbe29557e76f079cded80fd9440350bdafa294f97ecf200d67f0a4c6e29b221f9f953aa4f3c7fe18906b2e0c3b370ede691c8fa5a0ed4daeffbb5d8e6c73fe3d65b975cdecdb8d956d96e4d11e8ce9396defd4b5eb2e99d80684a1e7814ee642ed2ad34cc32186baf7302c40734dff5f3e5d44472fd91ecf245f6627b05915debd28e23afb2ffcdcba95fdf0889f4e5925e9d3d56bca4c3f9c6132921ec09555c850224e431b1ad6a53b94645a2f242f8dedb0e712ee149b737d4b2fbda1d3cafcd7820feedb1797eb3f5c13e5c8e1dfdb9d2eb1f44819d3be7bdb2da9bc9f1a355f06e3c059a6f6ed060b9e8cac24c7440e335f88161e4c2410e6e90cef3e55c39ca308d18686e4c12877afdeccb3194bd5dbb214b5f8b9fa044b8c2a4409f917e4e56425ed533a10a134ea3be86838d7b46e20334f21adb2b62ba8175391ebb356c506e26c507efb4802cb0800ac72c7bb076c151dcd1ad57626bac6b052e96e60e4857476bcbe6bfda294420cfaf75b8982f3f9f82c335bcc178b6207570f1636e7aaa04485aacba41cc350ce310366d36b99a35fba3e7c432d598d52a69db2f4b9ef262f5b1a94df209b680e879006be8da5540225a95164f752cc550d0a9f7bd064299e0d8e27f4fb3ef2cd38bc4f7b408eec5dde6c082c531dd1c9193f1f33b1ead068fdbe448133ddab3f3f659ba5fc3b28728f6864c5f1d1248ccfc5fccf070a5ddadf1d8adcddc5c5a2aeb32de2adb79cdea4e92963d86c03ea675bb5f967655aef8fe18f4d34c061cb1818580539492bb7aa0c97a3750613a80e45bf08b199214c8130bbc8bf29f9166feaf4d53bd65a94c01b47de8c6c4597d3b250578d387e01246d2c7eaf55fc5fb780930844264ee1d91b40f4fce80d88bbbbfcc58606b1113df5bf2e2e2d11935c26b09391bc779d94d9a0b453d8b9a14166ea1c10f2ef0681dd23bb07d8ee6c43487a958ec7d0d3be56912ade00b261a24db22201e2a89e574e91177d87d05f8b2af72f3e7039cfc6a0a3c05f248b03ef20579b2b406d21c3127f093020dff610fe7011e1f4f46c44e359c28361d2fd3878d97ee7bc643cb7fd88ad1c5693c4d025552d28b8853f8b9adc7152a20588189c725de6bd1aeb332691d1eec74c86ce8a56842a04397fe7fbab030ba289cdab4d0e0234eef1b1ec78b2af13570a98fd3504569db056a5ff87bfffecee94a8fe07ce21e0b3dbe4f3d3eb08d25bf0897610a2df6cd87e069528e53956dfa252e0be2dcb45db99c9c8c7b727e0c792b26917cc92c32f85db9ca5b59d07a54faffacd5f7e0e1485af05ae14fd201c87221c82b6dd51cd7739f749ba13caae68b3879349c423870e8742c9c8d539046e3975aa579d3a12d00c53687847b05f4539cae0ba088b7b8995e275d3b2a875ef34301e47c146d0486fbb40c21ebb2cee8912fb3407fc9e14e5311a5b2830d43cc74535d091e5213d91d6c8cce3a7c54b75f4ee84909fded7c9cecdc5d25794ed6affa40d5b565f4b0fda1260bff6645680dd57968025d0974cb0f4d3afc565e6dc8b5359b9ec7cfca2964048b4adf6e5c5ebd4df0a4acc91d1ab5ee323c4f013e03b2887ca17cd96f8b5cd4ea03f4a3dd27a27900bc15d7655ea1326f1811fd6434bccb550e9306231ff331f60412623c7e6a50d4eddbcb509716502f377d30c43fc98e81c05de1ab7f22007fb54138e217daa6ba80e16dfd651db70bfe401a4bc6a52710be479fc027f1d0d3f6bff69738aeedb32b45bff2a471fe45ca5a1134c1b3c41613ec9f9017bbca33f764b5111ef7de05e55af9fa82257c1d5dfeebce40df032b988855fe3d31ffc70f4ec0a9b4c9a43eca39343fadbe28821e2f775177cc293fe31fdbc802b8b60bd9fe78ef529013cb1cbc8540942bc7401695abd901deecd4a4b3dcec12d162b1e02525244a7c5816e43379688d9d0e1215fa5f0dc2031ccad55f22ece822bf9e29e6c0cccc6809346b7833236271237067abcfb5ba2e8b86ed011ea94434cd0208abb4be5a2335b5d087186e61d604ccc9a970b994185901bb620d1917373fcf4f4107e75014e979886090589dd1f5638b8cee303f1a536e454458d5e0c7467aa51194dffe030b55226e114295f388c46f72640c41df99ec3b23bd4fabd4f8702c590cce60bb8e4f2a736c8cba403e2bec5b8d41e895c54e6692d4b5ec78a51e184d73fbb3f222beae7ce2afe666b59c721a52ebb4da6584e8f8bf2e728ddbca850f8b6b622f2de750e881aa12aa7367fc8e51a3539bde82dcb1515d5e0e7b7a7fb0519b80c26f5bd6b3b7345c9da1c78a95f4c2a3a21085b1110995452157d42203ad60c6150e64f2da47592d5d4ee8325f4fc8f5c38175231e7e114a2380f8cdae6fbfabb9d86015f2926baa432ed37eee059cc96736839bec33840f3fb6cd2bf2a17065e9cc10f214cb71ba8c60cb9f494bb1a22c396fde1b7b4ecde198bbd53b820c84081336c1c18ff64dab2377b9db00623e31c19258d60e9d1e544ba4290b6220c994ba0b8928ac39752c59bcad84a7ba4ca2cf55abe4f499b9ea7471eb521183effc7e4549138f246fc4dc95da0c9109cc2acc58a10603a5d6a025e22a324ca3dee22c50140c8ea52608639afbd4625398bf7afa6ecbb876542113ffc73976f7cea60761adb00a9a1c9842a00d7f7fd76aa7bfe820dcdb0ba1024f1a9c9d6f047f4419012c3aa8fb4268bf6234f50877610f0bd2a01a8086464606dc38142dfa0007feaea92fec175874587aca0b1931a7c7209ff8b19d589947a4da1821a2919638e7682640852f8afb058284e938cfa959ad11d43514769ae0c9eca70db10f52a0d84f05ae59199a50268475929f33a72a23bd28b76f7f9a9e5d049fb0ebc20ec6e95e6b5b2f8b10dd0d9136b7efb640402862fcc0f1fd9093d67dc6db1fe78cbfd7ce52df8d4f8b425a9cf0babb75394b0db01db2349715b42929ed01fa9bac02e82a7caed4003560bcdb10bd6217d01d764c500c0372f3045b964368a0ea9361e159496fbc4f3fe83e2b24ea290d5358bc6a9858521b138f62d422543dfc663a794c3fef6f7ef3d133a4bcd3bfc7746a8bd4782f741187ca5c26ced38812d9f18f0e43bd77ef7c6096f302e0bfaa770fd7101f0a433c891d4a13504a89e62d7fe800d88121ef720b47dba3f345801e930800cc21adc2f5c5a2d1be7b629dc79209faeba9073245fd80a8054a4f28e6ed5e6472c56ef04dead0bfc91645e9edc6432d03615ac17d7cece780c25980f81385995079f83fb9690a75e278dc55ea63f443709213b34b4768fe80d60327579396d36d464b574426ba55574c0e287a5e3d0fae463524d9825348158d82212e67f40d97cf6ca19f5563a385eb0395ecf9845c5abd0ddf5ed21a43ec64f1ce45f3d379d115e15c228628c7232e322f31680957b0cb0ea1825ccd6eb53954a3c469101521cd0aa50919cb69df8ea2b2169d53644550ba448db37772bca8b03796cb768645598ece4ed8400c6fb15ab90ca9d3365d8609f23da1e95f61ae7e33683813fb353ec846c9a2dcb3052e1d0cfedf8b50e300ed5de3c68c8b282d8b1f69525c3e6afbe5c9cde5822c26d1971d40d80589e94c8ae2b7889c4a3090cbcc87a27a3eb06a000955f53ceec8dbbe3617998ddf71bbc4343be88a094c759b4869b1904731953989a03ca5c0a0e862b13e1d7cf84e2dc4c7c610736c8678efd092887205167b90b059fa94dbc941c75621cf5703ebaab9909b6f4b419ce013fdb3cb1502d758174b516a05a5e5a8d089cf02f73281bfed6b2bf73104a108598f7903d39fc8506bfcc7ec2085638ffa5bc894068a9cb3f7b07cd34f72c3e9067a492911e51558c2a01042fab63cba9eec984c9b87a4fda83ddc19dd7082dab8e37bb98419ed7e02a2c03560811e2c77e2f29de89f107363373fcb05cb1c9467e4b1eeab63a19249763eed40cedf7ab0ec2d7d794eb1079514ab916ff1f2af6535895de2517491ddf56362968cf48adaed3fe2ef81e6d9d6b2257e8a00c74253046b249319c06b52456ead4cf83828fdca7a96072fcb5ef9da1aee5aceb2378573aead598156bb059525bde27e314aa5209494aa6c880938e5694fc1b66cb7c676807b8b2fbe1eabdb447fba8b4016f63caaf7267b20d5a6a640eac97af21ab051591e0527942d688da8b1a06091d77c6d92b6738b42a20c2bb81c50da9b0c88b5a5d9d41a0b948a18dabc508ab295138ea675c452287bcf77bf72774576b94eed882e9c5fb9483a542ee694c4a84e737d8a886aba9a417f7f9f54f4af9548f8ddc61fa637a72b2be6f1933da9b19f6fc5cc75bb34e12a175b2db06c8f3256bd4e070c31ef7cdf7eaeacc89947a2d0791f34f0054739540e7463f8ffb4e6f5a4cae271914eff3113534155fc3aa406880596f47aa8d6a91c2cccaf7e25760b8bb0303640edcca4933c29a3e6acaf33a6c19f8e323f03aa15cb0468e2d6ec01997ad93552a672902fa9c4c0853d2be3d0359612e76a1b43b6f8203101281f3eeae87d345b29ab040504b128889981e6c60f2b8d999ddfaa539f728a46a5f84ca26b9f452cec3f84b35aebbe3ed925f603dd49fe53c7feac5b97e4dbde4807aed0288d41d87bd3c3c8ef40380594c42d10dbad1690a0301f1762fe1ed1639b75378d6b112e66ddd1642f78087d8e1644e062673a559565acab7a06784133ee301b40c514277f4e08ebfb512aeb3fee5b536644a2ec9b21db3f580813f2dc57effa665a5b331929312c26a7839a233a63912336be43bc9247f83bcaa2dbdcb0993d262d4193ff8f398ffdd692135efd3f3070e5771254d393af29a97104d920ef413137d70499a46f58a3a78fc1cae3dda3ec23f7810b5c7e07f6acc92f56494f6243dec7ca4c5305d88465008f967342ac8a4bc72dfde0b3de4c3f7ed889d52bd2ea30ed83d4a00f2b37274d831817782eb83622aeed2547ddecf3fa8b298f720cc13b04a020c722fd797720bb204700a964b79fad526ab40d7673104b04415c141d0edf3e6df04871ace9e36b52e2e082a6657108188d9b966bd82a1d62aa757207f6be6bf9de18965cd898c40ec5e91bd74428bf2e6ce3f8e7bce3d50954cc075df64374dbd15a1e5d414bada54f2d4f09e68c2afde5dc72529c141aa5d4363345330d7ddfeba71c8d8229a0ac29415b4ab3cb6c16664b174d98eebf5aa2fbde8ef9b63e6185ba3bd80bc6caf303937d118510d30563762decb28c2c7fc40c651cb7036155f9a1dad9965517046dafa9b68aff0c9570bf1f8597de5c59d186571f7c5eeb8d6840a9623b63f5fc4778f80c55b738df19669354b5eedec3c328be795403571ef5952f32824946815b9d3fdda29664654bd195cbae0d61befbb415da96d4352ad70260eb47e42989528d004ae9b446b92c47d92ed5330da65341427346649216d88135d899c9329b4fe3a2f9a0a40b99f0f89a4ca1df5afd972ad1fdf7f66b1457960e0c63c799b362111dc907deb1105e6b939c542b68cf4bf576c1f8c6912bd36282d13fabe5a249faa6545f5b9a6b32d36ecd1ee3564c4bb107e6b7c047e33e3e4fe3ad524be89e08a9c8f00ae781352e5a5cb2ed0f83ec91c014287bab72ed4948d7fec6d27ada5add13d727086b22f2b8071a5200c8bbbab576492db7e29ce925d842b57007ee5f857a8210432e4cf0438af78eefcd0652a3cbab0264ec3095eac8d286b3182b8db8a0efdb003f8e945e8b3acd9612a59ca0a164b8dda4927b0a91c6f8bc4675991e4c28e105507f8fa383046c86292b868c9258c6bfad3aa2c1b752de2e848bd1b38d091c5eb9adb499d106a4336151de077fc98c335c85000c6ec04b9907c54e637f7dc1458c7c8584940e565ffb3971ff08573034b859ab4f6af32d881bdf7f52bc76bc76f5be068f73c7485d6af1fc8ba56a7ddf6a2663eab80dce774714d4dd30c45cdd18998fcddf760f9648f4475762fea142db227781e9cf888e772d585e96258e001be22a741d9fed421d0bd975027dcaef7b982cf804a1f4533b0a41ee41a767b5851e9f918ba187229982c9fc5e3a528703e76c4c93fe5cb899c020ed8e5fd993e4126b90162eed988cb761b0172ff4d0a773f4924fca8d3c8b8d846cb5b89584ec874a7934699e7c4c5683d3dabe9e649ec2f64374e273fe70d4326299097507c76619e1f9d96017d2f6c948e8b0ec79a275abec63e961f87f5ea133ba6038217bb1dc0c32a588d4b2e6340e2ec6b24469339411a31aa2b0c6e7743c5c94b7f2b47a4de79ec16e8b2c7aefa6121ed44e704076e8de1e16230581530c67bb4e571ad661b5e0eb6151be590fe9fe6bca0b0ebbcb3f72124a5a25f346cd8752c283f1eaf7af3ef2a0e601477c152836639005b53015425a29ceec4ac9bc2e2f908bc59d2a17dd4e9c284e44f230477aa65dd1b27111a4e023ee0fab90fa6d9e8efedae7dc26a6d386617fbe080aa46d33e673d2689289f2a2ae57a1b1ee41e1dd495e506882ee93221e036557b21e401cff76ef1f6eee623b9537c10708e19cb52b91e90a41376447d228ba357e032fad6d4d9680807f408ff1c7e4fd6316390bfdcf7b321b39e6328d5bf14417d3a092051f04721c92d7387c49007ef193114c890c26a2dc92af67a8dcf81e012c0df9f85a394185113b3b05fa274109ddb1fef0139d6b913f11919c05dfcd327015d79f38e61c7534d34d1eb300484b2b7b1f6950367fc1d62ee01d8c96727df2ca6a4bfac5608f010300bee6b8c0853afbd3ad0ca0ab02f851d00f9fcd2d2fec0135cd63442b099dcbb4732058e4b0d472eb379972c31858d5d3b04c3505db270bf152e3e6405b5da1de3ee2c31ffee583852c5ca1fcd2292297a87da2af3c0781eb0431dd1935949da79800b9b165d6ab38f1423b54b8384d0e69bbcff397d3ac688933708737fd2c12661b09759b38e2fd0b99826b411856fa7ce8353abe531a329dd96f8fa6bb637bf4cb626f7d1030c01d6d4455980764fd7ad74b0405149e413fdc2fec5f018f102d24e251166d7ed7c86c1fe7a960f78d15f321e9b93e175d7f2305bee17b25b50d9c195bb2a4a990329ffc4f9d37bd6ad5d1b74b5a7c4d7ebd872fe5c8cab0731714737354f391711bc235d847a9f198f168c8d1f471bcdaa041381723f34ef2e6cb679390b05c235de86c82a41103158eca399791f7c3acb546775c0cfb89fe8f1eb6b21b6113e46e4e70e336a98df6d3adfeca48f5a49bb560426c4e29a0863f308a4f4f80ebae8e1a0f1386a4d942d00404d1598b09899ab44948bbae0561158a9eaa4e3107d10cf11b4dd29f21bef8e484a087468e31cfee14b64eb99e65628bc093318ff7747a596df5a8e5826d4bf6bf32eecb39dd84e7984b3471654f3b6589b15244a86d2e213e9b05bbeaacca742b2d5c74b2a26730c32f54fd31237796e266b7ad7ec55605a8df322f6db6e5c9410ff198553f6c45314e4ae0886c8096de7b1a57fb31980850c01753fb2d3b0a8845482db5639165ce3c3e72369671762ccc19bb791f05403fb4fdbb1b8cefd98d7361df519fe627fee11d0c6317445f96f6a7916dfeb9bcccde481aa1f5c02bbd0ed6f50d6cf48bd5105acdefcb4555d4c7e19204901a9067cfc2934a173c9be084173356770c54fc60e6b43cc375530e7569651db2f08052719251f591d4f5356657f3178f2a0d5a5894e5feb513c14b9024b5d978c9e1539081e8de6e5ad2f46a2f6085fcfffd6ea314cf679e7d0ff475c4c16956decbf0b6a535707e82e23cbeb8024355cfaf35f7a5131a12066a657314f4fa9c657db7d408c5b13eaca38648218d1ef170a8322d844c220c4c69d31e62c15b1f31171328ca88d226394bd2a94f7507625b02ba1ff0c5864bc82f5c86907d598ff5298b08414fb5764a10baafd0da82b554690d0ceecba4344f1ad150a3ee8c012adc8f014c1e714650ca0303c99af833a7dfbda817235417cfab291a2096539fcb2e7d6078f9e585cc4e79fbb8581aab69f0d900ac8e8a4572b570db6fde5d5d44b7200ade6e78762f71da5982bc000c28a38ba41f86dc6dc2d6248c70f11c4d840db1662a957202edec59f8bd968866d601d71fe710653c68365c7a809d1bbbef7f57e3e821c487e34c895c74e29f1d754da5ce35a24ef2e888c41f8e8831213e46c935f48ecc000c5454db06fc5de3f806550c57e4112fd9885403291439eb4a845c41aa3ccaa2f58cea34f2642fe72e924855e65bc8eae811af85d4874337dd84c8702775e78453707a574cea5a6298cbaeeed51c82b29fdc25640fea38c47c137f9b30b45b10568dbde2cf77aab0224369844f485b3561388ed1151db7bf6c11043eb4475571ff417ff537aad95619aae57e62123d186a4489f360c00ba9bd633e103e05dc3b991fb42904c91bf57628d20e8c498014a2167fdb34daec596f484a6d72631447cf69b44719f24be62c8741d5696d691277d5794970e42d3078b3638e1d957b9f4a12ebfe57a9c103b3284f5fee173220228f245899979ada1e8c8c680dd3e4cea91c0809c50db59200aacb502cb8a2d428cf49bf9430502e40c2a47b59577aac9cf2c48eb5012e1b8234e8ec2a3cc8ff637bd22fbc1c94c6a4aa62d530a98bfe3bef90c98815ce83d640622c8e990309b6c511320bd9536b6a60b18e8c46461dc55eb472a06b985462922670b9ef0ef2be22a818fce57fa8467dec4afdf15d50faa79b2d5b59d0d7b28af7fc6c5d9c422c6ee75b1fc27c2bb66616b1f52210fa52caca95c32f38b3cdcd8bf34097f0c601832e866abe0c976f7352c3c7af3f9e3fb8c2672bdc7bed30834ee180fe20ebe0611708d872bf435c4d454f27591823f8d5c3f39c567e4bcbd769090fed571f2db706f3672b066cdcc7480aaf63b76c5cbecc4c15724b100611ad764cdaf572792cb66ccb76e5a5d7521056646165e79260f83fa6a522d139c4faed79320bb67c0a58b740e9dfce3b2708d943c13cd28c8870cd1ae734bbf87cd7679d37119ca9a5630951eb9dc9456c7ac171d355a57dccd85a1d8d59bb7cdce6aa44bd9ee96862a06548c53703b145db427daea72a2e62d4d28f3d0fc482d77b9689162bd09281c8fb648de99715991de80ffc382f2613055eb7c0e7e09a25f39260c35295ffd70241958d875556443fb40eb641386caea6a4b935226088def0f16626da408fd060d873067060ac28e4d7b5bfa51babba364c134cfa121ca9566902d4af40dd4a52561683c7e1d61115222a7947a775c779fdfe4a5df0d909cddc2c5e6f1228d914d17cbff773d84abfe07a6bbeaa831ccd16175d1c4ffbbf0b413df1926a8990291ea7e58e76ea71ed2158368c922d4865ca23451b0fc4f97dd06bbe10b687398dfded57a814e1d5e32021566a2b4ea73da0bd90e9a334c1770d45e67e38489a01994178da307ab0b0b8082a8d8e4b45076cba90a4f5bcffb3e3476b1d2897a413b3eb09125ff05567c72ab37d3e469a6f0ae43aa96a18ff52a3a90c4edc4bc36827b28c3eeb20d1a70364f3eb76e0a35f8603809edb7dffc451339395906a2622b76d13cb1308b4412fbbd0f19588e614ac23137369db3e189345d23a3d3b1893f1dae8cf6542c0dc70cec45682670487bc79d0d572102f7cd61238b530b83dd3158ac6b2c96bd21f992b8848c922660c6abbcee1e069732d89bebb964e51c19f4efc66032261f3c03a2a857eb310374d385f7cfd7b46b12a78c0fe795944f0483afedb91eca4ed0d71265d01c872ea597fb20b5ca9e36bbd564b70d1cacaba8dd6167b2fa9b8f433d7f85d88c045c9fc6367d6c7b7e6dda552e38b7c3d946d0bc5c8c458fba5733dbea6daf49ef4428ec820aff496abb9f2115ee9e3e3a67b0d828ea83a52f22cf1d90ef6d06d811811fdf138104ecd23b31586892b91621262f77580fef99d8f836488c81fef19477a3825f19b67774b10aaaa7a5be5eb112126c99076abef7abb752fdbebff365e1203658e310695336088b1fb6209754d38ae2cf4f70e2937afda805ba2e607a9feff969c27c5ac1ab5db66799effa6c6f70def0593aae7e9119c437d79c2e2d71fb45454df6976cf29e7aff5d20d3902392e37f6e67764dbd80675db252a1c95bc5316b64084f530a8a1df8ef29a8586957bf049b64a237f7285b37f28d621d1b5d51c5195697d06a781e10b5b6519cccbad12d9c64a7fb5a67969794cc918648a1141fe168fae746e975fc7b81e047353e8d7ebba4c6f7882bf401ed0483fa04c36c7bdcd16249e3a046af409a1bb9fed08840ad21440ffe27532b96e2f6b7c36e34c4b07afe16e574277994a5930ae69bc4c832caf80cc3f058172c2204a07b4dddf9b31bde690026d92cee1fadc57c73606ec476a6dcca1d486f80561ed7534924f20cdac567234d64aca3e5a8a1bd3105ace83d5135672c7598ecc1fb5c6d9222271f956efa90e600b6e2b00700b15cfdf11dc719e48ccfed7d2fea20a6341708347ae57ccf3513cb60c6b2b62afc5b72661dae158f11073b97d4d71755d5793cb491af8ad3b30b27f9211d24bcfbb2ffca25d244b162f466057bfd43c5237273371d4b5d7daa9abb40272b817ac52f0fc3fc385d1a88410559678b128745217ab537d4334fa341e2bd598d003a40aee18147aee04636d3a469642121e2ff5c2b4da398da8b770b7624ee8279e6b6966f89ad4c234fed8780db66a2290a7376c76c8fe979ee1676ed75716c05a203f73a3571e013e05a47fb17c7e565ca0281693f48bbde681614b25d7ff263dd9d02ae10afc1039b68a47ffd2ab7cdf0931a2ffa1f768d8821ea0f7ad90d71dd4318b878f49796985c2c211ab5f46af5246ff4fa8d7353a7b19359c0945f8b843c5841b9d2b70b2d1fb92cfdc3ae3eeef24bce261d28016d49ab20e00d856a7ebf339bc9a6ae4cdf08c9340ec58121d095093a2d7d28c86622778627fa246d258786dc4fac55ab5c79b9fcec8e790ccb0a6b3600f8764789d4ab53bb21284bed93efb3210081b1170d60c5c9b9ba342b1b0c3fd85d117853bc054d7ff5c9fb6caf8479f1b332607e433171a26a7776690a31f00c1f518acfdf546d6c9466f4d81752997714b8d2664a18260026b08a200901bda598d4bbe64ff7a5bfa4e09652042b8466cb4b380b6eb9321c3dad84cd08d821577f2cc908f476ba9023fbecef4010c59ee956cfd08399659ee87cf1777a025a11cd08c77ad7507659d17f3da0aa9d4fcabe9c8d8c2dc20a77276c952eaffed6f59164c3626cb4311c13984d1eed201b93a6a82e5ac7e8ea2e0f256f6ef38c54abe60a7dbe8516d98904a47cf53e5790e3dc1da7537efe634f8f3130bdeceb00d2e7bf66370ac2e08f0545d6e54932f3f0a3f0eb292bd1306508071a47fa11040c2c2b820351f5fbd9703f81e4c8f1bdd593cfe5229712cb9d282662c4ad7468907e19340b52247bc4d7bd4da748e73fe0f5c4b487c0e0c21fcda667f903d3e04760227db1d6a6c858a73c6d32e23bd4d70345f48976664db0734be4449a434426c81af45bd327c382f28d92874984e263380ed44d6d1c2ca8f7c727cf810489d6f70272632a4ee442bc32d45234bbe16d2c41483509a0959dc364bd54f4cf674924e6e448a6685544729aa3bf433b6420239c0d6f37f92af47f4e962570c43bacc9276fd75a8cd575be1e067f1d6daff8d051dd044ed201cf483edde529132f1b4ee28473ddc65a15d3c1a6337346180ed5a03dbfb5a3d78bb5a4fdf4d890e1c645b79dccbb811166bd6f5771f7e6fc2def4f6252303ad3c329ce78d36003aa4c5a19d86d3c1ec535e12885d6a7a96482d16abed89fa760d43fb72ada958dacfae671995709f52fd556f4fa4e997bb46f72f8f603a2be17f491a7922229afa17215bf4fe832f2ead5e6c6a35b4d7c6733d32639bc9279f2a3478b53b65cc2b1e9d1de82e306bab04551fc1b3c6915ea9fae679505913ccaa2c4093493215a78ababdb81dbc700c85cf90bc1da619bf4ebc4db21e53b08c49834e8b938907ddc64f3e4d3c8922bbb8ff128a5b5f75a49d4ae3083135b4c63bf330fe78e96c054e81dc68dea9681d477bc7364b6672e16fdd2ecb7d03ceda147d55cd7b19da6babc8c42c7d99a9db00405de71d5e2fa7e759a6d2d7edff2c0c70965eee95478d1c892d6fb7c0633c7b65777a6295bb71ed4b77ff8411fef4b5143c923c4d41f327e4d6abbaa7e65ac5a48479bd32a3ec610aed8301d6d56efba367a11903fc93c0e34b7b8eb47b8b5838287ed100774eeef45f73c7fb3faecbbde18c6ccbbd701ea67545ea6513a6bf8eb30cf008384c9e185c34cd773ffeb2295479b9ca44ceedc7860037217afd60b7bfa40b81300a629cf07d3286b8be17b5736ca94c7f5d3539e9b7022ef18b386580b404f459a2f58676b9b10c91be4f700d994a37b1923424da45a12ba5189afce0482fd47fc53beceb0b93d584b0eb9e33af7e91e9cc10d8dfb884dd71520414f6a60ea7232e17d2c23b1f2a95331ba62087acfbcf4d8bdfb5128061eadc9ab75fa49be51b81386ab0e0cbe3cde5dff0b4ada032731b3427c33ba4d9af02c23d76b89113f5dcdc2f705d2444c8c4ad22d986cd83851d7415900ea9abd5f5604c85e1945f3060a353d4a9310bb9a88b37aa0b82d848cc5b07e8f14c5ed7dd1dce3db67180f81508960a25a242164207b80c8da7fa3b109a44d101d8778f3755f21bf074febb820acfa7c42e431cb13381b0a2761a03aadf51f5cc43fb0b18ac2887db85f5f4770377c9d8859798d75d3a5078d28c8d232c98d6d81195b1366060d91829b4a1ba8d89ef5794a1484ae1022dea619db83c16a75808b8458483976133c036092a20573ecd95d6f95e7444d72e0bbf1a103a3d1e2ad25ec5ece5e87fab9efdf11274eb46db7e334753296fbbe9b334f1952c9a0f70df6a4405b9d9e83f9d2eed94b2ccb1eaa04a6798d5dea2772d1d4c3e3edc580c45dffd9ea3b4c25c7c65e176f625ebfdc4e37e56b4a32b22d8a1fb836607fb1d6ee88a56e9c849789c1b231bf15237fa677cf79f07648628729d49d5f811e4e9de07ab8aff7976b10abb06965acc430d8ff79496e0e561dee5f113dbc3c8d418f2985d5dd1a417a4c31639acf53c1129aa9716c27be1e788e0f4190e147b03ebe4af62ae843546cc38a5fe97e301e4ecc39d2f30c2bdb05860c430ee85567d95cad573b68805bd7fd843bc73c996bfb290c0d602852235fb4fb62aaed049bd8e24017b3ea05840bf8da8b340a99071fe7225d6c6ce5f86d72209fca2e6111063b2dfea74f0246375492e52b3e5b3a388527e15b6f03b97cfff5dde019d4cf822f1048bf8785fb75f4910eb1dafb0e967d57a437dad12a0f6f715af3cf3e072be79b56aed4c9d3caffcc9b927a382ae66a935a2b7415ca9cc1ed425b2a176caf4e779cc9fb28a3d95886a44a2f765050fa80ad10c0d0638b9092da4015657b548631ba5a3ec9d03e3f69d15fbaaf7e4e8d55fd48db336b4ccb7d7d4c0bc668045f4b57fa42c001eae483bfdd1d291180b9ebf8e5b83c54906f561b15426f7af7a512e5c2dc4ee5043df51d7452c8351efbc8b0bebd99716b8ac3401e001f930f21ee6759d1347bf38c21ed556f674a11df48812410ee0916a0898b52d587a28ca89cd66ff0cf9f6b75e369d82cbf8249ed29c916aebe1fe0f40823b3a221c6bac6bc30b47141f558604fff3e5cb880df72dad9d6901af53b8480e25231cd1ae55847f9aef31d1f1eb1e0302ce5c5651a069ebd11e2f34b64601071a1914cca10f29dc9e501a72313e3fd87e8aecb4103c921d4a49513a9d3a604225db44c7c1b9f5c4a84494c9cf60aaf19b85735c39aee8dbce61b063786ae6557d3251aac4d88a4aae95457e2da86a187f4668b38d5439c7eb0a76051932c75045ba6c03a6a12023a8671bfde53863f1f53967335597399af4f8f6f4e5adf23f41aca3946d5b1bb8081d65e178d6a28bf8122100efacef5f82348d5800c8eee376c2b87fb8c4d28885adca606a0025a63c1d7c77887912c2643641774d0919d9c7282b99dbd7dd8bdf419fcb9a4c6c7bbc798b2e7967f721e7207d2549f685446a65a1887e185cb4ab2cfa378ced747fbbacf15d9948b3253e825a120ac6494c64f4eff1b17ff2e842da1cfd554d27e607d986affffedf0fa6fcdac3a22af80b733fc93f7545cea3b8b457f44c6cb7eb7579e197e20feb0ec405680bf27351b9b718e49ae71ddfd38174d217cdb3c29fee65bdac2ad3dd930b105192f0ce1f3717786302cbc560810ef10cb1c319549090bc5e533ee57229058849ae740ea45e4876120bad9be13507a4a83508091d728d60df19237ad322a5e35c4c27c7306006af8ea0b3d3d4ba550d4dc170209a6c093b1f44ca497654e868227731e7a3d5e8ce9941fb4934794c802f02253cd3b0f54e3c943abee9b13cc84f606c6d7e1145c64ec7c087298bb05d4aafdf9ec7a619a3412cd1898d2d81d2c8312deec1de522f4942c8ebcf6919c3a5184a5c9b8aa2657487554a5b26d36b97520dce08e7d559ea7434c48a8937f4fd43350d60d2b294ede2b18dbd32f1ff32b94413bb89a96f487a54c318f669806214048a5e6024264d56875b0438b5477a3241a28b72f9c2fcc7697281a59ff1c29dfbfa5424fd2ff94d232bf2e4cb5be1eaca94eef83495531591731b17928af59c35e3ea55e51bed925e70ddf44d1f1720cc851b3aa78094ab2a2ce3e6743d9018f630470cd221a5281a0bcdbbf01beb683d5b79b9dc9e6229700b4958b97c9601720029d5386cc30a838b8ea15d07b2d5f621db4cb5ce3b77f155c4c94d2e19b5a6b8a6707f02727a085b7a1cd07a98456227ef96300073d707a7b1d9654ac27f40e2f13f87f63aa04208a0ec463844b7eedf6851c72bba77b927abe43956916c8b933c7e278799d61f1f2cf8ddf15eab95539967fe0aec75f577a08ff374ce2ec33c8049015807c7cad16bfc8641bbfb82bfb198cfad0927b8ce175d0443aa55571c0a4803aa56b4fbdc17db2144b8abb357348db92241b93d8f4fbbafab94fedf496d4e6a8aee6a80c96659d8e8c43d60c24068d4649cb625f7449fbd002e689a9f5319909a8dc92d262d979fc4693f05cb2bb8432c53764e7df017c6c3f37fed9cd72dabb130756828d2c4d224324a5c37bed2066a933cee882dd37b7a60d9f232e2e738c7e1060780893e93d76988eb8f9423d0493421d019694c3a32e40b213e02130fad8db1bbd1d13753d0a86b62cc664c645d155f3880b74e7211e003509e03c366a235d76255a79fc0fa39ebe79e68bd4a71e8cff084337249ed5d15ac32916654ae0beb4fd5ef37335a05d3e97da0db2f48c81d498f0e5172b71e85662ef57d8737f356e57d513c5dc553be51e41d4289a40caa14c6ca45406d272c9b4a484dbd0d50f57607d3da359eae25584e45d0ee9f58a1d8b8c7f3186533c335eebd75f1ec850f0bffdbd4364591cc682d9804a8bca2f3732e0952c586ed5e7dd9829214c9ee6486687ed85b92f91bb6230b643da14e66edd5d42aeb70987093a1f96d3bd1709fbdc84c9cb4478c94465df7be9a7a692c1ab2a059d2f39b0a633d608ab884af4590989dae9fd55959577d3d2dcc8f4fa28bd44eb518d3e41a882f9b64dd1092f59af46535ec5dd5e80a3ae8364963b7dcb08075ce6296de7703703a0ce3585489a6a1d2bae1a1ac0570a490fd8f5770636fa86e762f80dbbea40eb538eacddf0407c258355c8c72cfbf7c6eaffee5b0ab6ee0abf2e86f021c530d58f6661f6732b2e00e557048cc268cba78a07f3ea6b2442d643b5b6b0c308c61c61144a69c9f56e3bbe85291e18cd13586ec233c54ae6466b9826fb3906f56792295b7a73ca435f6890ac7b6021954889a2e9e245e9bd6c6315adf3965f80e52bb446ec6c28cf5b788ead0fe823f107838376bde3335b8ce3f46efc9a0ecac790c85147306f00cf7e86bdae6a17d0c883ce852539d446bb963f2293afa1f803fffd3391cc5f1aba7090d3162829cbea051571fe8749e5824c284a7f151ed8511e181b4101a304a1eda676fa1a6ea7547f2a97dff67643184810bd315f1aaeef4d0a329122ca336caab2fd7699afbdb600b29fcf8c55b4b6e2bb138ccd1cb755335a43060da232f3e433a0cb672415979a9d57963942862b7071ecedadb8b49509cc93df6256cf0c2b5b9ffe53b67e457313f681d88798d608840a095491a245b3fe2befa0246d73d0eb51f0c8dc34c3d048cf2d9b784b3ff6b34b20630bb289b1d0a6f781d6f3e01241e33e184fd39c46aa455d952cc40ab32bbcbe5e59ad5bf7a1d389647cc7ccffc770a40ae0283351f6bf8486aa67573abd4ea9524e9921390dcaf4ea462c9c2f64e837ffe66d3d55876cfc61946359ecaa3101095c0f8197f9fd7b25f0a8cc8fe4f682403a554408bcee03f451c37149e70ab95eb798192997566cd47f660a9bce27693e0eb17e236a9a51dd0cc20b2aeacd69a9fb81e51f866016b183ba66c9a8fedba0321a280fd46199d458391c580be18711412d809fd186a1c837812795c67d3c8a9c1c0ed740dd5a0dcfc81d8c6c4bc9a08eed81acbdca168420c369fee56c26a995e14995be099e4267db6046cba996724f452282e8ff61385410dac11372ea1a4ef53f8b6c811cb5377be63fd041c28e2b8213db3e3ea1c4957f72f31850225e2715f5385f9f0d7486e74ba46a522e87c15b6ba33d1f838885ce2cbc2350e213fb7b560c5430d6afa68a00a2992a90a78eebf40056f35cb99d6a51328f040ad40cbefd975c061eb845eb8602653e4740f39d523c613123b60deddf7b9185268d3425e2e525361e63b6210d951d08ddba8b5c55a0d926b0489438a888d56f67ce8857cbfe0e658415f8967e373f5172b4147f190d0d8c6fcee9696b89af2ec53a7084176e27543fb0d749145a1d21b0976b189280804e2a74fa3014ec20fd8a681a05fcf0f2f928de83ac9fadaa6f5c115221684dcd025af3f894762447da24536560f0b695e84d44c8e068390d8978f2a29e7651c5eb1cee4a7794ff7b4264db8082ff51f2777112ed617a0a9c8567ca5f2693bb76f95d5edd0ebb4b9951157e52a60242cb6d1c403c1482ade6b98b03ba0b2407479ce683e821f712c0ab6ac3a31d5fcb6167d4551f3c0f855362ee74fef026fa062263b34fdbbf1925e2ce4ce9796f6cc2504e5706818b025c8df9b758ddcefeca798fc061366b9f2e6d2f9a938efe320f8cb69f5fee800eb84628c91f13f3f8877d4e2fbb9f18d1b34d0f23e9043a7045a2e28146d9f45142545b1c65bd7df8eda4449992d1c983e0d990aaa3f913d1b19667fb1f6365172a90e9a72a69427b308dbf8d33b8ec60d16e67f2fa9ff61053b970b149cb8fd15149bc3a165511e2a9b3071ad6ee0c08cae1479614c28a8d758e579991c28409e25a72d65e53b6ccdfd012c560eeca929b737fd49b18a38daba6b1d760d27b720e76238a67843fcc1e9ee9ebbb1851c7001c2ac241cfbcf554e86041ddad6bbc95d821158a722ddeb7b342ebc89e06012c4eb37788ef3c1d236a29700f44f587b830ba05f259b0bec5cf33ea35118a081d03328289b0174d34622288186b1dab8203ec3b60ad9fa23e892958b3c0209184a2a498fce802a4b862406ac4a47dd0dfbab17e16689642987a3f822f4eab9b714d42fd7fbeab58ce0b4238dc1013f577d49b6ec15ad782b5dc14c7ab34fda09dd262dded06ce8c4bbb560f4ee66d2477c575be5f8e6bde3fed2d9309175e779081b174a4a9b05681731be45c42fdcc3d237ab10e451a0e9e0681ff3df1f9270c7601a97c449772c68c1967845c7b700fff770dc618f03722694b63c241382609afdd5c04479c1ffee1ce349902c5a31562de9356be3d2a8d54dbbaf33e780a221c0892e697c35313b7eed49f581be0f214df4225774148e48287b0ae40546b5dffaf3f330d76a373007391f2fb5a90bb15f1f8a7432000f3da3ac134f1204f28751393825ba7954b430118dcfbe8a046358ea1a57eca0ffaeafc42bfba78281677f78ed688ae44be938dc3a4a8effeda3f765b921bed1f42b843caf2cbb8dda00763e2c3455846f5384192e34c81d6cc9ad51d58286012951b357116b22c8d4f6af952a646cdb5d70b4b755f381bc3b853d1176c1975cfbf6d057b940f1ecf25e58ee6d1693cce47a27922ea40f779658af6ac5be3c9ff7a0e0b7b78b080a238c3a75a6dcc60d1575b4fa0ac69d25c80816db28d209d21bac6ae902013e7ab3b474d4f3678cc60f8956b634eb234251bde40feef2c4276d416d28564c6d6ddced9f8b45af7631b2c191faae96c0a80c11f56239167b6ea1865ae872184a3ddecfc3eb5960d9a83005470e3c2e32367cb6284e04759af8bfffa1cdfe656a22a21dd4fddb1c9c7bfbd1a694472e09504d3d318b2e72cca5e9a3cd99bbbdbd91d203aa699cc2be24dcebaaaba4d987eaed306b60edc99c6e92c2f89df248f1fe3faf86e9308f71575900df8976cd4ce624371c06645b862eab4e62ab1c75f0361edddf46e0c04226dc0dc243f366de3045cd9e1a35ff81ae7375ce6aa75976ab7e35d4256e9c26c0db3c29808d9534a1da48f1e357b680561cdc4034ecd4a2c15eb5e6f01b4e4b9b0f408e833d9c8234c6c3bbbd9764615378a6febc020ba981a9954f86ddfb369500f34b4526b84c07a5f8b5740be9a247fd940e0d4e3ff0d68a988cca1d8cbb6daf49fb9aaf208c01152febd7abbfcc5e3278139550cf67ee0d5921a329e892f487bb41ab7f65c2d4d16f853e0a7ad93a0a0c2ccb4a63f3b8047bf733bca0c8e37ee7e10c12caed40578e87d40321e54cd18b546d37201435cd0c21460e189015df4808a791512ca41b87008df563a8e574ebc634ffb462348344739614644a2706bb3589a46e0da6a9c5d8d09c7fc65ac102917b848d3ef6221f203226212e1f1d9c4eb6644ecf2cdf4fa146e1897e67013bf56c36a21ebe5a70eea493e839846e9b913165753605d00c2f835671099cb5c0ed5b4ee62af947392f6fc0f421f672ad42e82ed6cb72efbc0f931c839aa350498b5c679deb97a9b50d3b9326bb1bcaa0b93f9b7eebf5877a1439dccfbee3ec23f8a92ea8ef8bec3797bced3082df0a143da31a715e320ffdedfb4424e91bfd113d74b98c55b15c912bffce7ec41d4891e694341e847a56e155aa4f8e48015469c2d9000b84f610d32e859670ec6738c1db8fae3d073c3e462e0f36d8c1fd8cf08233d657ceb1136a3d3cbf2ed957b2a126c5f7a737d4128b7b48ceaca669025e9c95fb577646764519b6b38df15564dccc0d919137f81b7bc459bbb354bf0f097073fb8bd13a7f8512978190ddcaea90ce656e5fe09581e30844baae7ebe631ba5a07662ae74a4c4a4b707818c14432f9d95ed0cd9c19c3d2241d538ab86c964148214a1d7f709016e92c8cf02d551af2c557fabc1d12ecf3e9ec85dfd2116b319c393a3a0ea1389574b4c5bfe11903edd3c29f725c65b53ec5582cd428790b00b76ce00c213d6d8ba6ef30e6b6f09c1051e39452d42da743252783712a4186c652d7b842a40e7cf541d5e436c2491fea6c02e1fa8758ab0dba15006d63630a3611d05145160b237f4ca6b08bf682e25c5bbb53ffccb58c0002095d1f4c794864a92b768d83584e2682e39cf7772bab3a6d241fe261288455efa874e416201cc0727bc374e61979c09f5c195fc90d3902715239c7c73919f6b8a7a72a6d0efa9de4b0c2af6840a41c356d52897911242b0390c8cc5318f8f94729770c151b3ab4d70d6498360dcfdd2e3d3422806ccb5056803c589eb3dd0ea678b458dec1a81864061487b9c4eceef0f9fa9a11d115935af7cd6429bcf7ce2a467e8940adf0a4fc1e6e3798b293a1d4acd7ceac9bb8a160a03e4c6c3f97df1ff447108e4714484ae1d74bbf48814d2048d2a69bbc2e5f1db43e12114593098203f26d9a168ad990f4069e641e55eb7fbcc73312aaeabbe1f5aa4c06da07bef988e7b7faa3301ae083fdb6cf3d1ea9dede3c89bb616ee5afffae3e51747e9efb087c6c1babc1e39c29e8e6fcf48de611a5ab2bcebbb6f485db390fa71b9e4f159c6b4b62b0bd03a26f7d204e578748cb5bd48510b9e3ad7ba4091a7abafecaa98688098791ae77bfd5b6e796b487efff1f65a1430480b31a9e3a77910df38cb21936c8ac8e9f18e6d065fc178c7f8b1e44249755afc8ab758b11feb0827e92cd508bdc632324ad53a277adfda857dc6d4114a377fef144c941727124b5f307c320beed9b17a9e41be5d1e3201d73023a055e20eba38d0ed008397cc9785720af1888810744b4e2453e88f94b5944a1fa5ecd7cea07bcc44d36324d208521c1a6a990fca064f904b969034aaf307da9e436c1ddbc0355fafa565bb3d4b960bd6357fcb2289d80f8fc6388ec50c4a1d9f5578406f62f15354fab52913e8b2e57ab68746281f970d5f66c36810c06e1d79f6399c0316c8132988c0465fcf96e9a7946e88205af014fd6b72d1fc8b035f4c7513d86df417a5068e0b55be11bc5e3cb476e71e0d213eea23a6984c07a23a1f395f18cd0a6c7f1a5a15aaa97f5258e5524d1108ef6424214eaac6ff16b08059e56fa4d316b01795965be1bbd42215bb4f6cf9c72fdb7a775ee7e4c475f96be9a070fc8fed061bd6788016c886be5694f25f74e82e20918d66361eca3b040398376705ff211af1de5c8252911d06762c7483d0815a7ae5db767ddb7729590eed6f99af5134423078507c047e60711ae59743d19adeb223554c8f321b0ee7aaa8a934f6eb95a9df21afb5c849320da39fc0bcf5f0d27d31a8ecd744e4e9a62d921518e818ced282cb30779b9d69cf178171798a35c4789e28688dbabe573dad02e01760ebbc9138911ab4e4e486fc13e2f6c49972aa12e077e793befee541fd33ab56f7ee0852ae96561822dd1b9113320251241f390e89a5521bbf04c6a514c719280be34a28b63f6f815d9f603cf38ff46807a5c072fc6b113a972e3cf43713e14280169414cdc122159b4b281b9992c411fe87765b9ba230aa8bf304301f1288f3f713069f8452f26e9aa9d12c7ac9e9ef4d77b3bb4e18bcee1c0f55c931045ef12fa22dc631855fb2ad8cc1d1e5f9a4b9d7b0d7ca803eb795e1bd841d78ae3e945aba658eb0fd865d17dc3540b82569b2a91458d2a3c3e6a54f7dae4ece4f9d499bae96a30e39ecabb526b31112bc90a7fdfe5f29ebe44400eb3005318f17d9bd8f1e764d0944bf142f0dd7f48dc39ebe0a59362589fed13f65e263c4ff1a063516c25231a967b2c7dc87f73c35094ade2612d41b53843937c77ff97a6e587a9fe150ba6185cd286954c1fbf787193d83dba7ff82ce2dd7d745d0b1a482363ab3b4f6e7382ca230dd88f7497460a3ca6d8a7a74c3e7583f0bf2f3437745f2db1140897fb00cde3f1b6d1e80526366a186273221fd8f7792c71b9ed63e710bf11f513e8e6ee3ec8f9839a4e6b19f762137af3300d5d325a79323ea39e9827b6dab73b65f568561ff73e1ddbd50d048fce5c5a99fa14d8c1ca0f3aed6e2c6a8e21ba70cb1bcc56e2d2e16895c9b585c1fe534ab3804e07686b958a2add5c6aa37e8575ed6d33c2845f33eca799922acaa24e92ca58e3d1900baccef5002285699e8b5989ca2338c3da957498e150b2f6352313f6f8f2790243820668c58846bca498152e95c299dd2cebf36f40af9e7991aa5e0d9e63e3b8ab004a36e6a40295f9a05331aa803a08515ad85fd69908175241952ce52de19b351cdd2c04555e97e712401a9fe029f0e5edeb684b734aadcd3ba32f5583a92f8dd201231a4c8531d32ad26cdeb3c7f853dc205587719ac8945c5dcb5612ad057939a70a31678727adc0163f48e6a9cf38ca8529cec868cd74b4ff793a7c09b4e9e878445b164b090e6f0e5e24b2eb4ca689d3e683a46583760e7bb7ffc77aa151c4af3bf16e337bf19fb04c11a25d6688a0d64f384071bb0e3221b27695fa4441b51aa5317bd14a0bbdd3c722463104af4c9bb715289e249e704abf9ebe7348e957ba0943c903fdf5f0e465bde9fb023b234442a4dd8008b9fe88c34aeef4bee6fe7acca1640fbb91b253dd61f06205ea111863fa5b482d4f6be6b5110c62feaf6e6a73953789be3947a020f9d464e34eca2f6bacb87f08b3105778d19eff7dc5e19babe3634f9a36e5f20bd80f62f0f6f7bfeb1957809c01a28a7baefc098b4b84e00e96e52b0407ccd50f9c30ac206500b5297bde52a9c23ca616f6c0e42edc26c28af6117ae722905d6b5a5086c1c8c445f2ae1190022502823a8fe441b47b442f5660360dad85014ff214ca42db42bf7fccce84f494769a7dbe6cf0fdd808f0be3130faa7d004f199c2adfe2a12af5ab023933492712092e73b494b397e5d343249d258e4a1fa4a3c75de5771841e61cf952ddc2a7d4bbc099eb4fa6128c416182a19b50c805c58e40d933de2f2c041a0821786bedbe1514a8b859140aa783d28ebe8ebbe04d7f4e1f3a06df718346529617723c57e3671877accdb89fb5e4c6b79bc75e38ff83202b8b4eee9a8dc3970ee97ad872996fa9c694e5975c9377ab0b4709625c213a4f61686025d3d0d43eb4b6138912dee6cf54d34eda53efcb432138ab4a193ea41863248cb87e993655e261a146a6b86697e803d38c8a06cd56e35f808c6d922903fa16fbf7c440b058e9d31a897d95c27a3a9f3c4c3ac9bbf569d9a4383b4c7b854dd0eddf93444dc06a33b4a41c42c5574216f773b0f9e0ad5020db7a6593a7d9bcb5684d507f772fe62414799806a47bc20cce1a83f03c6f145ff846a4c7b05cbc8aeafc53e408ae2d8c09bbd1cb5ed8326137c34117636605cd2f7417e60a3d1a5483e6ed174135a3846d32283500bb5b7f78154faf88020fab85abea14414c59c1eb7f8c07f97fbe2abf814918c2b11a5323f60bac125af12a1544b999140549012e09f82f53628e0406822c26080752a613002bf28efc42f3be417fd883339b89a80c4a6746c564bdeec4e5b11ea8ab120ae8829a387423da88ebff49b0bcb7cde737575c725ff00a71eeebcc2911ed2f5b37b2128dc46334a4de61cf8a3ea38575d41576d29add9bec36c8e2991002c8861b05762009d6a2dd0f80eb4be5fcad378d93173a7576b77b914ca83fbc3e9675bf5dfcdd46b1cce344687775f2aaa2055fbe6798513b04c7352fa0f6cc85392a7112ba14c38287627a8975f59f72ba15f2b1085673504958e2576c44cea5f94cf350363e02bcf21a0151b5ec4b2f26865e9b079e9ea48d744c91c9db02c19075eaabf6bd72d033457f5cdfb9a9c491c9c9ee577696387bc34239e10b4e2b293892f4dd82ec9b4c3aeb692d6e0c4ea6c10572225279ae6e366bfac159a64ed66736647c4ac5745e6266de5a4276777643bebe46a5b95fa96e35ecd26c1bdd789c29c826af81a38ae124c935561d2f20588e62efad1edbcd6a8cff2c0521b6c98c4833cea2275243ef9e881151372c1c841edd89dda18cda773e5872f70a7a24fd6c4c316b580b506b79575e9a2c5b6c54e3ca307baa759a1912ed6e696ee94aa49552c8f1df606d9a177b00a1850c12728d2b15c5265d4c00c0985356620784acd150b8263d19fc6079354a89ae96c0d1c81cf79ea22055d5bde47703db093338ef74c03a0f85c9dcf1766f2a330c9c4de36adf5ad6b743f47a68982b6182aa9607d389ae40b389b49cb13fcca5f3bffee309800c1c2565fb7c5923d5f6e103521754cba74dcf2ea5a8e88c9f1411903585c37ac8761c88bf0c8253f849f57d314381db0d5e889d1b5a25ba36e58e15e1bc0c0c4f24dedeca2cf67cbe9443490fc590693fe05f10ee6531fde676ffb744a154d33e1c556419670304989cfd592f61bf7e7d0a89722bea6c37069aad3e79f936fbaa6d61a31c4ee41d4bb016645a1a2beb4d0500ed09f3e1e9d6ecdf76051001d27d2f684140150279362dbc815ecfd679b5b9938ec78e3072961e1ac06673620bd486c7f5f12b7f19e03c45bf6a38a2e229e217015152acec5e3dfc41e9dbdace1afd46a6bbc914c2877935eed45f9334e14f2c06bfce79ad0c7de0488d27c040821d17a974904c5e69fb79116451296f3664bdae97fa362d1fdfe1468033959d3564f56f89fddf6940353c363222646678b12dbe353b4fad9a43e03e386d9ad9319a30d102337f45dce26c3fa29f43fa73c4cf432bd4f1ca25bf1d29848f8c0a7f2e061d8bd835e145c9b4b9723c70d12334a1bc764b53f66a1c96a2ca6c17c98ef990f20bdc0c04f4ccd5e9bdee0906c9c7a0c3404c799b53f1158d6f893672313adc2fb9ffa37aafb6c75e85c383d0d7138b82be90fca27ef2a0068857eef12892c91a36824b92710b185155ea94aca1e77ddf823dc7e3757f2a950e95d2ed397213d070811281e77333298b553ac67aa11a4497ea88886610b9dcbc9c0355d5a1e30aac9cb2458ad4419ae8befdb827c56844a665601a005db8c4627e45c022c2cfbdd90ee05b64220d7b287483558332ff24402604f740b1038bbf2c7b20c7dae0cf42a6f06cdb5e2da25f9d3dcf3d5dd97b322da8fb6f17aa99c8ed71e11016a49ae4369486d28b7469dbfd0e00449ed6f8e2c1f639c99120f6188bde344cb5f09d1bf19ee97fd942a451434420fa615144d5c9f043292e5ad2f1d95a3df62d21a79fc6236f7d58198f8c932e90f14d90768980f29f36f3099bb0ed0f6da71e8d997ad350fef395816f94077a0a1221fd992186844192795255a5151e99cc52668f8ed4cf7a6049a6065451cfdceaac28d607c5d7adf53d9d95a1afa3b69b30590d11c60a423a0255827df68af6efe33eb86f6b788c0d75f755ac174845c2cf2e2d52de33ac5af7e9d7ef41bd4ac9c2931a8ad23bf479166a122074be6653e854fe2f59472d887c8b657c42871032408a9d7ec2b0e330c64ed90997555f841414994930c16d651d8fa60fc6d55b2b92b307bc32cb4d79efff0d29a758db902e195e27f8d07c2d16b479caf7c3f2ebbc27486338d59d1403b6d5e1f8cdbeddfc303a22e797d648e55b34dfdf84aa7ecbe0aa6ffeccea97a52514c3a5ba4e746bfdb10ef9960c6065696d0da0c34f46302073c1924863bb43b2d61ffa1ee5bc8d388c4dc426b72ec6a2e6876b291d72ecd6357fcb3d087c37680670cac1d4289282e1392ca014b813b17677054ccad8e5f8d62a25ea3dd8513d0ed1180169d4a292ff38ccfa89d5293f5fb827ae5e6023936e39a8e6f28e6aa75addb0b8fc27b8dec62722b8c9c30919a4d84698b0f457ae565113d30f793be3059b02ab8da1ac804e73b571f5f71b3ef669a97c7f3f332f6d04e6f066b819b5b00234448a5007b88afa33cca32533756f250123157d462c70d0c306e8fe010ae45f6ea4d0b537d1a883ce47994516bb96c8d3ebba82681990f7cb5ec5fd4907a6537f0abe1a083952d7c15660da574ad80dd0e954922b09433116beab60a17fb0ace6a75648026c8e2aea8f840be7609d94f3eb83e8f76aceef660dba208f5e10741d8f201abe79940c36b8339290db04aab784f374e4e028fc9d5633a32ed9c81cbddf98ae17c47daf3b95d7fa02beb2adeff4a45505dc605b531c270a2e9606f3927c19b3466acf7af44aef90e0501d1bffe29169933c38092699bf36168cbfc0ca0cee02f31e3fda4b7b68de049af891cbec05b1dd5e1c731067d9b0705abab8eb0528a0c094540b2509216bba91490908646c885b2dc3bd239f4899cacc7fd4b3f4a121cfd34ff0cb69c72f3d3073c964523dff412a178c1b917172d5d675eb869183a9183ddf4239f5e07df285f17f820c2cf314f97b3c0ec9e7aa8b656cefcac60d21c6adb794c003b6db71bb539d1584e4402bcdb92eea706e17a0766bedcad3ac313e4c2c9cc09277023e918ae9196a8b632e1518a09aca0c74828e7ee145d355791b4dd3f5820643ab8369d2cdf58dde8cc99dff0a209a0a5d63a1f6a5b7493e30a8fa9bdfc4e61a1727e67bd91793df7e829b323a8b0ca9b50b902a42435a618aa7c3ebc3d772fc487b21e8ee77a5d09976dd8ad78fac72f216735dc366925ce94726675af57e2d3e900fe4408957c5f261c22d83c4397ad4749d0f06898c9bb30656a17779a5e8f9f6f9fd3cc805c12f97aebae2df81fee260edb47b13138a00b7d42f9f75f9091b1e85c96e9de2f3a626fdd02d34ec9bd95a7034ad9da5bb8f84e7038160a261baae3bb1e42ad90d82dd81c5ccf5dfee1c675818a55699c9b4c838137168bc52001f8e76389bfb29146fddd106f493ab30e5d9939402fd99bfd2b5179a174c20599377c93ce7b2b12f74d808d4259468ef6267af59738e9ab8a235b1f7e260c2d5dec9c25fd60880d59f294a3e87cc0f45ad5bac46d5e153d4db3e76c4dc58c0c23dce34c436f38c73fabfeef0e1a919b84876b0bbccb30ddb66c325da023e738074f15c8c6cfb42092ff2855f9af56f50a3f5f190093fe3a46982fa18df5b6292339910e6ed6d76fb20b16884bcc5801a4edcc8b676da55678255936aa88baec2902bd130b44cee620b446cf90b023fba39c6e806b6070ee5be305cb1bccdf67259f941a365a2627ff85c03dd5f17d0dc5d1e6276b8c5c70b5ca9aea4e7d88d0a7a7a044194fa5267b31e777dfb8d635426d3f66ab619126153a68f0eca66a6370de540a604e247f9584ddb5c562f58100bd79dc777a69e6e7bf94b2de893d2d234467377365037c4f6f505b96689b647a3614120b2c54df32e05b2e8214b2dee4f90d317ab04f0cc5d9730faa2ec0bdd7857b3304605127f22b9d36d5a9447330d1eb8882263c6ce4c7094914a54817578fecf0769e20ed7c7dbc89b6a7fb08624a8c02ba31ab4a616248f7d8383394453d6199b85288a67897d0151f7b9032a6a25229b1039d526e4530bf6a2d5e549d70ec05c7826c1db48bd575d74ca46cf74c6038bb729a5624839545fc19de7e4055771322c84048d0709f7adfc4865cea58f5f20d478ad8bb2c9297c049851814b216195d4eec6394a0bb180ae45c7261f8cd3da8e8789db0be66277299e48b399fc5837fbc311535a8c17f7a059b2746ce9543999e52eef836100abb4c4feae0ef3be817f242acbcaa08d905ecf18ffa917937662c073dc9040c12b99ff4782e3eabf143cbb50aeb55ddb692ad6f4839b49f981e0ee18456d58014f5a13876b6adf775cb9c8d4e46ccfaf43dfb7bf93322c6dfb0bd251229796cd97fc007911cc2149092a08cd114b4de90050b5e188267c8d85d3d8477993ef741521279ee06735244ad20970ac831bb7af844aa78cd2806c4f1e3fa8c6e55143a30b2df334445c55548401ef4fb6fb0f5262f44f835110f8b7ef2868b5a79ec11097a2e1fc2116cb27ed463f6289baa918ab2ca7a929655997883c76abef297c16da13ba6ea2586ef5171a1c300ace0a677e6ade9625e892778f9943c597aeffd107d1270d985f1412032902d28828775ca15778bf5926c005b73686caafca3df6e0ccdec73537a60114d9e8bac08ec6ca17e2dab12f7dfebcd18eba4d0d5e558c6cecb4c0dd61dcf5bf06a992fba58d6b260a66cc89c4363f9fb0309d434883387d401e1c41a61c0ad2ea214e94674cb460be2604b8418c95b74969a9ffa7de3fe3e8141a2992e651e9e65e939ae1a8d48018e16a2cc55a0cff853a0ce6ba5abe4e14f06ec8e092eda971dc044e9b15a54833c68d61c5fd825b1a949ff19a8e0578b6247ea0fa61a017477ab081cf95fa4a905f2b1785f972a3174db7ec984f3616ffb409851eab620dd0b8b71702553f56aa8bf43e9cc826a65229acdfc2130228dac676e82c0f58beed39480269f7979ea089c12c8fca3f87093bbbb43465f4470e1abd13d1a5d15ca11e4c627ac6ffec6ff1e5de3f148afee7cf6d16eb99b0157f3e71cd7762c71a02ad17dc5f4240a828fd89f04d1152c04448303c93c361c10d8cf4ca263ad51f0efada88763e9bd365855054dd9957811499110e528ee8e2f776db491d73025a2ff001c17030b56793bbbdb305831c310c50207a188fda3b7e46202620311ac3d2023870aebf8489f7a24ad977a1a0079f3b99adf4b8f111a2bc4dcc74cd5247432e923e5b90a605efd2d0db81eb89afa2c2a03adcc60750bcec4a66a99009228b3a67b6992484c99dff9cdd7543c0902bf1b096137280c91a6965bbf84843821d2e16b091a680689086e00238d8a08ef697edcaefe076c6c0d7137c5ef4b8811d0f9a46134012be3c0d0c0a0df86dc5ea1b8ee13597854405157326eae9089dcb907e166b31b0bdf85b6f7de832c1b2acb3d82fad68a0730259577382df23a3dab5b7f4a08b2cc7ca1669204fa8e9b9a07da5f643054a019c33bfafcc11e19fb925bae63f7b1d0b85cfa2f654c62acecd63e35bcf73b5f547a6a214bdae9081ce6d184eb7046b6bca8fade2178fd4475e1affc1adc67750f93befc9d1b8f389406a3be80bd6b6501e2519d0fee9cafe7a5baf037593e7adac595d033a043b3751ff982e69694533bbd4a3641284c176f9de6df7782d87e6c4a792c71f3f097eb0a03dc911e6349254dd749a686dba8a574b69e05b363e5c64df27e056b89e8f9dba7b19a9c59192b52880da256e0c644a458e965a42527f7bd097f9529df920271b6445ab2b0102eac0387ca4419752a12e05ecbbb0fb638b700a07007873b47387e4e0394d0427b1aadacdb2a11e9f2456880b1768670a0604075b376db4fe831e456c4370446db33a551e6c68d17ee7b7c6656503911f4d41aa7d5a815ce3c59f600ccf549e125e99f76b17610934b7310218c27f6338d85646f522aa220ac286eafa157ea8290681e5aca8ef5b7a819d3654bbd894f7d813b0a0efc264b518afba613cb378f35e251b13f1ef18f7dd965628bf039210ebb6662618fa2ef880632c2c65422c2029a2ce859fd82cd92b68131ee819696ba3eb0d1e2e8c5637b5a639e5b7377f7a5b6378091e7a0f3972aba954ca35643458f6577f95f7fd9173959d402ed5ae9fa4ef75ed5edac29c523d4f71daa00d6a62531efdde8b27b9d671bc849436eff7a4aca58ea903eeee26a1522fba1f464f195caaf5473d6ea12fe6246a85ef4f1afdf5d25ed6909a37aee272999b1b1b9c73adc8668d7ee8ce2eff1c22d2bf7aa399e194403884150639841469ffae6d36d78056daf0866498d97fa09e6440aa7aab99f22b57bedcd88f3d02fd6ddf2d09c27c5606ecb786ffb13c96aadfa07824fb430be35987560a29c3940937db55e6af706389fb49d1126b451eea093061db752e1c3e53fc36bb568ea02cc3e6f054905b55878b2bc0ff8732db65186ecb08d9ae3ee2806fcefef3616b27ae16ce7f4ed145d672979e2645b17f9fd8a8c2d14f93ab604753e79cc1f20c8d6d1feed33dfe35533d4f35dabcb076dd2005dfc484869bb603c1e2d908a8cb71dcc031698fe3d315db52bf2d06fb959319e596a1c0e5b695e24f6f924cec91c2cb47052db17e7063b79c6344a9acf3b5284795f3fb6c654cc63633bcfe87451dbc514b1e9a9cf5c135997c705b5e9bb66cbc0c8bb1fdf0e4e3567bda90bc7dd415f5e0e0412f9f86efef5c6f7a92d7ef26147689112ab5edb33f915e31d5765c1aa72c77d388dd2ec57984bb309103dbe288e5da754a76b81a16d3e22547fa62bdae76740e78240d5943f7c5cad5c19ecba1938872d33fc5e45b8de32a434d58dba6768e4c4f1e0c3f519c79ba495a80f788a13168f56bcb8ef9658c8cfa31916c05f4be6fe6f07aea7152d9e8414ef758dfa71315a1d2f895eb281e076bdba6849eca5b31cfc274f7321ea1e6a3bef7c726714406859d8423fcbf224c2cb1006cc74c312d1a2f2b5f615dc7b7f11bfe37342fa02024e4267b495db5ffaa5d013b9f11b5ac7f66ec1581de1178748bd8aa421f0e90d0e0650f072cbd2f5897852f8214a88ffc8e360f7d27278121f6335b93e92feb8ba82c452936fea545b7ac4bc894af967ecc018140d0de8b0303be92db5a7ad9e2e046455cd628df46cd9e2b9fd689ee37766ce90781eb94e2db690ea967356c14dbb76bdd8ff5c78055c7f121ba848f1c5f3afba0c44e063c4066d47fb028d18bd389c7c1d5df4c2ddfd4f89b55598a2d24059af53732e2ac7984f08d11215cb22ce0313baaa71ce562382dd0356ccc5c8a05bb2ed581175b7d4407cdc2122a0feea5d1f404d4a8ce269d7d5ced788dee1aab6c8ecd0d3337c83ddee4bf135c86637d27f01621171218234f1c9be685f6e88fab5866739541a39f2cc1b5cadd4f83903910899609513951f78a4593a997ed670d2e559dcdd0583c27882fadec516446d8917bf7c7956b1766bc827de9e807d661fc2d84bc52e587d9aee45b086ebccd5ea2efe889b0e26b41512967b27d753c6c57fd349ae323b76859ccc27a88e23ed01a1e7125bf203ff9abe1fcc5532d0abd991a60b9b225c4013e6ba6d9cb51aee87dc38072c550fd79d6b2f6de369e48d2361c819fd756ac8acba04f607b8539606c5955f159d9f478e40b3f6a91d1385e68b9d11c8141e14a37b0f52f4ac67002906989b1c830f34c435aaeff5983923325dd423377a3456592030a56beff4de485704ac6787eee310c6767f4340a5897b1ed302b517a90173c1858dc2959e8350f55391ca9bc322fc91b6a91f6049d2c189d81d76d5ea851edfeadb68c44b3341bf7ea5d4db43f4223bde74d91af93863232f722b46d7492fbacbae706bca05ba3f348b2598b15c962b161e7948af97bd77ae5914da592b9aea3d0a28a8ee5122c7523b474127292660cf959cd53a7958b5c9ac424dea51679b696db0737612ca5c02aa38f3a970f7323a0527af84fae302c7ffc57ccd2b571620507524d0b3519e31596edcce5b1b72bffff2ca79c61c446e43370d01553f7d4cf543ce582fc49b27fabe430244a5160317ad74940c7b544172036adb1d1f2e9cd864f60049f42f5cd9f8dda976fce28efb93818aa59cad67b2d06c3d07cb3b474ec45a9ceb6a854a319a5a81bb0cdc7518c142ea06ea7929d48950187822f723fdae9f35695b5a505e22b8937e0b418348971e43a5275816f2d971d6267bf20c8871011afcfc69c2582ff4a1f508e6e696ac2d2069acb05de6696502cdb850a6043f97ae9f5a554361c0ac98556fbfd74a1a9fa95ece38372260c4bc5188f568ebef2afc41de2f5e9b0e4c5729cde05995c7579df577525d8643b9321f3a00f8940e20ca235c61913c9bc1396b92292ab0dd7622414c99b42dab5322a2e9bab71d4447cfa180b479ceaa2175399707754c170627fbb78d7e3563ba242ebce32b24518239d70bd61a8bb0e99854ad1d674b1cc24ddaba47fa43d73c16dc1188fab6327518bbc9f28de12079ea241d69b49b66f2a4ed663ef8135d25dd82499656bf3e8eb7029e51672b6e677820cbc7bc3dfbe7f726f9c70891064824d151d0fb417a40d045029b071f5f532cc10d56f5fa1403da1aab0fbc3095448c9a293fd0669a71c0c880b39421364d928037036a4fe625e602a8d6a00769fee4c8c15655471de94971cef20404ea377ddbcdabc4615133b454fe956106efd7b5bf71bfe268bd170d9d3db56670357698c2b62f498123095dd37c8fb67135df9d1bba7896b1e5700fb248cf5272eb78c942de65c9f08f5b5f4f8ce1f4817285ae7eab6a8de8cb1e52ce1a0a35767eb69b6dbd5919c4ef6272366e4c961a5b98bd785058b442dc142b71b68038586080361e07a15ebad7066150869fecfb567f701aee7d9e922692574985810f1f9505983ec122ab4615683b2639355f442c4376d40ceb907ced954870965d363bd89cfb5528e38d6ceb7b865cf229daf625048a1fe3c00ec1c6df9a035d100023fad44171357dafc716c013953377fd61629dd48e2133f10960ed66586a2d15d843811faae9bcf8dc41645bef43e2ae212d128746a7dcdbf09d34963060c8e6b393e67593a60a87eacca406048b46a5c2fdfacaa5e613c4be0034558d83461fa84dc581588605c88d8c7789b9066c9ea8270732e8ae0258045bb03efcb4157a648ebd63caa8f2325752746a4bbea99cf54cf5352fd6e9c242fe762f6c09e8b8a4be0de382062d91f9120f713d4a75197498833f575d64f0e04c37c28583b5b6b25743ad0f456593290f8d0110b8966e20440ecb19ff60566b55e518f1fac72d105a7a3fcfa0914d7aff6b687c43053edccb0f69ba3abb3a121d7a92012713d6a123964d47e9b10a17b07c59165557e40429845a133fd60cb22a8658fddb78586ede47529ad7c2446cfcc9829522fcad6023ad13921a60cface06783c43d8163978736f6ed539001b01356cdf9082c667761d73899354b593775c2e8f1a0a00409abccac4327d1ac87bf070f99f9cb4c84222fb29cae2b3bca38ae5895f2dbd7fd3ee046b05fd44e3018a8e91b32cb8d30e424947efbb90b8a2875248d164e5b4d577b20ace5dfa66f06d26769cb09deb831e140d96173cc78c995f2c15ee8d81e041e3e74252b37f468b319072536300328d721675e2c931ac75b6341b937c42e2ed69f1f5ef6380a1f26cb2586d7ced0536c4cfffca5ac826dd9e8b90b5a7e20948d834e548f6844cb2ad80175dc268d925a17b46638f49369aa7921b24d3fa9ca96e130b7d3470b1bdfacedf998fb8bb45291dc6b53630b8b8655d464c2cb70dc9b38b9474198594a2f689c3c046d31981711623d8e29e6a2da20e02724df53ee235050e130cd8902bd020278a2558b017de1790dd94199d978240dc420b6d923dad60cdba09b7d2b11403fd290e7d76aa8d6b18b3bc5ea187c181be7ba65cffbd0304645d597070faf4b8109bdbbbe438febbaee0a7d1fd8f0b5be488f475da782686030f9be3a2625be728d28b9002654b53a1680a7e43b017dd17c07f019501d15ea20bdcff7cfb078a44201eef5072634e3142c83ebe9b897ca9a822949bf67e72ac57b3976dc62c1e689d63b9f37a79c29ffec888c6763a44acfaf0096256b161bea2be0dff79005c1f2eee2f0b80cafffbc15cc58149475cec115ef88c3ce13818e2cbc1b17f39147bde8f5165d26adcc1d5846e41d469464b162f416f158bd58fc9703f60fc0cdef4fc92a588db221cc8d92e9eaa506a7ebc88fc374cb6ba5b8bcc7b7514eb9a0f25a4d93d413a94676d72d9ad97d3cb34149468b88f83ab14e0134a91368c9e29287952a19158a51bfd322763bddfb9721dfd1a1884ac131948ef51b27776c0d25fd9abd3a33d0025b57ac7d44ee0d8c35807f2897f6c3265686f806baf36e57e6f55dd849d609ac604ea0471440dd9fddf9f9d1c955ce5033ccab582ab08e62b7c5e88066b306458b5e69bbef60f018b323af742b633b457144d5e6a1950177bf7ba3135a29f3272ee932e8a4fd4c28ad2a49f9e5a4090d9f1515cfad8cc6e8446b2a20408985dbe3d27c6f50edfdc5ef9b3d172cb0b6b5ba4db1c6a96b8a7c398da23a59ad17dbb08edeb47be3e207f6d9ea1c1c7c865b3db3aaf9139f95e3c806e1ba859b6aadfdff37907d5183cea868ea85beccb61395633a7db1f037f3065d697081b42ef6548c0667926a6ea540f8293c05f5d316587beb1756ef250b94b99d45e4c5000c7c35eb66d0c52b9d639cdc47bfd1731cf983ddc3ac56435fc061b7daaed6fdd0ab90b9a53e0492fe02182b5d8bc2735d27c882d98f09cb257ac7b25494a3b824ccd833ef18d939ce7c087d15750d747e143fc27d22286328741ce8987f924ef82f33ba1676ed48467728ff73c1ca209726159d26752f1c21932323ef65470c7f4ef068197e62f92f2cb7dc2c22974ce0182f95ad35198efdb3da7fc4e484f5e253313556f3df77f71533d53753f49a025335bdbb61ef02b6afdd4962f8bc518824920991a52790410962ca84a64d1a6496447bac29fb47a433f2867f481bb8be1c39d30774c1280c580415cc17f43b60433c67ff501ef58fea87bc0508886ceacbb362942b79e125882ccb4e09df47dca3caf462f24923edc068595cb2d52d6f6272d3be39d6566d3b43dca4f2c3413989f39976dbd08ae012296ce7ba1f7c3e8882737b51974951ad2467d5f91f18d182b8f4acded57f1a1b9a56c83510de1dd55317c63a4b8831725d4227c899447a5966c0a50f3ad231c958e227725f6def6ebef3744cd9cc022a6368cca8eb67e0e3fc54f3149a2b9460943705da29e59450b10d31752dc98156d3cdb4c1858232d8cebc80f6a2a5cede729bbe5ae88dcb3f9f28a34659d9514082c24d413091a27a6b652e04612945a8da60d53168ad85e56384995cd01f530763e565c30609252753ae66e7f36b18d3fee6b42fc9bca4b056db363be1414df655a20060181e1bccbddca61460633efc9098d5528014fbb042764f1d92058ab5bce0cbbf3056fc3cc5c2130b90d584ff451911d637f6736a5218ce4cf1f222dfd6d2166dca25d63d75b361cdf2dde93b3009d68aa1e7688c42dc803cbaf4639a2595add056946e134ca5072fe3c4e4377e516b7176b70066df2120f49a29bbe988833692880bd6e0147402ff291c87d00a813d274023abe8bbee6dfc9b224cfde55b598489b25d19f951760d14abe4bc1aaf7d344ed361a42a0d63f3d2985b62259c0ba5f136923b5c9dda11f795768ec19d9ef122b90044a0c9bca7f0df11ce977d32265759e4a2a649c36dc4c904960097056e84e59aee52ff419e23cdfdc662ebe2a1a7c2e7a382658d7c931a8d4f596d0af8491bc8a2e3c3c64ef7b95aa88214c4abe365e3c5ffb76fff5d26016370111bda04d31cf8cb5b2bb6209c6f56a18ee741a9f10ec07003b1d67b6afaf7e3353d848c83465137cc52e56ad7493e27572748564f1f5690c73cfe7958199f767f9ae821aedafb8e76d806c194d0476e6bf7c7d98f73a5123c35930098678905ebfb9a7a047516736b01c93a5708e10b6a745efd1f1d0012cc845165f1ce51dd6f7073d9c31a826805c11c839255186dd6326bb7bc6f23262aa514e29e51b50fae7c9e0c2b3175a5ee97fa8ae31c8eba6aa0cca3761f214bc31b0c9f0d5b0ce0e78ec3e536aa632960bf7102c5b6020faf9ee82c53747743014193afaa8a79accd9088def45a9d88cf78ca07dd0bc7cb3ec1bc1520d96d65c9332c85b4a1fa3e7e56db14688599e300664bb0f1364a6bb723914b4e0aabe3684e5a6a13ef86e75ba1eb1dd99ab2701d4af9a1ca7ddb4de1a341a13e7e347077812dca556274f60751741e38ce5dfaa8cc65fd034e3e3913807bb3c6ce256a9643f069c352c9f6fb35711a2e7fb13821e9a5080901c841a05ccd161f12ef35d79a12ff587b205375600ef42c69e4de3ef67b05582e992b0d33cba5d854823f7e9a252bcd29c11315eebf49a9c297e08f60c6e508ba2f9b9a3a53512cd6010a65980db5b4245981584b7daa497089df88f262f91c90406c6ace4384713e65e372314123177f0208a2b60edf063a72489ef6cf40c9a211e28379462de05fbd6196a9cf3f64f008c106f277404c9e6b29d2982166b9b3a73b86e2a986d79d28475b2de3530d050e30f244cc1c68b4e2b7b5aaad0d2dbdba0a38bb4ba98769e9032a1915715e3de292877323f7acdf02a151dd01c437c2b8564ae2a29a43ea19144ac8699605672a39a3b5d64f572a1bc3fff9219e5738396d6841e5fa8a34802ca4642f5c1954b905f702152f682c7c7b4343aa4f9905ef44c6c1cc133b978c5ff42baf4632333b8250c7e0c81ee0c757b0e0bf2a5d7a798fcebff2de6c864be27ee33d962979185f95b197c3004188504062f98002423c6a5dbfe8e1a457723e6f0864906aa99ba18b76a90e8e12616793c81fa3bd2a7560b6e2c6d617ad7b0a70dadb9aeb1239cfb5f21f361d60832591ec430ec08b17ce9169d29097ba1778f3b24655764d7aab030c8318bb6d30a5b5fc5cd93e49c78b8eb32aa94d818387a869cf0b40cdf580dbb172ffd58e5b0d7dbe35c1e03e96fd66e634c5251361fbb039fa8868c77ec374fe4cb78a6fe53f765f27ea7583825210ece00140c103595e76554f85472d940f8972d75fa77bdb78ed156bdaac3880d0ce9c36f01949b4113b482e081f0edbda7f7c85728c1980c85fd329a875d4cf1d1c750dd564f6c0a0a005cd86c3bc293dc8ea8811f2e90dab54197b0ede8e959e91379ae05ebf5db270297ec3d83733b434b91ee63ecd3b0dbd37cec857f759df460e33db9866088c4c71615680d615b4ab3b5f0b506d17fa01a4e4d905948414a080cc4f9202d2b700b3cb1f7874357c863394dc6ffac39f25b355417f9345453c447788b6116f2d515d8d18608a0cce7fecc54fa27dc7bd7a94ed818abad3d637550e8715b3b251f728feab8dfc9883bfcda19ed35d3466f7a7c183bc903de132e3db23a1069ca8faa451e4d46b54f6749330217a88deec90e6731404a42e7b3834d0602aafcb15923253769afe20c7290430c4450371effc32941191bc2428df7c10e6045da1c2bf5690ba05ed1e7e97fee5952d78b271f87611a6a647f52ffe1e1bcbf92189e56eddaf89e2fc0055c73f62629fd6c248377dbd6fd6c0a8fdff35940ddfc219848b87dfa764b544872693a4bcf17e319cbd63d32d8bdb9e450beaada4948bc4fc58b34687e0a6f95f0d1b070854060d6e6f2d0828a2168830c076e482e638a6ed929e7197ef0066fc4a13a658c1e53a936abf72dd4b1bc3da6f5448180a0109e30f10424657bf57b568d68bb190bc83aab076b57291b6e30a3270e686a15e55a1bcc9753ad1efa02b8c33fbe9b71f5ae5691ae9effa5c89184dabe0a399bde5d3327ff6c4861bd434308f57606b2f6ea3bc747aae56371e1e16027fb1ba1c6619f8ab2cf3bff38b74eef01da0b6f3dbd4860d118817b7eb166410a7483a1a5edb620999c13c55ec8a003f6b3e21b32ffa07cffdbc3ff5e8b66a881803a6747e1e3c1f47289228be82f22a0024c9e1328d70981222216a2d61287ea81cfd5a636bd5e71e122567eac7a78c8df94128f20227d1d38f381b2a2c8d7acfe216a73a5300017b29501fdb17373cc95a84b9f6c8fa5ed1ea3a6cd9924573ca85cb3ee5e5edaf181882475db719d67cfae0fd6870fc73695027c4b5d3574d84b0fa8a3ee9725d2152e8e9c66334674432ad63474adca65693072e7110cab152857994b4bfa2deea2c0a0757939c6d948e18ff5836603dde568bc4d62bb6f928b5ef1c24b76354ffecbf152dc0bdde83b6e2a153ee7e7fdce39cbc4e0d533d61713a5ab6d964347f28fbd1d11c639ea66a7c10482aa44b4dc426987b97f2a74ae2a2f95280226960f1f80469535fd09f1414299f6ae6cae95c7dd8e86b6e7220a33155f2d2dec56adb2e500b915c9ba87c585c442eb062e59abcb136f1f3a6e25c9d9265e8c0b4902f2186f2367fcd5fba1b1827fd3dbb7e971b0f09fe7806bb708641cf4168d7b92c51a99c58cb1ba23d1455becf85eef9ed51017adcee9a0faf4a9aa8d82d9d7addbc6d6b956ecfe100d51b42460922d94d93719edfa9ebd5f54416acba3be756895d9111f25efa298191145c29c58b123f5c6ac2fbe1b6b456a34f6a7e8073890ac0be1c63ec0a81c1957c0c041c3d698a229e285a47a7db10db16db441573e5393a53a6dbdc1c05d4a9accaac25f7a525776eb6be2daa8b9a48ceae49a3462d2e75333aa85430ec38e7376c2bfa60a38bcca218030033866607e38bd4b5eac047590b7bd16dade9d6fd4fbe512f249b11a4b02d65476fcf09f4d3a87c1fcc49f8d61812acb7940e4bb8b26746259c92c3fb3c0e8e9f511565f5b58c73622ef60849d9e1d0a39998b423e600df8cfe2926258ac0f0d3263db04cdf71c69c348832942c8b4acbc8b3bf35a1519b72ad8dff6b36d547d258b341949ca7140bf163251bcac100682860f8eaf9ba8834e9be5908c236735bec8432d37bec4f8df3e3ce173a41bea100c51d55c307f2baf7dbf61d245b05cfcafe48d64f8b0cc73c2c6025924e4f8c4ecb87ea5a73d75f35e30fd990ea6e8c7b7b30c535d915abded75520d793373eea6602d179772a7c380588098f58bad2f160ed1aa7f52edc32ec4a0362dfc7de407026dfb56b48e22277d2562e8fc1cb4e79b658e6c7f1c8def584bbf96fe350c902c0cded182be56eab99fa41c5075563d3d28c31dddc95afdc84b6816a2ebe1aa37e3de7687f8e4715615237bfaa8b359f5ba8a287d537a83008ef53a95df941012487b5ef1050b16366b1d08c58ec3fc8f5dd229a9125f924ec04b8c16e0b0ed15abb8cec6f37e38904d01297d2b9979812ba1f1e011302c977bf1ebbcaa880545bc5cc26ebbf96b911e3e2bdc7e26d45c0db5a5004f70e1ae3faccae9c0243121b57cc0e4c0e57348aa634ad5edcc6fb971d1860e9fa00682e3e1dfe89b0218743d242ed7a1526e27d19186840ad01710b855d2ac50b63675a33c41483b6c19b33b353ba73a75fc2ac1811eb3bf8e7e47e8188dda40c4de2e4d36bb0e5568d8c74a51b995b9d0f90811fb03bcf611725aa4d4a943e6f74f80afcf4a61319965c8cdd4b1b4c0fce88cfdcae0ef47dbbb0759e040d7abeec5778e7afccb3e79dcf7ab66ec7032f3b2311fbc087ba3534274d1a6730c31b21aa4968cc47c71e106c5bdc3ff79ad736e0210efcb0a383cde3aa351f24024617bd44e0fd654e8e7915802e68677300c6109efb98e32f5cca257f57b5976bdf43397de82f65908e7464570b8a8ab23c203c7c4b7f12741f386dfe5bd1c2323b7a98fa8d82605b1d1f29795670e17e4b878a3e5d5a0b6397ba60df5ddee74ca11d2536121ad205af31703be56e28928d6edd8f56a70668d001e1fe5f6f709d382049366dd95da6e20a6445d2ed96f36dc8b3786422dc80d0c313d7a826ecbe16b1d4dd1433d466f6467f85643cd2f7284e66d8ef2d3a3049f5e05a51bf2b7e5f42fbf95a2d87de5de6103b650aea97d130b0ffa22abc5eb6d51fe7901f773dce6f1912610b70c245479ea58d489f6436869cb1ce6fb212859926304f45d7715968c954c291721a425c315921bf663c16bacc9b96728e354f9c7acd3c7f94f418217f678bd78629ed610adc3d6f0fe1c4098eb8021bc6372ac45e7a51f3bf817f3a9a0b23a2fde08cd8ae930fde3fefd61c73acf767fd0a79775ad29bc0c08a60314e1a5bbcc837457a292c30aa8364e74ac69ffd284a3ddcb4358560a76d8e06ebc9b9dcb0aef57ee1014f90ea00db4d3abbf2cdb9ab083ccf108b39482e6d4fda19f2e6d448f37350688b6c2a3b356c54dcccfa5906f71cf13f82922c2a95477101c0abc900e3bfb907edc13d925233d11f9a00c52951d4f137202ef4f34580ed935acd0dc2272ffec66e3cab49c93a0a9c3259ca306e95858bb1441a8609d32f126e4239297bae8231624c211837813892967fa1a940bc77f2af0ea1d41f008dc5f4f7293c7626eb346f6335de2a51e9202d9a33588d57ae8749f4f58f4ca44b7236836a254c01c4b1092c29d884a60e0ed0875b134fd8285d77ca16ac60421fd2f5953413c1d1736db92a88cecda89c4054021fae18eb07df6f731b0b493c220001511e83e5ab1e093aafc7bd41514341504af6fa7be43176891fc521ebe99ad33f181c48129ba1a96390f43750b89dc77355711f1bfceae1e149825a3c984e44276a35502b1280005c00a539ecce1e30087e0cc4189205e665d90b8d0211a2e4a9167385d1076deeff4b047e76cfe34ed60f693a6bbccae36b31dedc3f66fcca26f770e85045ff97d7061763b63d2ecb6d3ae086df3511c6900749a6c86665f27df36076434a05f1ce31e5926b3d6d104a9b1d3fb29cfe2cf930b318db70a28fd74350706ed4d00246c3914d13d4d5b290341aa3441a4a6bac1c42ce33e9a872475f3071acaa4c870918e52efe136791266178e154762d61399f866fceec520674e36890c271807074ba2daf298fae760ec9172b2802cd3da16d591acc1b76a9c8d8892dc96a828945f5cf529b33b565e73842f5d02aeb93e3c1e35300d7613fa4a0ee14dacfaaa0d3ddfe326c64f8a08cdfabe4f5c317713455322f2ff165dd94f2573d711a90b0598a06665c85a3375e7913abed644748a9c82f51e808e8f657414352382427051e8f18c0da455420b907f356295796f00e209ef58499a01a43d8038d6f1517a6c3dd67cc9500988b3d1ec18dd612f8e6c7539cfb018f0c4dc596d65395af0128b5050baf4f06e846e7dd1219edbc17b2f2e02c5dd028c6ec5eeb77a77814057939033837aee6c692997e7eca8b9b061d589786aa1c0e75cf08a17902ac2c4913570a078a0229d0b1bd1cf122e22e93722340909f2f60443a35620265a8df683807a95209172327231af7d74d2268683a732441a914085b46857d64af4bad97e9aa56124610692002b5d8dab803ce224903e5f772d795120caab179796c43f09d347e75022c1d0f7151197fffc7c096786a847c20b5cedb2c535c6d3356d26c8c41da3b9759cf743819359f5b7d4834a91c538125651c623c679e89b4cae8cbeab270f8821724c09ac1b4aea30a0f4416b921450db44880a2e605df30b89a3012cafb785d029df39d86bd60e5a64375dd58848013aaad27f435f4ebcd85841cb5fa70f1e3e0b41a7444c8a8ad03e8b0443bedf6da800dc7eadb533a2218a38eed32ac073dc50edbbffad9b7dc83326119289bb6ced8d51f49a35ae9eb89239e40e96985e3b5b183733df94257abc83f3579f0bb66ef2b7ecb090e39f5b95680cd58ca81f6b42d1acf931319883e82f54ebf51ce3212aedcc8fa1606ae97c16858a11fdc51ad240876eb9d5f068d6d3564669ba61f73900792825c5da2829fbab9e2a5e834e23caf6c1a9d82387a5727b8e50a5aaaa42f28997a423f6a4b1d424b1a47f5ace52bbf334e3d45d8c871a1e121322a4fc04d8a20b75f9dda8f288dae50b903d2faacccd7401143937ca5b66b6457609ff44abbceaf33d9c1aeafb32f451e369c50221b0d649ad3ee73c3cffab28c1297c8a4eeb22803c74d7bdd4fee3a6a597ed4cf0799048d69c791c462eef8f2dc725ffb15a27140bec446a9524e4b35c8b665e8855d0e4382bc4122800f3e174aaf9eda90e429d1b304e286cd54acb86722625037197a383fa4f038172edd2e93ac333e00f9bf4ee1c3741beb4e40f7a77524dd1ef8808fd3ec94b146d186afd45152ee4e0a94489b940ef2dcc8e4823792735384c976151e03c7898fd468b1579da9a18328d016b7f63a147b139f95325ac458e2991a22510b579209663ea87d7b6a8967e43a500abd4e87382b53824c24ce66e3a46d0d6702628cdd3c0cefc9890390cd6ccd7b70e6793255efc45cbc22d136c1487c373086c0604427ad05525ee521a4b4a478acea0198ec536d1f5636c4be43cbc6cda501abfdca3c9312145dba97770a0dfc1b327481b9d21c326d1fc98189ad522ab5b98aa1800ea8f226cca2ce98ab38e84f872b6c1fb840edc99f06289dbab43144355ce806606ce521c65e87ddcecc2a1385f37af10c93f6167826e11e52151389c6e1b6f603c22e968b58e3c9ff1b3acc7df32feb8dc2c4f4031405b6fbcafdea27e6e0b6e7738a050226c955b69114309d5bb4d3aaa20656e78d36612ae93d4eb0154dbe59a50e7bb1ad1c1e8531aa23380abd8a9764ddbc25b62420f95768576497362a5bb1232a89873f47e83fb331f9cd3247438cb1af74e5cf72a9d0d02cb9c698c3373a25dc5a6865d8507bb4edd2fe52f80e5541e8584d9f7eb8e1b8f6c709065493e995cb00eca1bf949358d5a988f3aa45cb9f398bd698719c22f8ee82398fefc645b3aec55a60eacdfe3eeb14a3382effe5df7a322bb7d47ded22703a967cb1998578e74e68e0fc024746fff0b4cf7bff3aab51c3f7353b166994ea8ab236db7d4bc730020ceae6cc939c1577b366b1a76d2caea21e854166819d049522d9f0ea3f74629d506a6b0246f7433bece650b233f3f508941e3ecc0fc9a56438c981573e1ce07e16674f0b08724d511a158b3cdb097ea9e807e4c3a7e56fd85269d28e68478a9beaf6261e2a5e71998a330a12cd1ba9adb1c6c19e265cde7938884d554e51f512ddd88c732232054097bfc7aea06efe087ca9b76ccc314fdcb13981b5a141c624776b1e8e0768e66b7461795b814b5ab669df828ae1b7fce35482b5fcb4a80073a54949f1c67f37a93864b4cbf83fe849738ef4bd701ea17c983147e9dc7c79b3051e5bf98a4631c162cab8d4d939ffb61b33211ce14127413f9c471a14a509871fb7d5b8ef786ac6d12ae723447d01ec768128dbf4aa33c9c5816cd7a29c0d8ec3b858a7bd4ecc26afcb0ad46e931b1b2c4e631a7c9ed1fddac5c4536e75e9729d5a1f85bf8d0aa8be0745d0b9b06ab214a2a406d87d0e89897ca799eb768e7735fe408fc029e5928e6def27107da7d2347cb0c92609911e14acdcd5e862e15ffccc42e91d86830dae214a6b420adb74ad89927a42f04f2ffe784179659c2ce020a6c633a01f4fca5dc174ead1782058d1bb1aa7c42de1bb8a9c53ad8eb1c8f304f53e40cf9f9cf834847cb3e08e652701a4dba946831a452548555564a739b7ece19e77f9d71912e954833f52581054af2cc0651fb389d7acfd88ad024569d91902e27d8554c8b632eff3008bc59ad51db18a9557f03dd463fa416bea4fee3ec7645cb540f6184a78f7569cd50040af1c54c2bf2497723fcbb0696b499e6a9d8d6092476fa9a20a442980399af7c97164b41de67348f1be069bbbd6988489e69d180bd05e35f59059a74e470d91bd2bdb107884ae01351dc725847854a15a9ceca46be42a3a56bc73cd466f5b2648a27211ab504a4e2e5f3216652da7a62c018eae72f87b841ce121d8ebdebe0109ba46794d850bf02ec0fb6f1fdf4b949e2ac571218ca5e4a59b6b78391d58a161419ab5be2c2d740b0d466f674e4618dbbd65ea4ad57a251ed09c1dd48d791ed8b9dadab581a4058ce39b07a60150c7942ad9adb749903bada0e2247bccf9853dff8234347cf59f4f3481510296f650bcd6f2d0f31767b9e77115246fe336e83f0a8c3f658df5594feeb9e47e82671d676ee28d78f1a0161972651f190765f2e14365639b95ac5995015ca248becd874ba9f3725fbb09a22a91e85159aec1e2287023684eab1f1c60a077a1e355bb212d393adeae33b0c08bccfa8afee4d1a9a8b039a84bb18d0c03e4aff172a0470cfef24ce1a3fbf351078e25914796a7f03527335d26418c02307042b2238a82767a1c9bbeeef98b57dd92b7c82d01dad1c060d9496594a3331b5d6aa0446bfae16ddbc4b17f7722157cb1059138d15b4b35ef9ac33d5c138bcc0a297dc42ecfe1d712d3d9e18ed82b505ca2d54787c2b9bf27325b2d1c1419aa6f871ef272ab8fa792cffedca8a8441ff4e01c8467f5a8f121b8d5979bcce0e35a83f58018501e2afb3e932f3751a0b4726cce4af47558ad62ad32440b08f60f5abebd438ade1d0de03bc61a4bc4977a5fc1b8183fd1fce71e5b02c54379826717c830087525e8cfbaa191248194c800b6f7ba103a513ede5d72fbc200028406c9edf3bd35922cb61a6e362d6df925806da129965b0b8b89a831f5b2c330159fa534dd49413a7642f2c2b8aa5968408430980a68c6b4b992f45c54a24db8438bfb8b71110ac5f937ac59fe5c69f4cdf42cc3e13eb1b250edf23cf72eff5186e44b80f7916d2b0380935d54c73f779b4f4dfd0561b1c37fdf225764dfce498d607610eea58580ceed0849511bcb4f6528a4a16687e8cf7f17e2ac8e3cb7d3d3b7877c309a2449366f9c85a840a3f163207c99bdc60bfcf6e03a3a9153e1cc91ebfa8269bac3d4cabcc27be3ad3b1bbf949963123d5cbf84f5bbc33ae9775489e3087a7d97d3777a091e872aaefe6984bf52e8b100df72b226c9ca8076c20d40f74498eae2bdea9f95841708c649fd2a242daf974169894ae097ca27199ccdcfc61cf0fe6762f6a930925fd27103b579382aabe56f01d71d5fde8f81c891129fe298774191363f79bc7eeab091f0f4e337969ca109718ca64ae253a1c699599df2dfac4c5d169613064bab8f147bed303eaea73206a06ea5eb8d0626990c12e3b4d92ee44fd686abd2c8df5d30fbe24336663076d05dec323fbdc7e879d3bf9ead634558beb2ae1df6e7d61d38d50a3ca293022d900e83d39616daac826ee711346fdf67571ec5db69eb00b2e13222b689337926e88cf2bae84b5ed4d054a0b324cc961d25caa35ac8a78c752b56f0ebe67a8ca83f9b18f2d9ff0fa318757cc01eb9e85ab1b58dd925885364e086efb5d5df57d2236fbfbbee6fc5172b220ea1ca882ddf5a043930a716c2650329ae8278dd7e14b1beb3b34bd7c9894cb08f37a05c5e3a6034afebfe8f7070b9dfc273405400fbf719cace72ab31081c7fc897d09653cec793cdd5802c2dc54de1552810ef49b5b7b76406d30b7bb53f5a5dc723b879266ec39da5fa1f6ec01ad3b59f327887e903ef7931e4c3ecd52922dce329241bbdd52544c1cfb8fb0549d4d2810379d0e25c92819c7dd20d4e47b53335617395ab57f3bf68ef8a529a3a27f90fb12d4cd889a6d112fd341a5d24e01a924c4c54a7c5ceaf0f538dd1868f9ac73fa9a5345ffd6cc498bb89847460e0246a63b7d8ed46d4ecf9348ae8dc52b2465cf1ae7caec3d61b5b23fa6e44ff137999b6a14d7742aa96db39951ede65c819b0344b956ac3f9b7370f264a483002314f94ce10432f8fe54774f93f02464f7d5d3515d41a9dadf945f50c85b1e9bacb17f003e0e7ff52b0837cfd4dd094b09195f693c5f80def30f900865796a0c867cb6e1d35ff8cd348416edd236eb000ab56d95bcdd162544eac41cfcad2113a89dd4a798977efba339d286075f8f5b97fee2bb92c71b981ecbef099dfb9fa36b348fbd8eb7df6689e90170287b662a3a6dcbdc8bfdc8395c5bcc71107709d97dc227299833b5939897a64a9b7995d372c42ea5860ca54c7517dda92a244fe841fe885d2113259172adecabec4b3ef3e9294acd5e2133f9af3163799bb25cd829a9da349e30406be51db22ee506f6c5cf54ad4ff7074daefb8e741fb07c841b43acb08970e2e87fae5c7dca0bef6072152c9b1b607b664c84d94a33a736be6a6b8ae30efcc57e780205c6ebe933df9f6017a4a6baf8571dd1b1ca4ccf460b5cfe69332354765d98c9921064239b691f73bce675bb6aee89c26904d313edb680a4ab3ffa9e75662d7333f17f7b09b3e54f04792a29311154966c518945ea146557817316dfff45bd6710ec6af0cfdf81662379ee581f9ae6eeec8e28e74e3e47b8c6630780286444c30d64d4761321070c08c1c2dfe75fd52c8508d037f4cc4ad596dc1ec35848a3280de4462fad86ad68ddf3127a0af8c596ca2bc0ee162a9e661fae912e6250cbbc857d79aed910fd7ef78f1c2b6d8c6f318b9d3c366beeb8f0066fa7d700218b0d79a7a5dfadeeb97a5cdc753aaa801415325d3e7d52782ef5c6b5f820a90e766a0eef4deed72a699ed1d52d2d7fa877c776b4222eda0664d0982c720eb8dd3edf249aa9458bef502153c0b3a6426eaed9619d9a4a97c8bf764bd928f425218f5c9fe8a07c20793a3f556910dedcc98dc071c5f791021b6e28229cb35a65a32e369a10566037337dc16c852505e9062de55400599901c902188af2d4ab197516bb4cca9ed0c59d1b523aa5c6c3419be9e8c8e9027b29f87a6e2f3afd891715175a88811a24ba1b05f5e6699b4726ca6e34f3c25c92f3bb63de65938ff878daf10c292ea804754f18072c7c5e996852fa6c4fd1bfd9540f65a87a0912d5141e05823d5fb3c9bee2cfcbcc3ce617e35bcc226467b15c74e6b402b0eba6bfe36b4b93fe7a6c2ee5d5b3a6b20c9415d005d2bb280356a7e5fb7101afe5b2cab2f2472cad9c6f9cb86a490514c5a20dacdf3c2dbae3f698e508751c21b3ad7d82886dca40b2549942eb4645afcb4baa74e7b70fe4e16543af71e23287f94d9e3e08ae70e53026603b8274444617520221aaaf688e43cb050dc0c1e18b0251db62de0d8e07e9a093497698638c5ee322640a8c9fdfb32d5938ae26dccb39e71a844b567287816cee551f951743f58455993d030ffb6728ed56af893a7a5c553f167755a4c558e63a1477b62e2cb740ee5c1ac519a5428051aa089abaa768c4cf1274d0841bd06c453e7d68951287f96a77db4e382cc0ac9c0505f06a91d1bd2f988876ab374343a2fa7e708753fd5736722dc20059f45e76e384562bb0f7d49577246cf3936a5d09c2b595a29d6023e5a5907183c43c0eb012a2ac8cda6271b4024ea1ed06047adc46aaf608be635ffdb5366f0aeb0f387c8e6d9ba56de759762f2ab2980de531ea479842ff40c8887addea66277e1c632df37173ec1b184dd7d0d655a4d8a3cea131fb969d8ce45ad7f21f2bb566908843fc911bb981b5ff96de32c83f5f1c4abf4e8ff8a05425208694ce22a711ab1d3be82ded4413ffc678bdf61413efcd202cf2bd795eef221a2c71639399b0e4e5e9559584bd7ad1cc2fe611f9166647d25d3f56d15ba9f87b5cd8e594520b88e39506f6963d05fec5c5d325e3661dbbfba6d77b3b375aae529f70a21fd8317620209680ba8503d5eccb1dc13cbe0271b583728f6ff73793056c808b039009338c9b915a6e9eae528912f04b04f7793bdf6d3c177634538b258099a789e7785a0ed203e7cb78e200c4b49e054d18254c425fbd4251e47d8facc4d6598a94eae1138ecbd3c850a7b6c3ee55e1ca72d30dc84d5d32f143c9c0b1ac7c8f13ab6cd3397b7488f761414e1359c342d037df8711b05e117f8a664a6cc7e458b087b3dbb72c1a4603dc370eef81c151e743dbe5e86ec213b491913e31b633525f42ab3d1c57423ec259c22c55d5457653389c530abd3005a1907e21d6e1269b366f5cea9cce7a5bcb258668f2ae8215caca85b0c4b12588257583180eb6a8c281f09e64279a9415f97fd81cea089f97f3b7e0fff41031d7db97550149b478cb6f7a689322cebb48ad92add86e0968f570680989bc6267aadf53fd8f903d3caf60aa82f4c369634d904144431cffa923dfd4a8bccff632374a4fb47afdbb834eaadf500d115cf7f07511e645efd8c00fe853c0f4ec4886160f2601e89d0b1ddc3ca5e62679867e74049f98f0c29ed79b4b0378dd54f3335ab9db43a24d8a47a42f3bea534aa8f67cb8e977966e7a241f69b7852c63e64b522f8849db8081cff4bad83e1f112f526a3db8839517cbc0f43b2bcdf554f83e75427731400a7c158509cc54fa83e998fbf1181ecb6483f0b1c49c6289b703657c1ebb16cecda28b5e7960a09c82670f95969959d4a628573d2155758a59aa2b2496c631d63cbf37c62219bc4738c98560c7069ed5c6ad6a074eb75abb5cfbde9fb5e4e1298ba3190bfb295330f074af2936c5955da988dfb0e6b668ce9a62454d650a8b629f81c699412aa59de5b5bddc8aa45391a322d517da81abb4eead3fb22b93abda96305ed0d7f141067dc14ec03b394343023c5b23dd221afade97ac5cc00f05f0625cdf63ce251b044dfaa879bfc04398c603ec9bf902da6822455029859b6f00aa622920624b0c540b61124fb27f68f2977d2859cef0bba4ed2dc5c9a5986460842e94696f75e7e9bd0dacd173b6ffd858a0128dbe82ea98d6feb8c4aecf0afef821db41aa18601e2c25135c44e88d45622b596e7691d29251a4588e3960b4cdb102eedb00da871435b4943b3fb3211c72f46bbcad940eec04adbdedcbfb0467a4e872674f6aa80a24fc380f0de22c141b1e75c53cdd77f8d2f0a8b72551c22fc0fbc6feb6391603d5562c9c5b24665a425af9337b3f186bc84eec5961cb850ae7f0f0d82bda387138eb358587ebc6912a9619b27229eb46204b5d4d1fb6876c4adfbfd120861cd1e0dff425bc5be4219e0ae7111832115d12f4473c0b4cf1581a1e093bc6545b1f8e4744550801084eff32c287e23ecfe10102d81a9df4dde2b251082b8f5aa55cd3dbe139f5424e13b36267790c26f59aec678d6235532bb64c91c316d6409bef0847d5d2ac32be46c7786513f6b965f933fa6c4a58b07a1eaa98f5e99f9dd1a8498dc6e385b07a00cece7906dba233c87cbad184fb464ebf07b38419a0d38e809bd1bbc7be5d28d43b26c5679f406bdebb4b1c80884d71abc64e35d733d888990653620165264b8aaa462d0f9a695067e9ce388e9f8883f32db4a194d320c05431f6974175590b0214130c180b9cdb15d8e42946a8dbb9233be81195f832888058b1b9e4465791620ba4330dd012f419563201aa35fd8728f2c98fccada8b15b24fa5eb35a665e82ba6b091ffaee1ea13f1a1b927d174aef65667f22bdb4ea4c7872ea93d8a60c20a8ae6ed8573e975c5d3e147662d09be46f583e39155f7cadaaa67f876d7a6dcee3bf769695c6963bcc07ae2fda432c11fbd680016361ff767ec8c47e0f671b305a3991ceaa22f012112d21f464d563f256f76d988f5c25c4e0fa5b1ed07e49fc71f0c971d2ad5594f8017fa2648ef2eb5e16d1c666c075bedb214d635ec8fe477be73db7876eb2f5e4ead0f3afb539a618e3f5b19e9efeebaf431ae7ab60cd32470760df4b50f17071f8b1573945e912f2c977fe4864d2b80780c7126abfa322bf5f892668ff6dd271c52c4f02d69f37231fe08d04a4565069a1cb27426ed6635e86528b7c9ab21b2ae83f39895a4a83c55856312fb5ed39c9811ab01eb989fc84af051a260a761c675b2e7b8b8a7357e3ba5b842b591712e73364bf85897d9a92a752fba5efa7cef3efa4ebc3e1418c3b6a445e263459d8e3fe961008b02ef7fea2dae88aab23a7b1736aa19e34f6526aa90fca0c836f8fac20b418112eb549ed933fc9c8a9aa0e01f696e283e3778b0bd2b4fea8467771d64a21efd1a7ff5a41cc2711055ef0268890a56d0cb8475cd3f694f4e49f53d64c1de9d84f2c8088e067ce753266a350b8d06afb05925b57f47f874fac4bc16d8ac6ab05f9a0e42c934e6029b90bed102dd623c68673274e534bb7366a1ad0b69af6d4f211050a5ef998c6dd20a730c94ef7eb68f691e16ef427c2cce04ba15d2a76612f055ba840c722464f861bc0bebc820a8ca3b216c0a55bd01cc79823f1c6e45c9cff0f17c96435cc4c5630adc6caf4c179258f4a2c1586b3101f55245eeaf1012404512a6ffef2553c9f6debdad3306d1738a3c4ffe2a06695281cf559c52432ef9c4efcd9a786ae4061a31bf8e55795d81318d9dc6aba7c701513cfaee8426a3a5cceddea59f001c397e94681ed084df97459701b911259ff3130ce8252784d8718c32639852add606f8c4fa4d5f0a4d70a2271253bf9d0c36000b9b0247b3d7c3373f3694ecc892c44338c917262fba8127047395b5783015235d3427aae6d5b3f2ba907495a63d41efedab49fa0321a15a3b71fddfed4bf8d9bdfd9bd07515019d19cc2be309c189dc0d64e2f67eb0c9909b263e7be3c3d03ebc6d94109638685791a4afa9d98caf41e05fe78825ac87c17f3b370d7fcb1594d33d872c6eeff23044bb84cc877252bdd33ff4a4602a8fa08ed100a5c18fd397b86d8f34b6c664ff9aa45dd3f4c75d3420f09af6156cf6d2d201ef59999be35a33bb07c4fb93ff771ed102e0303587b193de6105ae9d9b053f9b8a181fc6d64d67eca469a142681ad723e61a3438115b02f262d64710a44f3cdf1e71555054f7f7c43ca78230fad6148fdcddf0d04be6544452f3bca174700cf53f4ec0a1d77ed544af5fdcbad509832d286b5aa9718f2aa9c518fd86704546f073b8697ff91f935de07fd7e46896371ef5d1c4e3f9e8cbf6fb0bbd334662665a8bd9d52bd55aa5bc0e6c2cd4b8f0f9fd28681805ba2a5b5cae0f08df0023fbc64957fb6fd409979eecde37f6d49aa18a716c3aa28090d410920dafc741fd7eadd78d389503d1cfe2c020f59430bb28c83d993d004f0054f13eb76dc3d34506e35857a78308afa3259b142f4cd6c629d6c6e8ef721a076bace7d42bc86acf5f8872f5028cda6abab364005fcf08ed8f09b6e31f629896db3b99212a46d88974a6cc340b5711f99499690ec3bf3dbb280b21a06edd75e707285c9e1739efa23da3c05cc10f5ed65e5cdfab638d5d2fc74617d08cade3e7e78435cb1ce30e9110a519d6850590acad83895f9cab092550ee7920103a817556d017d9867efab8ecf347e9e12915a7408156ed9d35832811d36777c9b593471d01695002693a6e13466833a3a12815b2722ab03f56d441d7ed9fc0fb18130202abefea51cd028058e3be806b6fc6075b18dcb675cf35b003df6e29488ab0e2f4251e00f9be73fcc04b6ade16229cfb1cb63ce1d498307a6263708f35d884f2ab77cbd2b3935223a1d649703c7662cc25f833b1e0a98f395f5367963a4f794ff0104eb6e0ed0bab42fdb06904aae72c9de9421801d06b8347c6d777cc19af457dd90dd6d0bf868e79dbde51c2dd432a93f608470efbb472e1b7803c5f2202619ac132cb250f9b16aeadba87c75770646b55657b5508eccc3b32ca7b8080b40970a9e74c4288dbd43c2da67f628cdb512089cfc6b499c8a92807a7c98dcd40b0c00e4f755af9b9388cf249ddc68a13fa3fcee57fbe2b4c1eec548fb1a256482d8a8be5972f085807cc377cbe8ce6d47f6734a51e0533e6d6994f29dabbd8e78e5b3b8fcb9f5050de7612cc72ed8f84b44566a77c040fadb33219626ad528cee890dcc26d036ec7adecec79e11412e698ac7be96014400db610a0e464c5d37179d61633f237b9e0d5933a1a44d678484996a822df6b6cb9e1a59888685006f81c4f22a84f1994d5a79336ba955fee1433f106cecaef9fd9388f1a17fc80ce4311912b7435f3d6983b8bc035a745c9285529dee033cf513673f98e955244823d248476b2ab40e7220b9d81b00bc413df7cb80aa92cc7ee04082fc4a78d33eb74fcd7d96f5efd7bca0b9063bda5499678db1ca575b4903891ffe20cf3f0cbb2cf85faab8f66feebf30e72e558502651a95b7dfd39166453ece5d271004b83522803a71c12f4e2909ef7a51817138d612200b9154893ab9b505ca22ef6c4ed9e43f45aa4a623f4bed940c3d3e38b58d1a861d1e435d6cdc5ab8977951488ca88f5b435b95e8968aa9604ba17acb05d7aaca9708f9d276f3fa2f228f4098abcb544a9d3b2eb73611c476a05b1d0d085a704c0ba23f14f8d29ac5eb53e43adc4825d49c7cef82f1532e1adfb06cb14e8f8f5cea8cc2627b436ce3582f2672502477d8b6a0a513b5c7a2a03fcb262185df07ba81c90a4a58b538a4aadf21dc8d6f061008dcc456177e21e184166c01e68416739b37929d005580b837cc2078e5f96ff82b46f585437fc79b8d56f9860c506fa2d364edec2ace87857bfe97e27418d472ebb5d5767ff0f4a892c1a3aa1d22d06163a788a689629f994308f5b58bf70ba45bade3a153f87071b941fa84543c4a0c9cb42717f44d95809951d2080cd85dfd3715b68c70027a54981a4e86f6bcb77dc8b868dcb32241c769d70ea3f7f7997406d778da0bf85e06f3beaea58e68d8de6d8851a503d5cadd0eae89baced8b2497fe4975ca1e257b0458bc1ccecc94b4e3709f60d7308ec6e7f47e2130e66da8fbfc500a1b3cac6acca6cd448749b2b31df70a7b85a3aff51b356d13890a458d6577b302d423b13057a7a11707cee62ceebc22299f212aaa8641936ece6c5bd7f469b69ad55245b33a9a3d4ea940ffad2f1117279eaa30c9b93d543affa38a1e25816b1e2995861bff43c6096bb6bda2e357313278f2acc3acf58bb7dd7164205a255c94c7daf814677115d9cfab7a4c4b62103f491fc9bb7d62df05ecc49f656a428c4ff3e96b2dd0282271b0743de636</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码是 hb 房间号</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这篇文章被密码保护。</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>CTSC2011 幸福路径</title>
    <link href="http://summace.cc/LGP4308/"/>
    <id>http://summace.cc/LGP4308/</id>
    <published>2023-09-20T16:00:00.000Z</published>
    <updated>2023-09-21T01:29:12.076Z</updated>
    
    <content type="html"><![CDATA[<p>一道不错的动态规划题目，需要一定思维。</p><span id="more"></span><p><a class="link"   href="https://www.luogu.com.cn/problem/P4308" >Link</a></p><p>首先，考虑最终路径的形态：如果该路径是有限长度的，那么一定是一条简单路径；如果该路径是无限长度的，那一定是一段简单路径与一个环拼接而成。</p><p>证明：如果我们当前经过了至少一个环，那么经过这个环即是最优答案，向外扩展一定不比重复该环优。</p><p>那么我们可以记 <span class="math inline">\(f_{i,j,k}\)</span> 表示从<span class="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span>，经过了 <spanclass="math inline">\(k\)</span> 条边（不包括节点 <spanclass="math inline">\(i\)</span>）的最大收益。</p><p>计算第一种形态，此时 <span class="math inline">\(k\leqn\)</span>，也就是对于所有 <span class="math inline">\(1\leq k\leqn\)</span>，<spanclass="math inline">\(f_{i,j,k}=\max\limits_{j&#39;\rightarrowj}\{f_{i,j&#39;,k-1}+w_{j&#39;}\times\rho^k\}\)</span>。</p><p>考虑第二种形态，我们记录 <span class="math inline">\(c_i\)</span>表示从 <span class="math inline">\(i\)</span>开始重复走环的最大收益，可以利用等比数列求和公式得出，<spanclass="math inline">\(c_i=\max\limits_{k=1}^{n}\left\{\dfrac{f_{i,i,k}}{1-\rho^k}\right\}\)</span>。</p><p>之后我们可以枚举简单路径的终点，然后拼接上重复走环的收益，计算答案即可。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t : e[j])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">if</span>(f[i][j][k - <span class="number">1</span>] &gt;= -eps)</span><br><span class="line">                    f[i][t][k] = <span class="built_in">max</span>(f[i][t][k], f[i][j][k - <span class="number">1</span>] + pmi[k] * w[t]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">if</span>(f[i][i][k] &gt;= -eps) c[i] = <span class="built_in">max</span>(c[i], f[i][i][k] / (<span class="number">1.00</span> - pmi[k]));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n; k++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, w[v0] + f[v0][i][k] + c[i] * pmi[k]);</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道不错的动态规划题目，需要一定思维。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>NOIP 日记</title>
    <link href="http://summace.cc/diary/"/>
    <id>http://summace.cc/diary/</id>
    <published>2023-09-20T16:00:00.000Z</published>
    <updated>2023-10-03T14:29:05.852Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="出错。">  <script id="hbeData" type="hbeData" data-hmacdigest="93b98df06e74663b80a46e7a4e3ea637a29f021ab81b0f89e8ca6e5aa1501690">9ab61599d64bb7443567a78f19eaa4bbfe22a018854dd97a275d48fb7a080fa8c0da90925f8a2cbd4c146ecdae32376f7225e81788324510a769d5c9b7cb389807394deaa3a955138fe6c091217de68c2a93a90e05b42abea282cec1009fb67a52858487851aad26ad91d25ccc18aaf34f16a3f490d7a2e413382e0180b8e8903aaf91902d707ffbbaf5f9bee1e10619c58c50a5fc9c68eb788dea87b40e4fb3e9f02aeb335456cb0c8bd509e5c2b32219c54c70f43afecb3f0864467cbfb4ba84f1eae95fa43ecd63c8184114116e006d1c43615ab3a690ed71e256038ca708f8b69fd502ee0b473e13d218e33facbb437b6238b3c533338bf00bf6a3a5120d13a2f16153dfd360b0b2494df170adb345293904fbe1792ede67c70c78fa90aaf47e18330021d43beea3904a5c9fefb358550f4c4ec5c99a925d3ce787b928be30260eec63facfebe1e434e36b8fe86f7883866ae2d94fae280bd4d7ceb4351df35e4479f5e6e0d8f3ddbfd14b21f71733a685d327184b1b20148e129419f7efd8882c9dd48904c662307cb00298982f0d11f1f7e14d101e30e11ca6e0dcc9468fbaefa4e20724cffdffe9c02cff9179d3f7b62562e31914998635f0839adffc11588b9cbd7abdffd6e41f43cc99e2e8cb86bf680d4e14b9aa6593bd82bfa5a6daa3d3582756ecf29d3f57cf042e13bac48fe6a7a0246f0da4233d915ffecc510aa8cb89e4d3fd5a3bf9f0d70d69cb5ea3cfa5222fc7350f98dfe65620cb0df42afc32084e70dab6cbbd97a1d719543c6b16e1a59c16c12d39eb13a7aacb756c240390246675decb9bc71e7aa68e9c79f72f9cc0d5b9152fab7b492a995c888336d2ef7019b2be0c44d142c4d0face99e67aac28e4fdd14da80122c133e56dce4f6ed5f2771aa6edc4c8c70c53dab1e157678043676bb5ad52e149b6442984878d8427dc69e4d49717a778c514f1e030366bd4c74de40006d2c7c0de132cfe34e4b083661c9624a8aed0c60573e73e1bd1127205cf65580b057d0f23e5fab958164d5f5df4a34909849d7cbff697a13cc15b36cc63ea3a49c4c3054564edc4c6d32e9e8ac3d7c7856be5621f4a43b2131c300258144d2e534e37bc03e402f7bbb408f1f3555fded67b02ecac4ed55b41d0262fb9942e787548a53dc8a29cb611deb28bcc554c41cf9e593caff2c31a2fb5bc96ff8b7e50a5d605a76d21d4a690cf829fa4f0bc0841543583b896be253553b8a4b76c3a9391b1e6b127c3632e5df3a30cad7f074cca7b257e5b32a19c9bc2c8743f55a0432b63ba4fdb203c9406f9a088fd2f879f346febc2be63d073c38eb64542dfdc9c9c33c13effed5e4baa833c9e3e28b98a2119aa5d7ea1e59cde86e27631f5f99099ffdb6dd54071bf20bcc6ac041ce74db27db7f6847ca15e50cadcfad1e6a5e0697e22244159bc66ced45beb32e71c73c39e8a22c54adaec45a6d52ef806dfe78860505a6c8bfc6e0b2ee6a8ac345783f9a1b16128d9fb16f80c6d72952fe2d26c97b91970c1ce864648393601dc4a2fce09182b7e86392c34d86d26bda886f3b8b88d182187c8d84fe3c3b254b421c0f661a0e9b0bfd98109080380f6f0338e3e9334a708458dd4a95454c5513241a742a86db7ac5fd767ffd0e2c861867dcf62b8fe29757b6dff4b66ed660c8a43424e3f9fc6ffb80ba570380381c1063a23023a97b1ddb10ffce3ad7a38cfcc4cec01de0838b958f407af74574b8e9886eb41d07f669a3e065435a22f62540eee087dc159d63540f9f4e991f0a035b19cca5b570acc45819d9dc038dbeac8fe44e9e7fca2634bb34ed4df1dc05fae94bde711e012add1a17458adc3741eaafbfc093767f585396d8e9682621c6839ab1154ea0df9c0a4f1e7d677eb3f30a6f230a95846b9fd47cb3749a50acd953a3225810e1b3d3f6ae556de719618feb97f7848aa588579cb1eda4843c6db3fc3901c9800a8bce8db36fcd533732378a8d2222dfa5a1783c8d50521fc9f54cad622339f5c874880303ae99a4eeb9d1ab44d912846bb5029514631f88cf5b474dcc2e5d715f5750057b67d3c700981ade05ef9eba69fe05c8be36c276d9affba26a4e76668ffe1116cae923542071fdeaf13fb1eada223215c1c809f5653fd54a8fe04adcebe14c968e762427b19222348c4c1d0c11a87fe21c0988c8c91a6c15a500667892f88e128e8a6b7a2e3ca69d2828f54c3b08df9971d5470d2b80dc4ad06450c167b424a648b66bf9739972a9a384b212776b40758d2eb8082528d174ebfe1c34c93bbdb40ab4cf6f801793d2cad013aeca4f6dde2d8c8e08b6b94ac7f210588c43f59b082ef1ac24143a3d3147900ca3e3262dd3d6594b62f8d12ffae7e1fb38086c647200fd0f2ddc629e4bc64492041757082b6b3a76de31a0e75c6dd05184d68be5aa51060777d5eb56da71b166f47a7657581a57b1a91314f2a3b35bf59a973068dfb89fdec4568e6cad8334e8522562994bc448883bf25b0c27c6b22fae0a85487ca8a422583e1404e9f0f3b082f4c23af8094cde4315b64d1bc4fa2c6ff4297efd7f8524e047337f4dcb8fac731b29c19e553759534a1e159ea9df2d2b9346721b9eac8cb87649114c72bb4a27df2692ddaeedc9c19c6708ef856fa73257332561ebcb19c4d01622e0f9b263b82cd86c0b9ed0ee78a0c8dd5ff3232558b1fffd71b5b151f5fbe8edd26ad5f230e14fe455b9ae33f044b5fdef050eac5eb5264d56b580624ded4dd807deec9f38d340988ef486a3d9c7535bc309393edb757331d03b218b6afc1270f1314aa06e5e08299976e063346b3e91588550abcf28017aa38577dd63df0cd8498c23535e95830a349f298902a0c71f9b36d8f6f80764766350f4ce8fab0f2ecaef76be3ea042c28e89a38c7647dbd093882e0f5c8da45436d1584452e8d24327b39c818ee836491235e07bbdfe446a4b6bfb545b5c15e79a1b874c4656cc8f9f9468804f8c1075ec93b1a5aede3ed1fbfe4292812de0700fbf41d4a361a54d648921f7954c0e8bd4e07e24ec5191e9573c68433a7428f1f4a6c53f4cf488df44d09d90f6ea3b8460bf48886e4c2a5b4fb0c0c14da01a9742cfbbbbc28a9c483efd2b7ecce50b4af3e0e80efb685427dd8bb47f29e8024c171f4c7ce71f27192a169e01c97b9c1d967d0c3b75c17d3379b76fa3e01384c65d614ff3f00e7cdf8d654042ceb1b23f80172632949f78bdf87055e609015e67027ec06364532df88040bb1e6ae105327b58ae3e1aba2c89952dd3f2b0a023583db46e5afa577ab9ae086c7f8d2e5c9ade6807d9079cc15789f62b651049876138d6d971d17731abbe4cffaca911b2c78ae5a8cbbbc51325e1de4ba5d8ec275ba25e89af1cdb3b4941b4c3788b2989d6b983bc9c02419b43d0f4c3b644c3ad3ca4aeac4b80808f5d1abecec8566ddf2b2f07a3c1116c80fdf7be99c45eef3cdc6ef52c6dbb8f64ec3c2bf9f11e3be0d760ef270d5b9553b82eb225149ce749a74d1e30d3bf7afb07457fc9e4d927df7ebac6dcc407ee9a6c48bf75e7fecb789c281a48fc366af23700acb0ae83ef35f270edaada2771e51f49774473cb09d82f9dc0c788e933f634642018c91e240d3892167fea8a3dd2eaea0d896d9346dcd8df8f71bf8f55d02999c6df33a096bc0a3a40df681a09bca1055d214045c4d3e594f5a9b9c4e4b17e6c76edfc1a6afd157ce47e773445736a958e5ac4987cae3a3602d94696d1fc4cb7241e28b300dde20ea8cad960f9093552b1bf94cc5f0e17cfc5870366c33be7e8471e13a78c35168ac51741d4ba46ba3e7bdfc5485f8eabb5c6827b1f8b37ac95615c05f208e0bd7f61d18793ff12c96d744b7e55212b887597ff77f5172014fa0f33894dd4cbf04cd0f6cc625ced97445211796e09c741813200f686b15d4044d69edade8c52e327b7d12dfa32848e61d399717fe64fd4606edcc5e22c96875c8207e999982d0aae73f65153cce910574e2bd32abaee0c4b2f0b36505532c6b787c80ff39f3e19b47d97e3f182bcf37a0d00022d430670e3e31a17222c69613ae57cc37a85afd565741a3bfaed14ad343902daabca06c7dd66330b39e5c904131134cd7b2f37cca501304134f96587b3614a7815f94ab95d88132d7119efc7ba9a2ff8fc9eca09d49e9c420989439636adf26b25304804862edcb8ecf6ea4761052dc5fa2934de97c64cd399d31e13e900c508269b4e90336996c2281d9bb58266de096dd4291ffbebb43baebed1d0b27fe51da568fc46793dd9c07b5dd21187a0e4a4f7582550c6ecd7829ef8b554ab43eac25a20ad6eedd136382787195f0ecc18987d238281db79fb03ed309d5474df55aa7225167a8d59b6a495243f86d3b94d1ad9b8065a2195349d1b5aac08010fffb818afe758b60dc4c7b91d382d1f1995d6d906f7474f3e8e22609ce7e3983b6eb809d0755e75788f1e96003e5bfed26967cfc46197c8161ab53abe005f0132f6637f4d61afd7501eac5e6e88ce1760ceb8011256fd2094414849037d4890179ffa230ee2f0aafb6992baa89f35dcaa68d815cfd80dfa79a2338e8ec19b836e0770bbeb60d36ecac87fec3d6731f8aa6ba54b87f6393c3c9036984a7f3f48609e4231e14896c5a36e2f175742da6677f02806bbc8ff4ffd17f3e5fd6bf43209e2e84786ae23a015763a16db39bd963065ad25306ec91596c2115e534e00de39aec5506fad748b232d4f12425a67585d5fa162c1764cfa36c98c3fc63aa93415dc57fa47de14fb531dc268fce91d5c8c60974aeb24f23f03e1ec1b930cd68a272a51a3e66efde6d279a90298c2b45b44f7644c5a475d54eacf21abad239ccc4668874f8027f7a6b2da740494c40ad90ef7a4a4cf3beeeb87f63ccb146578a815fe2cd59942817c4ec6eb10b0bece329591333293a235645198a4caeeb95a4c7c6363c5600a193a752868d52c659070a18d4ed499dc8a83b64f4e699bfb02406668e04b1d32d6f2ece44cb49d7ddbe83621e0133c9f1e98a491235a0423e75623cc6c7ebc7032b81c96b52b33c16b9e2ce0b1973dac006b91302ab272dd126a85976a846c0b1c60d40684f05c1d93d56ac4d5f63589c278343e309e08a18f148d8cb8d821bfda798b4bfc884320f502533af9c6bac5f22753a6c1751d82d8083f2d315a5431651cb0bcc0a9f0a53764a0c1f284223c03a6d4670e887ce7b38e2b26cdc5c474a52c6da4b12317f8c4be85120055d82229a4ec7f1bcb2a8af88617acef4319e654c548bf9f245bc6c2b6011e51817091bd3b2c5fb4cc9be56d9a7cf85ab8ec1f998baa27ede58d0828bb1ae59aa4572d5ef3fc03ce30ccd11f47aab8cc18781cba717a7f4a610c41ba81b9e427b6d88cefe220ec12ad4ba696ca5959f0325cc37aa3fc42921933f35b4943a70cef4d6dbed7456c1e4512f42bc0be0e64b33cc410efa6fe6b949c031d592b32674bbc03b093c5c4a264476ed1c3a3b5352f3596989893b9d6c88a2ca82a6d269f2130442e63b91e2beab7c5078d7fa64f93a6ad990e629e5b60a2053e561e291f4c50886f4dc8fc8acb05be5da0ba8e55b2e83d18c9c4c72a286e9012bf7ebaaaba14bb4488a77cb8eaf88d38a24cd54d865f5af67ee669b2853c77ebfeef93c1837bbe25fddb652eeb81a870d8618b99f54a59605a0b2278d5cad34d15f22e924566f672f735dd9260103161c5b9cf747a73c98df8774a50c98f142aa6661d35d3ae4804adfe2ac5990882463143c84ba051df08b2413a603f1d64440d7a94837e3da82cecdd20b4c526f7ac7d97dd4ab40cc6266e08e7aab1a9d8611d8ec7313325b8da6369341a8831e1704f69ace8e811acd596052f92c77d04b9766b2e2b5bd3438dee1056ef1e166be8adba87d8890fb41d10d33400a54174cf33f166c614eefad7e6b1285bf5ace74000634be45b717f483b8c8ce586ef3e7de659ffb3d041777cc3bce32fe0074d4bee8ecc3d3d29592bd24376de11a906b7798b0ac45576555b8182f0cfea83135ba00c3068cfce0568ea69da8a17b276f7ef89a1960bab5cc3f526ad22887d365df1c7c1548c7f3b90b80260ed1d42fcba04241bb88661fd709f002d0e3b080f2c105042bb8e22b244d9417b7d2a356f70d6bf7834281a406b1f484c481041c7095cba233b9d51e2e81b268de47a4e1ec1dd05460ddb71d18671fa9b4d6d5557d0fb5c2fcb8f794dcbdc5837fbf3223646b3a6c35081fede97ce702962f9680caf845eb2ab63406db8a8524d819acd82010dacfef1c1c53b21c69ae38099474cac31f8cb7a07e673279b8c02d032411c0cd5b0509d13296707a76ef4c78920795cb00dcc2e504ccada7332a107064ae0061b2fbc8432488fa7e0c0a495d03b352a3d05c9b23364c12b21c94ada766d64a7502660e2170dd56a5d9cd2a1d497dbdc26150a2c1c4e9acf474f9e51ae93dec587db26f308157a2e14d96d12348d92713fdee00d3341ddaca42ca70d4e95eca9e1a3a9c5cd2f22cb365a932c48ae9a8f659e3345dd71e5313bfffbe951266260d261eff9a05e0c3064467cefe92884e888c18775b5240f81db6cc2e9d4c94c975d9c6ced1eed99a104a72d870eb585d5deb81fb77f9af0d9c4fc2ddd4cc4db6ab0e0b5a247d7424bce90a61dd40fc330f27475e8a768ab05fdd8abe200a4b81983d2ff90a6f6ef38e8e51e74dbe6ad0c62e950d9b05034a6fcd266daadb1c3c38afde18be0e1413e417a235727e857d7d3edb8aec34c4e8ca6b1e7b977c2404273b6b38dd5a9859e4937473c147eb2a46a03f89b244c5f67f8d088949471f432cc3091905cdbeaf7dd0c8cf09866e92e0675321253073df8bbb72c1895a45f8f56620bdfeea205faad560e2efa2c1661a75a5c1fcbc859dcd43e754fc72f9c34eb2104b15e7a0d8af8128a08228b5740d8bbb137717b89195f3a524170b5a3109d338f1cea2cccaed0fa2b333672109cbb49d5be0aef85b0d6217e50712ef6a7dc861fd38c9f7c48a71736e20e720fcbfd10a9391c96e87da44bf3dbbc1d6659944670eea1e6f3af20ca829169f3ac5da1cc15e4acb06f003b8e771cf941b2c6ca7a65faa3b3f132e31584eee6be0fb96710d8647ec080e482a056ddf708e959b27aa74752430775c20d93ede87185f6aad40855c6f421ddf98a3478ad3b1565ebbfe6e86a19bbb4be879a79306aaec2844d2169d64114baa5bb154ce032010885d82bf78041d59b1b175e96660b089d6850e89fc48f16455e26b935452f1a5c2a3602e8e6a6a4bc9c29af9757b340640483893d6d77968d8962ff24789b7623d067cd34ae81e61eb634aff0bd6e12cb07404652d51725b8c383e35b25b366d80debb4b314a7b2d2b8798276879767dcbe4f921a5e88dff2b9c79cef404d4c22613d9064b7427ea89260e72d6afb816d500596c6ff4d7ad1dcae0116c497807cfd38a87a8288ad5604efbe11f2e69809d346af274968a82a483eb4c70388492d61d7d2a5ed14aed2b1a774a6bfae3e65af4b4db885d53ed683832074d8a084f05f0dc723750903caf4d96a695b3e8193f4daa1067ac162b47b907e8b930ae3d508ff1df54a598ca5cf59692b605e23eaded8c537a0bf870f3ef920facf8a4ba4631ff302ab393703bd053afb835a3801ab973093f1c39a2938d8f6249a794d6d9784a8bd9c5e798c51622aaac0cf199a3b3e0ec1bf0aa6848787a2e798ae0a91a8872189687c3aadcd52b65b5b6d7bd1500a1600a2751de323a39b4edacf71ae01b9faa1d0c097dd48607ab594e9aa54ad5584e5e76d30f4048fcaa9b59aae6f3c24f9bb03a29b4556e1ce5302210929d24f976b15073043fa753b2bf8ac3577d858720bdadb51f6b0ea845331988d4f16a6dbd69e11ee5cefc45d9911bd65193d9dba8f10908f7d125c05d25d00970e007e16ae338870dca3c64f2d933c5cc9d641f560079ec71fad24a166b1305df67b740ecd9a1b8392f574d321ffdedd0c0d13be2d69e2cc136df21639f6f9d170d97b7350ca188616400c523fd6f3d0c155f0d9f1660b4c3ab03ddd79d5be299b689da551c617d985a6bd133521f8c06216910488110a474c8dced745f8dd05cd958614da6d1a6c26c8aac2fcba719704069974710e50452ecd7283b9f4ef8ba32cddc8531da240af2f15fc44c792bbc6d4289f479efd0246e32db21d734b07cb4e6615bd23e39fb771652c9f142b1d54e0746727b124e6d7f6b5a47f047189c89ff913170fed673ea64732dcd9d9c55fc3d41a60a429afac0cee2ff77b78678d286a59087106cc12b76cc1e5eb6da8a9cb94e3814f3529096a9d3857ddcffd81198310ca4d1bf74c01251415eae65dbae85da12ac4fd070620362a203aa1cf7e8413ab8e5926ff496fb893e62e27675afd0f0419a8823ba1819986b1a68d92143f499c287e6af99ea2991b8d964b66b53ad1648d6889131684c19f09c942684785f2e2ca35029d630745b45d64bfa69a9ba0483ffc73e2904e21a1ef2135d952e5a60036b0e3a35598e4a706fe559b24698e011cd543c8c55162983148c71c5639827bc64df45e0349d2e897589c0a125172441a53f8bb67d57c9399315bf89a122dac5ec382f6ec8b0e21bdf76e7059d052f5b110f4cfe4a7a77dfe7f6ddb9b9858ba3135c03b7f11d84ac32aba6df977e198e5a935ed67c744340a3b1802e5f2884e352fdbf857a7021aec66548a0d53432ec5b3a851a3f17ffb41ccd3c5dc59210fc57c3fbfb9874cda4bee19a14e9494ef3800b2fba6994d4d96e62b41e509df064b5414700085072b822010e3e319f9d86b720bf217cf568b0e52de3895561c5cdaebe7a769c12cce23979de3129d311797a55fae5f52f22835f8c99a5adfc79f714b0c7e232a86c887eba6a057ef3e8fdeffc59a87484bc71ed33444d4fda03cbb66bb1269dec58aadde1d095c6a1834b7aa213533df06455965333836caa97317efd11169407a09ca018cfac0f906cd8fa4a117c7c3cb495c1c33ae9cdffdb96592dce37441ae6700a04798ad38193ac7283852b10d304d146f545f4e23d281b0106a495d40931cd7b4c9c9c71950318035b38aac8416909e812c6eb87a531e22b4131789b38fb8b900a71614bd18cc3140ae678be6c2c165bc9ea0a91ad02d47270ca2eda3cdf3418fbb463fdc15633f55845883e8686674aaf68645ad2430dbad1db2c24e80ba5cb90668b54de420a2fc422fadcd4f0bcb833ab2906524ca7af66085537cc23db0e191d476f81a0b56c4a30c9766910568ffa1cf320a5dcfcaa5a8a17595d5a95c799a6dba394193a826f0f7cdcd2f3221943738ee1db94b8fdd0e66ba166f2dccaf8ec59fdcd72076d6a039e06a4e1c1fdf5efb0ce158106c378572c8e9fa2bd60a611b197eb2598f02d2cf252d1c2d77dbf68e8271f43884030a300d1dad4d03bb0dc21c3db59174514dbbd4423cd7a40c6a165349712923cfd77ef782e9b455614f689631661a68ded405a3700d4349b84478a91726b8afe499c14b45af9196f4f789a8d569867f4b563a94614b24c0bf56a2cfc54cd640709c83f6401a7867e5bc64dd283441bfd4b9e4a171a880d3cadfa554409c5f49db24f71f44c8bd77ec57af7c15c46b0d92e02a8b468041fb7b4e3550bbf65e735e0ebbfd0dc732ed5a2e45878309b8a3adaa8ae722900f341c0c62b1610022c9b413df8c265c6b59d28b3501dc97c6767535780d2c1775b10ea065a34fbd0fee8621029709472a5ea4ff50df050cddf4d42bc81e4a42f0f72dc287eeb7f7da1963fc56abd74689bf9e622836a2d0adedfdc78c2add122fb7fe53b5e0d9dd28e62d3ecc593ced6280f567283e2ce21dfb8348b41dc1926cac041ac9c438f841b0f9c1a34ab6507f9d586ab043069346a5bd317d41a2fcc0470056a67277940fcffc97e840227bde5081d31a5c557a0afada9fb68e08a075bf6b4c8efd249cab7de6f9d6c0b872d04d22696967b8e1643ec69b8b7a2fd5ba9fbdd92b8f7d195157d25d0a5c90f563b4431f877bd93096c1666662d372fe7edb0ddeeedc856d331941c5e2597779eac9ffd900c889fd370bfa9c2056120798847c2d3d62eb414f7854da33d2f44ac87b0c479655428bd53930a470e8d8e9eef101022e08cfcbbff35402c7806e3cd90cf24401d56dd483aadc90fb48c80b4eae8c9906fa3313def5fb614a89bbc2f4f847052e3a3f8204818aee5c71ba878747ef70ea6cb26c871b3c3f63b6c39abb54f323c53dbe8fe504d86e35ba42326d87d6a10c76755c22766be1b22014d6806f5e3656bc08d4ecc588a6006be7ce0105bca447490466e2e1fbad6a7a5917d69fbf448bd5ffa0610d81e7a88b5297df233f087e3610ce4c2785fc2957699b2694e335e8eeeb1bbe0475f64e8509febf6f7b6980b128c5f7383a6bfd6febd871a0a97f736704851fd18152a8fb6d7686e093e0d9e504846fcf0cfd3aada122273a8d544b3a6cfaa5b61c712c39a53331709cc27735c5c7e8cd32494b71213df2255416572bcb3257e43a971f784ec734f85614e64ebe36c98c0d8ecffd8226327be2720094aa0b080de3c6b131321562485ee9e92ac9bcbf15ad213f7c3225522a02b67a53527f44721050d1b46dceea240657d0d13b64633ed52eff8dc910999a096d442a086d176616afd080ada234c70e396a5abd90376e7f2899b6e27bc9756f1cb4465ee35e3dadd8b05c0f0fae03005f18f656fbea5b713da4ff0fea614ce0bc108ab42f0e01b94b997cb462810de959756c41b132a115f6505cf570ea6e8e6fc8325e6721a4a4823a410bd0f48fe14d8216aa3237ce4619b6bf713d1f2fe7fa810dc76c2321c0b946fb8f248969107acd4f7e8fe7a99a34d7e7583ced321f379c8a0f3d214f4740f4a838cc5e5461c95d4994c86b06fe60d54509e4d7f3353e96d0a3505e898a898bf4c7435367e3565f38cea4b5c00a75b4925e3d665ce19d655aefa01361924dc729dab7a900bde483687c4161e225b580d85d9b7c074d806e34158de24161de1d2bdbb8257966d1cbbd4bc48718753f4cb9c576455384ff6793ca5a772d414aec88fcfe8184e0fe761449487bf7d50fe386f18adb3672f1107da276169e7d13acbcb1f8e2566af0502ad4f09cad472a0b8a826bdcfe4ef2a87dc5ecd0c0245de12dd30aedb0575250564607fa4c8f4cd9b5e55767d3daba202ce57a32d7d08aa188c6060686977a166b07498986edc67705a71e928ab537bfa026d950e31846b00c8b2ea6813a5bad0fa97584c675fac21abcd72a0b7d5ed8b9a6f720286bf4fd5745ece4f7d8d2bbc351a6f4ab9c9ad8fee7bed27c5c2346d804cd9d5523825a60dc99afcb2c37a0aa819c5854f81957422d2b7e8dbb2d9dc3e19cf3cff9938cb6c000618137b10072e7d07f22d8fc2e2268337622af6096e3e8e1f4d556cd003c743f4902ae3eb328b240e0b11fd3400d8a31189c283fdd3ec3da4551c088cef9fdcaabe83d47267f0a45a61b127e9b039e8063d417b31978ea0a4cbac3eecbac5e7ab9f714a91654e8fd81307c517718cc0889a08d40dd379c865bb44418b107f746f0256b66674a4a656d0dd352ed4e614deab2773984753c411835e4f3eeef80589d9d724bfae0fc9601b63fd973d41a561ed2ab01c67e3b72e5d84abb9ca2516caef2ad970ba6bcaa9289a254e1274b2cf5454a818b536dd81fe4fb7a6ee679402ddd44c8d3b1aff220361f56958209be7671702da439bd56f55ee239de498247811a6530a506c76fa06d8757d81af3fee9ecd61de55813cb6ab5f4e1a0c0bbcbd78012c487a6cbb747e7198e769e27ef983ba12e58440e7064af2ff688cf9c1e234ee0ca9771e1c77b09d4af6bffd0e672a13330b931d25366abcfdeed6c488d42cf4a696a542f06bd21ed0c131015934df87ae</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不要随便看别人日记哦</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这篇文章被密码保护。</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划题目随解</title>
    <link href="http://summace.cc/dp/"/>
    <id>http://summace.cc/dp/</id>
    <published>2023-09-04T16:00:00.000Z</published>
    <updated>2023-10-03T12:22:59.242Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新。</p><span id="more"></span><h1 id="cf258d-little-elephant-and-broken-sorting">CF258D LittleElephant and Broken Sorting</h1><p><a class="link"   href="https://codeforces.com/contest/258/problem/D" >Link</a><spanclass="math inline">\((^*2600)\)</span></p><blockquote><p>给定排列 <span class="math inline">\(p\)</span>，有 <spanclass="math inline">\(m\)</span> 次操作，每次操作给定 <spanclass="math inline">\(x,y\)</span>，等概率选择是否交换。求 <spanclass="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=i}^{n}P(p_i&gt;p_j)\)</span>。</p><p><span class="math inline">\(n,m\leq 10^3\)</span>。</p></blockquote><p>考虑直接设 <span class="math inline">\(f_{l,r}\)</span> 表示 <spanclass="math inline">\(p_l&gt;p_r\)</span>的概率。初始化很好初始化，我们考虑直接对操作进行转移。</p><p>假如我们要交换 <span class="math inline">\(p_l\)</span> 和 <spanclass="math inline">\(p_r\)</span>，那么此时其本身 <spanclass="math inline">\(f_{l,r}=f_{r,l}=0.5\)</span>。对于 <spanclass="math inline">\(\forall x\neql,r\)</span>，考虑不交换和交换之后的改变。</p><p>可以分以下情况讨论：</p><ol type="1"><li><spanclass="math inline">\(f_{x,l}=\dfrac{f_{x,l}+f_{x,r}}{2}\)</span>；</li><li><spanclass="math inline">\(f_{r,x}=\dfrac{f_{r,x}+f_{l,x}}{2}\)</span>；</li><li><spanclass="math inline">\(f_{l,x}=\dfrac{f_{l,x}+f_{r,x}}{2}\)</span>；</li><li><spanclass="math inline">\(f_{x,r}=\dfrac{f_{x,r}+f_{x,l}}{2}\)</span>。</li></ol><p>容易发现 <span class="math inline">\(1\)</span> 和 <spanclass="math inline">\(4\)</span>、<span class="math inline">\(2\)</span>和 <span class="math inline">\(3\)</span>的转移是相同的，可以一起处理。最后扫一遍即可，<spanclass="math inline">\(O(n^2)\)</span>。</p><details><summary>Code(Tap)</summary><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">read</span>(l, r);</span><br><span class="line">    f[l][r] = f[r][l] = <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == l || x == r) <span class="keyword">continue</span>;</span><br><span class="line">        f[x][l] = f[x][r] = ((f[x][l] + f[x][r]) / <span class="number">2.00</span>);</span><br><span class="line">        f[r][x] = f[l][x] = ((f[r][x] + f[l][x]) / <span class="number">2.00</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h1 id="cf1185g2-playlist-for-polycarp">CF1185G2 Playlist forPolycarp</h1><p><a class="link"  href="https://codeforces.com/contest/1185/problem/G2" >Link</a><spanclass="math inline">\((^*2600)\)</span></p><blockquote><p>给定 <span class="math inline">\(n\)</span> 首歌，每首歌有时间 <spanclass="math inline">\(t_i\)</span> 与流派 <spanclass="math inline">\(g_i\)</span>。需要从中排列若干首歌，使得时间恰好为<span class="math inline">\(T\)</span>，且相邻流派不同。</p><p><span class="math inline">\(1\leq n\leq 50,1\leq T\leq 2500,1\leqt_i\leq 50,1\leq g_i\leq 3\)</span>。</p></blockquote><p>不妨设 <span class="math inline">\(f_{i,j,k,1/2/3}\)</span>表示三种流派分别选了 <span class="math inline">\(i,j,k\)</span>首，最后一首为 <span class="math inline">\(1/2/3\)</span>的方案数。这个显然是很好转移的，时间复杂度 <spanclass="math inline">\(O(n^3)\)</span>。由于我们要求的是排列，因此还要乘一个<span class="math inline">\(i!j!k!\)</span>。</p><p>然后我们在考虑相邻流派不同，时间恰好为 <spanclass="math inline">\(T\)</span>的方程。这个有点类似于背包，但是直接背包时间复杂度是 <spanclass="math inline">\(O(n^3T)\)</span> 的，不能接受。</p><p>这里有一个比较巧妙的方法：将背包拆分成两个背包之后再分别求解。即我们记<span class="math inline">\(g_{i,t}\)</span> 为选择 <spanclass="math inline">\(1\)</span> 的背包，<spanclass="math inline">\(h_{j,k,t}\)</span> 为选择 <spanclass="math inline">\(2,3\)</span> 的背包。这样时间复杂度分别为 <spanclass="math inline">\(O(nT),O(n^2T)\)</span>。最后我们只需要枚举 <spanclass="math inline">\(g\)</span> 的 <spanclass="math inline">\(t\)</span>，<span class="math inline">\(h\)</span>的 <span class="math inline">\(t\)</span> 可以由 <spanclass="math inline">\(T-t\)</span> 得出。</p><p>最后我们将答案乘在一起即可。</p><details><summary>Code(Tap)</summary><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>] = f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n1; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n2; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n3; k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= <span class="number">3</span>; v++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i][j][k][v] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(v != <span class="number">1</span>) f[i + <span class="number">1</span>][j][k][<span class="number">1</span>] += f[i][j][k][v], f[i + <span class="number">1</span>][j][k][<span class="number">1</span>] %= mod;</span><br><span class="line">                <span class="keyword">if</span>(v != <span class="number">2</span>) f[i][j + <span class="number">1</span>][k][<span class="number">2</span>] += f[i][j][k][v], f[i][j + <span class="number">1</span>][k][<span class="number">2</span>] %= mod;</span><br><span class="line">                <span class="keyword">if</span>(v != <span class="number">3</span>) f[i][j][k + <span class="number">1</span>][<span class="number">3</span>] += f[i][j][k][v], f[i][j][k + <span class="number">1</span>][<span class="number">3</span>] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>] = h[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = T - a[<span class="number">1</span>][i]; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            g[j + <span class="number">1</span>][k + a[<span class="number">1</span>][i]] += g[j][k], g[j + <span class="number">1</span>][k + a[<span class="number">1</span>][i]] %= mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = T - a[<span class="number">2</span>][i]; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            h[j + <span class="number">1</span>][<span class="number">0</span>][k + a[<span class="number">2</span>][i]] += h[j][<span class="number">0</span>][k], h[j + <span class="number">1</span>][<span class="number">0</span>][k + a[<span class="number">2</span>][i]] %= mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n3; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = n2; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v = T - a[<span class="number">3</span>][i]; v &gt;= <span class="number">0</span>; v--)</span><br><span class="line">                h[j][k + <span class="number">1</span>][v + a[<span class="number">3</span>][i]] += h[j][k][v], h[j][k + <span class="number">1</span>][v + a[<span class="number">3</span>][i]] %= mod;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n1; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n2; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n3; k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= T; t++)</span><br><span class="line">                <span class="keyword">if</span>(g[i][T - t])</span><br><span class="line">                    ans += ((f[i][j][k][<span class="number">1</span>] + f[i][j][k][<span class="number">2</span>]) % mod + f[i][j][k][<span class="number">3</span>]) % mod * fct[i] % mod * fct[j] % mod * fct[k] % mod * h[j][k][t] % mod * g[i][T - t] % mod, ans %= mod;</span><br></pre></td></tr></table></figure></div></details><h1 id="cf1699e-three-days-grace">CF1699E Three Days Grace</h1><p><a class="link"   href="https://codeforces.com/contest/1699/problem/E" >link</a><spanclass="math inline">\((^*2600)\)</span></p><blockquote><p>给定 <span class="math inline">\(n\)</span> 个元素的可重集 <spanclass="math inline">\(S\)</span>，值域为 <spanclass="math inline">\([1,m]\)</span>，你可以进行若干次操作：选择 <spanclass="math inline">\(A_i\in S\)</span>，将其拆分成 <spanclass="math inline">\(p\cdot q=A_i\)</span>，删除 <spanclass="math inline">\(A_i\)</span> 并加入 <spanclass="math inline">\(p,q\)</span>。需要最小化极差。</p><p><span class="math inline">\(1\leq n\leq 10^6, 1\leq m\leq 5\cdot10^6\)</span>。</p></blockquote><p>想象一个竖直的数轴，考虑将一个点拆分的过程实际相当于将比较高的点变换到比较低的位置。</p><p>这给我们一个启示：答案一定在一个区间 <spanclass="math inline">\([l,r]\)</span>内，进一步我们可以找出类似于双指针的方法：固定 <spanclass="math inline">\(l\)</span>，并从大到小维护 <spanclass="math inline">\(r\)</span>。</p><p>于是我们不妨设 <span class="math inline">\(f_{l,i}\)</span>表示区间下界在 <span class="math inline">\(l\)</span>，当前枚举到点<span class="math inline">\(i\)</span>，此时的最小最大值。</p><p>考虑转移到 <span class="math inline">\(j\)</span>，若 <spanclass="math inline">\(j\)</span> 不能被拆分出来，那么 <spanclass="math inline">\(f_{l,i}=f_{l+1,i}\)</span>；如果 <spanclass="math inline">\(j\)</span>可以被拆分出来，那么我们把这个拆出去，<spanclass="math inline">\(f_{l,i}=\min\{f_{l,\frac{j}{i}}\,f_{l,i}\}\)</span>。由于不一定只拆出来一个<spanclass="math inline">\(i\)</span>，所以这里我们可以用一些多重背包的思想。</p><p>但是这样是不能接受的。考虑怎么优化：首先可以压掉第一维，然后第二维从<span class="math inline">\(i\times i\)</span> 开始每次 <spanclass="math inline">\(+i\)</span>，是调和级数级别的。</p><p>然后我们考虑在 <span class="math inline">\(i\)</span>不变的情况下，随着 <span class="math inline">\(l\)</span> 下降，<spanclass="math inline">\(f\)</span> 是单调递减的。因此我们可以对 <spanclass="math inline">\(f\)</span>数组开桶，用指针向下扫到第一个存在值的位置。</p><p>这样的时间复杂度是 <span class="math inline">\(O(m\log m)\)</span>的。</p><details><summary>Code(Tap)</summary><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(n, m);</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, (m + <span class="number">1</span>) * <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(t, <span class="number">0</span>, (m + <span class="number">1</span>) * <span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> lim = <span class="number">1e9</span> + <span class="number">7</span>, ans = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">    lim = <span class="built_in">min</span>(lim, x);</span><br><span class="line">    a[x] = t[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) f[i] = i;</span><br><span class="line"><span class="type">int</span> pt = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = m; i; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i * i &lt;= m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i * i; j &lt;= m; j += i)</span><br><span class="line">        &#123;</span><br><span class="line">            t[f[j]] -= a[j];</span><br><span class="line">            f[j] = <span class="built_in">min</span>(f[j], f[j / i]);</span><br><span class="line">            t[f[j]] += a[j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!t[pt]) pt--;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= lim) ans = <span class="built_in">min</span>(ans, pt - i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br></pre></td></tr></table></figure></div></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续更新。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>线性代数学习笔记</title>
    <link href="http://summace.cc/Linear-Algebra/"/>
    <id>http://summace.cc/Linear-Algebra/</id>
    <published>2023-08-01T16:00:00.000Z</published>
    <updated>2023-09-15T01:15:42.724Z</updated>
    
    <content type="html"><![CDATA[<p>学数论学自闭了，感觉线性代数还可以。</p><p>供自己复习用。</p><span id="more"></span><h1 id="矩阵">矩阵</h1><p>一个具有 <span class="math inline">\(n\)</span> 行 <spanclass="math inline">\(m\)</span> 列元素的矩形阵列，形如：</p><p><span class="math display">\[A=\begin{bmatrix}    a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,m}\\    a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; a_{2,m}\\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    a_{n,1} &amp; a_{n,2} &amp; \cdots &amp; a_{n,m}\\\end{bmatrix}\]</span></p><ul><li>主对角线：<span class="math inline">\(A_{i,i}\)</span> 的元素。</li><li>单位矩阵：主对角线为 <span class="math inline">\(1\)</span>，其余为<span class="math inline">\(0\)</span> 的矩阵，记为 <spanclass="math inline">\(I\)</span>。</li><li>方阵：行数和列数相等的矩阵。</li><li>同型矩阵：行数和列数分别相等的矩阵。</li></ul><h2 id="矩阵的运算">矩阵的运算</h2><h3 id="矩阵的加减">矩阵的加减</h3><p>只有同型矩阵才可以加减，直接将对应位置加减即可。</p><h3 id="转置矩阵">转置矩阵</h3><p>将矩阵行列互换，记作 <span class="math inline">\(A^{T}\)</span>。</p><h3 id="矩阵乘法">矩阵乘法</h3><p>设 <span class="math inline">\(A\)</span> 是 <spanclass="math inline">\(N \times K\)</span> 的矩阵，<spanclass="math inline">\(B\)</span> 是 <span class="math inline">\(K\timesM\)</span> 的矩阵，则乘积 <span class="math inline">\(C\)</span>为：</p><p><span class="math display">\[C_{i,j}=\sum\limits_{i=1}^KA_{i,k}B_{k,j}\]</span></p><h3 id="方阵的逆">方阵的逆</h3><p>若有方阵 <span class="math inline">\(P\)</span> 使方阵 <spanclass="math inline">\(A\times P=I\)</span>，则称方阵 <spanclass="math inline">\(P\)</span> 为方阵的逆矩阵。</p><p>逆矩阵不一定存在。</p><h1 id="行列式">行列式</h1><h2 id="积和式">积和式</h2><p>方阵 <span class="math inline">\(A\)</span>的积和式为不同行不同列所有排列 <span class="math inline">\(p_i\)</span>的乘积之和。显然，这样的排列有 <span class="math inline">\(n!\)</span>个。</p><h2 id="行列式-1">行列式</h2><p>在积和式的基础上，记 <span class="math inline">\(\pi_i\)</span> 为<span class="math inline">\(p_i\)</span>中下标的逆序对个数，那么对于每个 <spanclass="math inline">\(p_i\)</span> 乘积，累加时赋上符号，若 <spanclass="math inline">\(\pi_i\)</span> 为偶数，则为正，否则为负。</p><p><span class="math display">\[\det(A)=\sum\limits_{i=1}^{n!}(-1)^{\pi_i}\prod\limits_{j=1}^{n}p_{i,j}\]</span></p><p>一些性质：</p><ul><li>转置矩阵的行列式不变。</li><li>交换任意两行（列）行列式取反。</li><li>某一行（列）乘 <span class="math inline">\(k\)</span>，行列式乘<span class="math inline">\(k\)</span>。</li><li>某一行整体加上另一行，行列式不变。</li></ul><h2 id="伴随矩阵">伴随矩阵</h2><h3 id="余子式">余子式</h3><p>矩阵 <span class="math inline">\(A\)</span> 第 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的余子式：</p><p><span class="math display">\[M_{i,j}=\det A&#39;_{i,j}\]</span></p><p>其中 <span class="math inline">\(A&#39;_{i,j}\)</span> 表示删除矩阵<span class="math inline">\(A\)</span> 第 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列后所得矩阵。</p><h3 id="代数余子式">代数余子式</h3><p>矩阵 <span class="math inline">\(A\)</span> 第 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的代数余子式：</p><p><span class="math display">\[C_{i,j}=(-1)^{i+j}M_{i,j}\]</span></p><h3 id="伴随矩阵-1">伴随矩阵</h3><p>矩阵 <span class="math inline">\(A\)</span> 的伴随矩阵 <spanclass="math inline">\(\text{adj} A\)</span> 为 <spanclass="math inline">\(A\)</span> 的余子矩阵的转置矩阵。</p><p><span class="math display">\[\text{adj} A=C^{T}\]</span></p><h3 id="可逆矩阵">可逆矩阵</h3><p>对于可逆矩阵，<span class="math inline">\(A^{-1}=\dfrac{\text{adj}A}{\det A}\)</span>。</p><p>若矩阵不可逆，则 <span class="math inline">\(\det A=0\)</span>。</p><h1 id="线性空间">线性空间</h1><p>若代数系统 <spanclass="math inline">\((V,+,\cdot,\mathbb{P})\)</span> ，其中 <spanclass="math inline">\(V\)</span> 为向量集，<spanclass="math inline">\((V,+)\)</span> 为阿贝尔群，<spanclass="math inline">\(\mathbb{P}\)</span> 为域，<spanclass="math inline">\(\cdot\)</span> 为数乘运算，满足以下条件：</p><ol type="1"><li>数乘：<span class="math inline">\(\mathbb{P}\)</span> 中元素 <spanclass="math inline">\(p\)</span> 与 <spanclass="math inline">\(V\)</span> 中元素 <spanclass="math inline">\(v\)</span> 运算结果 <spanclass="math inline">\(pv\)</span> 在 <spanclass="math inline">\(V\)</span> 中，且有意义，且满足封闭性。</li><li>数乘对向量和标量都满足加法分配律。</li><li>数乘满足结合律。</li><li>存在标量乘法单位元。</li></ol><p>则称其为线性空间。</p><h2 id="线性相关与线性无关">线性相关与线性无关</h2><p>若向量组 <span class="math inline">\(a_i \in V\)</span> 和任意标量组<span class="math inline">\(k_i\in \mathbb{P}\)</span> 满足 <spanclass="math inline">\(\sumk_ia_i=\theta\)</span>，则称这组向量线性无关，否则称线性相关。</p><p>零向量与任意向量线性相关。</p><h2 id="线性基">线性基</h2><p>线性空间 <span class="math inline">\(V\)</span>的一个极大线性无关组称为 <span class="math inline">\(V\)</span>的一组<strong>线性基</strong>，简称基。</p><p><span class="math inline">\(V\)</span> 的维数记为 <spanclass="math inline">\(\dim V\)</span>，为线性基元素个数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学数论学自闭了，感觉线性代数还可以。&lt;/p&gt;
&lt;p&gt;供自己复习用。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="http://summace.cc/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="http://summace.cc/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>KMP 算法与 border 浅记</title>
    <link href="http://summace.cc/KMP/"/>
    <id>http://summace.cc/KMP/</id>
    <published>2023-07-31T16:00:00.000Z</published>
    <updated>2023-10-03T01:59:41.304Z</updated>
    
    <content type="html"><![CDATA[<p>终于完全明白了困扰多年的 KMP 算法，果然从 border理论理解才是最好的。</p><p>因此写下本文，供自己复习。</p><span id="more"></span><h1 id="border">border</h1><p>首先给出 <span class="math inline">\(\text{border}\)</span>的定义：在字符串 <span class="math inline">\(S\)</span>中，最长的<strong>真</strong>公共前后缀。</p><p>显然，<span class="math inline">\(\text{border}\)</span> 的 <spanclass="math inline">\(\text{border}\)</span> 也是 <spanclass="math inline">\(S\)</span> 的一个 <spanclass="math inline">\(\text{border}\)</span>。</p><p>我们定义 <span class="math inline">\(\text{nxt}[i]\)</span> 为 <spanclass="math inline">\(S[1\dots i]\)</span> 的 <spanclass="math inline">\(\text{border}\)</span>，考虑如何快速求 <spanclass="math inline">\(\text{nxt}\)</span>。</p><p>假设我们现在已知 <span class="math inline">\(\text{nxt}[1\dotsn]\)</span>，想要求出 <spanclass="math inline">\(\text{nxt}[n+1]\)</span>。</p><p>考虑 <span class="math inline">\(S[n+1]\)</span> 和 <spanclass="math inline">\(S[\text{nxt}[n]+1]\)</span>是否匹配。如果匹配，那么显然。 <spanclass="math inline">\(\text{nxt}[n+1]=\text{nxt}[n]+1\)</span>，否则我们继续考虑它是否可以和<span class="math inline">\(\text{nxt}[\text{nxt}[n]]\)</span>匹配。我们一直匹配到成功即可。</p><p>这样可以均摊 <span class="math inline">\(O(n)\)</span> 求出 <spanclass="math inline">\(\text{nxt}\)</span>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&quot; &quot;</span> + S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nxt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = S.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; S[i] != S[j + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(S[i] == S[j + <span class="number">1</span>] &amp;&amp; j + <span class="number">1</span> &lt; i) nxt[i] = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="kmp">KMP</h1><p><span class="math inline">\(\text{KMP}\)</span>是用来快速匹配字符串的算法。</p><p>给定模式串 <span class="math inline">\(S\)</span>，文本串 <spanclass="math inline">\(T\)</span>，求 <spanclass="math inline">\(S\)</span> 在 <spanclass="math inline">\(T\)</span> 中所有匹配。</p><p>记 <span class="math inline">\(S\)</span> 长度为 <spanclass="math inline">\(s\)</span>，<span class="math inline">\(T\)</span>长度为 <span class="math inline">\(t\)</span>。</p><p>我们将 <span class="math inline">\(S\)</span> 和 <spanclass="math inline">\(\#\)</span> 和 <spanclass="math inline">\(T\)</span> 拼在一起，形成了 <spanclass="math inline">\(S\#T\)</span> 的新字符串。我们求出来这个字符串的<span class="math inline">\(\text{nxt}\)</span>。</p><p>之后我们从 <span class="math inline">\(s+1\)</span> 开始（即从 <spanclass="math inline">\(T\)</span> 开始）遍历 <spanclass="math inline">\(\text{nxt}\)</span>。如果 <spanclass="math inline">\(\text{nxt}[i] =s\)</span>，那么这是一个成功的匹配。</p><p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于完全明白了困扰多年的 KMP 算法，果然从 border
理论理解才是最好的。&lt;/p&gt;
&lt;p&gt;因此写下本文，供自己复习。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="字符串" scheme="http://summace.cc/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="KMP" scheme="http://summace.cc/tags/KMP/"/>
    
    <category term="border 理论" scheme="http://summace.cc/tags/border-%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>线段树浅记</title>
    <link href="http://summace.cc/Segment-Tree/"/>
    <id>http://summace.cc/Segment-Tree/</id>
    <published>2023-07-22T16:00:00.000Z</published>
    <updated>2023-10-05T08:00:33.321Z</updated>
    
    <content type="html"><![CDATA[<p>《线段树浅记~从 0 开始的线段树生活》</p><p>系统复盘了一下线段树，发现网上现有博客鲜有将线段树各种操作一步一步讲明白的，故结合自己理解写此文。</p><span id="more"></span><h1 id="线段树">线段树</h1><p>先来看一个经典问题：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 x v</code>：给 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>考虑最朴素的暴力：对于 <span class="math inline">\(1\)</span>操作，直接在数组上更改。对于每次 <span class="math inline">\(2\)</span>操作，我们暴力遍历一遍整个数组。这样单次修改复杂度是 <spanclass="math inline">\(O(1)\)</span>，但是查询复杂度是 <spanclass="math inline">\(O(n)\)</span>，最坏时间复杂度 <spanclass="math inline">\(O(nq)\)</span>，比较爆炸。</p><p>线段树作为一种基础的高级数据结构，具有单次修改、查询均为 <spanclass="math inline">\(O(\log n)\)</span>的优秀复杂度。这时候运用线段树，就比较好解决这个问题了。</p><h2 id="结构">结构</h2><p>我们先来说一下线段树的结构。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.luogu.com.cn/upload/image_hosting/gmqvut8k.png"                     alt="线段树"                 ><figcaption aria-hidden="true">线段树</figcaption></figure><p>考虑现在有一段长度为 <span class="math inline">\(5\)</span> 的区间<span class="math inline">\([1,5]\)</span>，我们递归地每次分成两半。</p><p>第一层：<span class="math inline">\([1,5]\)</span>，第二层：<spanclass="math inline">\([1,3],[4,5]\)</span>，以此类推……</p><p>现在 <span class="math inline">\(d_1\)</span> 就记录着区间 <spanclass="math inline">\([1,5]\)</span> 的信息，<spanclass="math inline">\(d_2\)</span> 记录着 <spanclass="math inline">\([1,3]\)</span>的信息，以此类推。这个信息可以是多种多样的，根据本题的题意，我们可以记录“区间和”这个信息。此时，<spanclass="math inline">\(d_1\)</span> 就表示着区间 <spanclass="math inline">\([1,5]\)</span> 的和为 <spanclass="math inline">\(60\)</span>。</p><p>显然，我们现在的 <span class="math inline">\(d\)</span>数组构成了一个二叉树型结构，<span class="math inline">\(d_1\)</span>的儿子是 <span class="math inline">\(d_2\)</span> 和 <spanclass="math inline">\(d_3\)</span>，<spanclass="math inline">\(d_2\)</span> 的儿子是 <spanclass="math inline">\(d_4\)</span> 和 <spanclass="math inline">\(d_5\)</span>。那么根据二叉树的性质，我们很容易可以知道，若父亲节点的编号是<span class="math inline">\(k\)</span>，那么它的左儿子的节点编号应该是<span class="math inline">\(2k\)</span>，右儿子的节点编号应该是 <spanclass="math inline">\(2k+1\)</span>。</p><p>这样，一颗线段树的基本结构就出来了。</p><p>考虑一下我们需要维护哪些信息？首先，区间和 <spanclass="math inline">\(sum\)</span>。其次，我们需要维护当前节点所维护区间的左右端点<span class="math inline">\(l,r\)</span>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br></pre></td></tr></table></figure></div><p>哎？你这个 <span class="math inline">\(tr\)</span> 数组怎么开了 <spanclass="math inline">\(4\)</span> 倍的空间啊？线段树节点数量不是 <spanclass="math inline">\(2n\)</span> 的吗？</p><p>我们理想的线段树形态应该是一棵满二叉树。此时，节点数量就是完美的<span class="math inline">\(2n\)</span>个了。但是有时事与愿违。我们采用的编号方法是左儿子 <spanclass="math inline">\(2k\)</span>，右儿子 <spanclass="math inline">\(2k+1\)</span>，这样当我们原区间不是 <spanclass="math inline">\(2^m\)</span> 的时候就会发生“左偏”（如上图）。</p><p>容易发现：左儿子和右儿子层数最多相差一。因此，我们线段树的节点有可能会延伸到叶子节点下面的一层，所以需要多开<span class="math inline">\(2n\)</span> 个节点，即 <spanclass="math inline">\(4n\)</span>。</p><blockquote><p>注：无特殊说明外，本文 <span class="math inline">\(\log\)</span> 均为<span class="math inline">\(\log_2\)</span>。</p></blockquote><h2 id="信息的上传">信息的上传</h2><p>然而，我们现在的线段树只是一颗线段树，跟原来的序列没有啥关系啊？</p><p>考虑这颗线段树的叶子节点。我们发现叶子节点维护的区间都只有一个数，那么这个就对应着我们原序列的值。也就是说，左右端点均为<span class="math inline">\(i\)</span> 的线段树节点，其区间和就是 <spanclass="math inline">\(a_i\)</span> 的值。</p><p>然后我们需要让整棵树都维护正确的信息，这时候就需要我们把信息由下到上地更新。我们记载的信息是区间和，那么显然，父亲节点的信息就是儿子节点信息之和，也就是说：<spanclass="math inline">\(tr[k].sum=tr[ls(k)].sum+tr[rs(k)].sum\)</span>。</p><blockquote><p>注：下文将用 <span class="math inline">\(tr\)</span> 代替 <spanclass="math inline">\(d\)</span>。</p></blockquote><p>这里的 <span class="math inline">\(ls(k) = 2k, rs(k) =2k+1\)</span>，分别表示了当前节点的左右儿子。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="comment">//常用技巧，使用#define会让你的代码更美丽</span></span><br><span class="line"><span class="comment">//根据基本的位运算常识，k&lt;&lt;1=2k, k&lt;&lt;1|1=2k+1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="建树">建树</h2><p>著名感情学家鸭子曾经说过：我们要有所建树。不建树是一个线段树题目中常见的**错误。</p><p>考虑我们是怎么讲述一颗线段树的结构的？<spanclass="math inline">\(d_1\)</span>记录着整个区间的信息，然后每次将区间分成两半，分别记录着左右两半区间的信息……</p><p>那么参照这个思想，我们就可以建树了。从 <spanclass="math inline">\(d_1\)</span>出发，依次建立左右儿子的初始信息，然后 <spanclass="math inline">\(pushup\)</span>，把下层的节点信息上传到上层。对于叶子节点，此时显然一定有<span class="math inline">\(tr[k].l=tr[k].r\)</span>，<spanclass="math inline">\(tr[k].sum=a[l]\)</span>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].l = l;</span><br><span class="line">    tr[k].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>时间复杂度显然 <span class="math inline">\(O(n)\)</span>。</p><h2 id="单点修改">单点修改</h2><p>好了，现在树也建好了，是时候干点操作相关的事情了。单点修改！</p><p>这个东西有点像二分。由于我们只修改一个点，那么我们只需要每次看看这个点在左右两半区间的那边，然后一直到叶子的时候把它修改了，再更新一下整棵树就可以了。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].l == tr[k].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">update</span>(ls, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由于我们最多跳 <span class="math inline">\(\log(n)\)</span>次，因此单点修改的时间复杂度是 <span class="math inline">\(O(\logn)\)</span> 的。</p><h2 id="区间查询">区间查询</h2><p>那么接下来解决最后一个问题：区间查询。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.luogu.com.cn/upload/image_hosting/ybjuqqrm.png"                     alt="线段树"                 ><figcaption aria-hidden="true">线段树</figcaption></figure><p>再看一眼这张图。如果我们要查询区间 <spanclass="math inline">\([2,5]\)</span>的值，那么比较理想的状态应该是什么？</p><p>应该是，我们每次找到可以被询问区间包含的<strong>极大</strong>区间，最后将所有区间的信息相加。</p><p>太抽象了？让我们具体看看。</p><p>从第一层开始：<span class="math inline">\([1,5]\)</span>的信息显然太大了，我们用不了，那么往下面找。</p><p>现在我们有区间 <span class="math inline">\([1,3]\)</span> 和 <spanclass="math inline">\([4,5]\)</span> 的信息。我们发现 <spanclass="math inline">\([2,5]\)</span> 完全包含 <spanclass="math inline">\([4,5]\)</span>，也就是说 <spanclass="math inline">\([4,5]\)</span>的信息可以被我们利用，那么就算上它的区间和。那啥叫极大呢？我们发现利用<span class="math inline">\([4,5]\)</span> 的信息显然比分别利用 <spanclass="math inline">\([4,4]\)</span> 和 <spanclass="math inline">\([5,5]\)</span>要更优。意思就是：我们能用父亲的信息，就不用儿子的信息。</p><p>继续，我们现在还差 <span class="math inline">\([2,3]\)</span>的信息没解决。由于右边已经完成了，那么我们直接在左边找就可以。第三层是<span class="math inline">\([1,2]\)</span> 和 <spanclass="math inline">\([3,3]\)</span>，其中我们可以用 <spanclass="math inline">\([3,3]\)</span> 的信息，把它加上。</p><p>然后我们继续往下找，发现了 <span class="math inline">\([1,1]\)</span>和 <span class="math inline">\([2,2]\)</span>，其中我们可以利用 <spanclass="math inline">\([2,2]\)</span> 的信息，那就把它加上。</p><p>最后，我们发现区间 <span class="math inline">\([2,5]\)</span>实际上被拆成了 <span class="math inline">\([2,2] \cup [3,3]\cup[4,5]\)</span>，我们所求的答案自然就是这几个节点的信息之和。</p><p>那么考虑一下我们应该怎么写代码：如果当前节点的区间被询问区间完全包含，那么直接加上这个区间的信息。否则，如果查询区间的左端点在左儿子内，就到左儿子内中继续查询；如果查询区间的右端点在右儿子内，就到右儿子内中继续查询。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r) <span class="keyword">return</span> tr[k].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += <span class="built_in">query</span>(ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += <span class="built_in">query</span>(rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>来分析一下时间复杂度：由于线段树只有 <spanclass="math inline">\(\log(n)\)</span> 层，那么我们也只需要询问 <spanclass="math inline">\(O(\log n)\)</span> 次，单次区间查询时间复杂度是<span class="math inline">\(O(\log n)\)</span>。</p><h2 id="区间修改与懒标记">区间修改与懒标记</h2><p>那么现在我们把这个问题进阶一下：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素加上 <spanclass="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>现在，我们由单点修改变成了区间修改。</p><p>问题在哪？我们每次修改，如果一个区间被修改区间包含，那么以它为根的整棵子树都要被修改，时间复杂度到了<span class="math inline">\(O(n)\)</span>，这是我们无法接受的。</p><p>哎？同样是涉及到区间，那为啥区间查询的复杂度很对，但是区间修改就很寄呢？</p><p>我们发现，区间查询的时候，如果一个节点被用到了，那么它的儿子就不会在被查询，因此时间复杂度可以到<span class="math inline">\(O(\logn)\)</span>。那我们能不能类比区间查询，让区间修改也这样呢？</p><p>这个时候就需要懒标记(lazy tag)出场了。</p><p>懒标记，顾名思义，是为了偷懒用的标记。</p><p>怎么偷懒呢？当我们遇到一个被修改区间完全包含的区间的时候，我们就给这个节点打上一个标记，意思是：我这个节点的后代应该被这个标记影响，但是我现在先不往下传。<del>（我知道你很急，但是你先别急）</del>到我什么时候要用到这个节点的后代的时候，我再把标记传下去。</p><p>这样的话，我们就可以保证区间修改的时间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>。</p><p>那么具体怎么实现呢？</p><p>当我们区间修改遇到一个整的区间时，我们选择仅更改当前的节点的值，并给它打上懒标记。以区间和为例，我们更改当前节点的值显然应当是<spanclass="math inline">\(v*(tr[k].r-tr[k].l+1)\)</span>，此时我们把当前节点的<span class="math inline">\(tag\)</span> 加上 <spanclass="math inline">\(v\)</span>，表示我后面的后代应当被加 <spanclass="math inline">\(v\)</span>。</p><p>然后我们想想怎么把标记下放。显然我们只需要把标记分别赋给他的两个儿子，然后把当前节点的标记清零就可以了。考虑一下，那些操作需要把标记下放？</p><p>由于需要用到后代的操作都需要下方，所以显然查询和修改都需要提前下放标记。显然，标记的下放必须在操作之前。</p><p>那么我们就可以开始写代码了。首先先单独写一个下放标记的函数<code>pushdown</code>：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[ls].tag += tr[k].tag;</span><br><span class="line">    tr[rs].tag += tr[k].tag;</span><br><span class="line">    tr[ls].sum += (tr[ls].r - tr[ls].l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    tr[rs].sum += (tr[rs].r - tr[rs].l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后我们在更新一下查询和修改的函数：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum += (tr[k].r - tr[k].l + <span class="number">1</span>) * v;</span><br><span class="line">        tr[k].tag += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[k].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += <span class="built_in">query</span>(ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += <span class="built_in">query</span>(rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="线段树提高">线段树提高</h1><p>目前我们已经解决了线段树维护区间和的问题。线段树维护区间极值也很简单，只需要在原来的代码上稍作修改即可。但是，作为十分美丽的数据结构，线段树可以维护的东西远不止这些。接下来让我们看看线段树更为进阶的用法。</p><h2 id="维护区间平方和">维护区间平方和</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素加上 <spanclass="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的平方和，即 <spanclass="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这时候就需要我们思考，线段树要维护某些东西具体需要改什么。</p><p>原本有一段需要修改的区间 <span class="math inline">\(a_l, a_{l+1},..., a_r\)</span>。我们需要维护的东西是 <spanclass="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>。</p><p>考虑我们现在对这段东西整体加上 <spanclass="math inline">\(v\)</span>，那么我们的答案就变成了 <spanclass="math inline">\(\sum\limits_{i=l}^{r}(a_i+v)^2\)</span>。</p><p>运用我们初中就学过的完全平方公式：</p><p><span class="math inline">\(\sum\limits_{i=l}^{r}(a_i+v)^2 =\sum\limits_{i=l}^{r}(a_i^2+2a_iv+v^2) =\sum\limits_{i=l}^{r}a_i^2+2v\sum\limits_{i=l}^{r}a_i+(r-l+1)v^2\)</span></p><p>我们发现前面的 <spanclass="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>就是我们原先的值，而最后的 <spanclass="math inline">\((r-l+1)v^2\)</span> 可以直接算出来，中间的 <spanclass="math inline">\(2v\sum\limits_{i=l}^{r}a_i\)</span>只需要多维护一个区间和就可以了。</p><p>那么，这道题我们就需要维护两个值：区间平方和、区间和。修改的时候按照公式中的修改即可。</p><p>思考：区间方差。</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素加上 <spanclass="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的方差。</p><p>方差：<spanclass="math inline">\(\sigma^2=\dfrac{1}{n}\sum\limits_{i=1}^{n}(x_i-\overlinex)^2\)</span></p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><h2 id="区间乘与区间加">区间乘与区间加</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素加上 <spanclass="math inline">\(v\)</span>；</p><p><code>2 l r v</code>：给区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素乘上 <spanclass="math inline">\(v\)</span>；</p><p><code>3 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这不好做？我直接开两个 <spanclass="math inline">\(tag\)</span>，分别维护加法和乘法懒标记，结果一合并不就行了！</p><p>等等，你先别急。你乘法和加法分别统计真的对吗？</p><p>例如，我们当前的数是 <spanclass="math inline">\(2\)</span>，对当前的数分别 <spanclass="math inline">\(\times 3,+2,\times 4\)</span>，答案应当是 <spanclass="math inline">\((2\times 3+2)\times4=32\)</span>。但是如果我们分别计算 <spanclass="math inline">\(multitag=3\times4=12,plustag=2\)</span>，答案就会变成 <spanclass="math inline">\(2\times12+2=26\)</span> 或者 <spanclass="math inline">\((2+2)\times 12=48\)</span>。</p><p>这是因为我们加法和乘法之间是有运算顺序的，因此我们不能简单地直接计算。</p><p>那有没有什么办法呢？当然有！我们在小学就学过一个伟大的东西，叫做乘法的分配律！</p><p>假设我们当前的节点有 <span class="math inline">\(multitag\)</span> 和<span class="math inline">\(plustag\)</span> 两个 <spanclass="math inline">\(tag\)</span>，那么当前节点的值应当是 <spanclass="math inline">\((x\timesmultitag+plustag)\)</span>，现在对这个节点进行 <spanclass="math inline">\(\times v\)</span> 的操作就会变成 <spanclass="math inline">\((x\times multitag+plustag)\times v=x\timesmultitag\times v + plustag\times v\)</span>。</p><p>于是，我们正常维护 <spanclass="math inline">\(multitag\)</span>，并且额外更新 <spanclass="math inline">\(plustag\)</span>，这样就可以了。</p><h2 id="区间开根">区间开根</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：令区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素 <spanclass="math inline">\(x\)</span> 变成 <spanclass="math inline">\(\lfloor\sqrt{x}\rfloor\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5,1\leq a_i\leq10^{18}\)</span>。</p></blockquote><p>有没有发现这次的题目多了一个数据范围？</p><p>既然 <span class="math inline">\(a_i\leq10^{18}\)</span>，我们发现<strong>至多进行 <spanclass="math inline">\(6\)</span> 次 <spanclass="math inline">\(1\)</span> 操作</strong>，当前的数就会变成 <spanclass="math inline">\(1\)</span>。变成 <spanclass="math inline">\(1\)</span> 之后自然之后的操作都是无效的操作。</p><p>那么，我们在更改的时候可以暴力更改当前区间的数，并记录当前区间的最大值。如果最大值小于等于<spanclass="math inline">\(1\)</span>，那么就可以停止这个区间的更改了。</p><p>这样，查询的复杂度是不变的单次 <span class="math inline">\(O(\logn)\)</span>，我们来分析一下修改的时间复杂度。</p><p>不将值域局限在 <span class="math inline">\(10^{18}\)</span>内，我们考虑一个数会被更改多少次：</p><p><spanclass="math inline">\(a^{\left(\frac{1}{2}\right)^x}&lt;2\)</span>。</p><p>这是一个两层不等式，想得到 <span class="math inline">\(x\)</span>我们需要取两次对数，因此我们每个数最多会被更改 <spanclass="math inline">\(O(\log\log a)\)</span> （<spanclass="math inline">\(a\)</span> 为 <spanclass="math inline">\(a_i\)</span>的最大值）次。考虑我们暴力更改就相当于是单点修改，那么每对一个元素修改的复杂度就是<span class="math inline">\(O(\log n)\)</span> 的。我们一共有 <spanclass="math inline">\(n\)</span> 个元素，每个元素修改一次的复杂度是<span class="math inline">\(O(\log n)\)</span>，每个元素最多会被更改<span class="math inline">\(O(\log\log a)\)</span>次，那么，总的时间复杂度就是 <span class="math inline">\(O(n\logn\log\log a)\)</span>。单次的复杂度均摊是 <spanclass="math inline">\(O(\log n\log\log a)\)</span>的。可以通过本题。</p><h2 id="维护前前缀和">维护前前缀和</h2><blockquote><p>前缀和：<spanclass="math inline">\(S_i=\sum\limits_{k=1}^{i}a_k\)</span>；</p><p>前前缀和：<spanclass="math inline">\(SS_i=\sum\limits_{k=1}^{i}S_i\)</span>。</p><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 x v</code>：将 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>；</p><p><code>2 x</code>：查询 <spanclass="math inline">\(SS_x\)</span>。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>我们现在有三个数组：原数组 <spanclass="math inline">\(a\)</span>，前缀和数组 <spanclass="math inline">\(S\)</span>，前前缀和数组 <spanclass="math inline">\(SS\)</span>。</p><p>对于 <span class="math inline">\(1\)</span> 操作，我们要用到的是<span class="math inline">\(a\)</span>。对于 <spanclass="math inline">\(2\)</span> 操作，我们要用到的是 <spanclass="math inline">\(SS\)</span>。那么，我们为什么不选择一个中间商<del>赚个差价</del>方便我们对两边都能维护到呢？</p><p>因此，我们可以维护前缀和数组 <spanclass="math inline">\(S\)</span>，对于操作 <spanclass="math inline">\(2\)</span>，答案即是从 <spanclass="math inline">\(1\)</span> 开始的区间和。对于操作 <spanclass="math inline">\(1\)</span>，我们只需要让从当前位置开始到 <spanclass="math inline">\(n\)</span> 的区间加上 <spanclass="math inline">\(v\)</span> 即可。</p><h2 id="区间加等差数列">区间加等差数列</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 l r d k</code>：令区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素 <spanclass="math inline">\(a_i\)</span> 加上以 <spanclass="math inline">\(d\)</span> 为首项、<spanclass="math inline">\(k\)</span> 为公差的等差数列 <spanclass="math inline">\(\{c\}\)</span> 的 <spanclass="math inline">\(c_i\)</span>。 <code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。 <spanclass="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>区间加的数不是同一个数，怎么办？</p><p>考虑一下等差数列的性质。我们没有必要知道每一个数是什么，我们只需要知道首项和公差，就可以推出数列的任意一项以及数列的和。那我们不妨用线段树维护加的等差数列的首项和公差。</p><h2 id="维护区间最大子段和">维护区间最大子段和</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 x v</code>：将 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 内的最大子段和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这咋做？</p><p>线段树保证复杂度的关键一步是要保证可以快速、正确地合并。这题单点修改是容易的，关键在于如何让信息快速合并。</p><p>我们思考一下合并区间最大子段和时，可能有哪些情况：</p><ol type="1"><li>全部在左半区间。</li><li>全部在右半区间。</li><li>横跨左右区间。</li></ol><p>我们显然是要维护当前区间的最大子段和的。对于 <spanclass="math inline">\(1\)</span> 情况和 <spanclass="math inline">\(2\)</span> 情况，直接合并就可以了。关键是 <spanclass="math inline">\(3\)</span> 情况该如何合并。</p><p>我们考虑横跨左右区间实际上就是左半区间右端点开始的区间最大子段和，和右半区间左端点开始的区间最大子段和合并。那我们不妨对每个节点多维护两个信息：以右端点开始的区间最大子段和（记作<spanclass="math inline">\(S[k]_r\)</span>），和以左端点开始的区间最大子段和（记作<spanclass="math inline">\(S[k]_l\)</span>）。这样，我们就可以做到快速算出区间最大子段和了。</p><p>不过问题在于，我们新维护的这两个值也需要考虑合并之后该怎么办。只考虑<span class="math inline">\(S[k]_l\)</span>，这个时候有两种情况：</p><ol type="1"><li><span class="math inline">\(S[k]_l\)</span> 是 <spanclass="math inline">\(S[ls(k)]_l\)</span>。</li><li><span class="math inline">\(S[k]_l\)</span>的右端点跨到了右区间，答案变成 <spanclass="math inline">\(sum_k+S[rs]_l\)</span>。</li></ol><p>而且只有这两种情况。（思考一下，为什么？）</p><p>现在所有问题已经解决，我们就可以快速维护了。</p><p>思考：<span class="math inline">\(1\)</span> 操作改为<ahref="#ei-的第六分块">区间加</a>怎么做？</p><h1 id="信息的本质">信息的本质</h1><p>我们发现，线段树可以维护许多东西：区间和、区间极值……通过一些手法，我们也可以维护诸如区间最大子段和的东西。</p><p>那么，究竟什么样的信息才可以被维护呢？</p><p>首先，这个信息必须是<strong>可被快速合并的</strong>。其次，这个信息必须<strong>满足结合律</strong>。因为我们在合并的时候其实是并不关心信息之间的顺序的，这就要求其必须满足结合律。那么可以看出，这些信息实际上构成了一个半群。</p><p>以上情况都是在单点修改的时候。那么区间修改呢？为什么刚刚线段树维护区间最大子段和没办法区间修改呢？</p><p>在区间修改的时候，为了保证线段树复杂度的正确性，我们势必要引入标记。那么，这个标记也必须满足一定的性质。</p><p>首先，这个标记必须是<strong>可被快速合并的</strong>。其次，这个标记必须<strong>满足结合律</strong>。第三，这个标记必须<strong>可被快速作用到信息上</strong>。可以看出，标记实际上构成了一个幺半群。</p><p>因此，我们在考虑线段树维护某些东西的时候，一方面要考虑如何维护信息，另一方面要考虑如何维护标记。</p><p>有关更多这部分的内容，可以看<a class="link"  href="https://_rqy.blog.uoj.ac/blog/8105" >_rqy的博客</a>。</p><h1 id="线段树的本质">线段树的本质</h1><p>不同的人对线段树有不同的理解，这里分享一些我的个人看法。</p><p>所谓线段树，实际上是针对原来的序列，递归地建立新结点，维护若干个原来节点的信息，当询问时，我们就可以直接采用某些节点的信息，以达到快速查询的目的。</p><p>照这么说，我们其实还可以写出 <span class="math inline">\(3\)</span>叉线段树、<span class="math inline">\(4\)</span> 叉线段树、<spanclass="math inline">\(\sqrt{n}\)</span> 叉线段树……</p><p><span class="math inline">\(\sqrt{n}\)</span> 叉？分块？</p><p>很相类似。狭义上的数据结构本质上都是对序列进行划分，线段树是划分为<span class="math inline">\(O(\log n)\)</span> 个区间，分块则是分成<span class="math inline">\(O(\sqrt{n})\)</span> 个区间。</p><p>不过线段树和分块仍有一些本质上的区别：线段树对于数据，更倾向形成一种树状结构，而分块更倾向于形成线性结构。</p><h1 id="线段树的常用技巧">线段树的常用技巧</h1><h2 id="动态开点">动态开点</h2><p>有的时候，面对庞大的数据范围，我们没办法开如此大的空间。这个时候，我们就需要动态开点线段树了。</p><p>动态开点线段树，顾名思义，即对于整颗线段树，我们并不将它直接建出来，而是到用到某个节点了在进行新建。</p><p>因此，我们就直接不建树，在 update 和 query的时候，如果当前没有节点，那么我们就新建一个。</p><p>不过，显然此时我们再沿用之前 <span class="math inline">\(2k\)</span>为左儿子编号，<span class="math inline">\(2k+1\)</span>为右儿子编号的做法不再合适。我们需要额外记录当前节点左右儿子的编号。</p><p>考虑到一次操作最多会访问 <span class="math inline">\(O(\logn)\)</span> 个节点，那么总空间复杂度为 <spanclass="math inline">\(O(q\log n)\)</span>。</p><p>考虑到一颗线段树的节点数是 <spanclass="math inline">\(2n-1\)</span>，因此动态开点时只需开 <spanclass="math inline">\(2\)</span> 倍空间即可。</p><p>因此我们只需要对应更改一下 pushdown 和 update 的代码即可。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg_Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum, tag;</span><br><span class="line">    <span class="type">int</span> lson, rson;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    tr[k].tag += v;</span><br><span class="line">    tr[k].sum += v * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f</span>(ls, l, mid, tr[k].tag);</span><br><span class="line">    <span class="built_in">f</span>(rs, mid + <span class="number">1</span>, r, tr[k].tag);</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f</span>(k, l, r, v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid+ <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们初始时需要建立第一个节点。值得注意的是：update 和 f 函数中的<span class="math inline">\(k\)</span>必须加取地址符，这是为了使儿子信息在父亲节点中被更新。</p><h2 id="标记永久化">标记永久化</h2><p>当数据范围较大、或者 pushdown、pushup代价过高时，可以考虑标记永久化。</p><p>我们知道线段树一个重要的部分是懒标记，而 pushdown就是为了下放标记而存在的。而标记永久化则是不进行标记的下放，直接永久记录在该节点上。当我们需要访问某节点时，叠加所有在它到根节点路径的标记即可。</p><p>然而值得注意的是，并不是所有的标记都能永久化。除了要满足标记本身需要满足的条件之外，还需要满足<strong>交换律</strong>。</p><p>标记永久化并没有时空复杂度的提升，但是可以优化时间常数。某些情况下，标记下放可能会比较麻烦，这时使用标记永久化不失为一个好的选择。</p><p>标记永久化可以保证了当前节点子树的更新，但是与之相对的，当前节点到根我们需要额外维护：从根到该节点，每次取当前节点维护区间与修改区间的交集，进行更新。</p><p>下面是动态开点+标记永久化的代码：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].tag += v);</span><br><span class="line">    tr[k].sum += v * (<span class="built_in">min</span>(R, r) - <span class="built_in">max</span>(L, l) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[k].sum +(r - l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    <span class="type">int</span> res = (<span class="built_in">min</span>(R, r) - <span class="built_in">max</span>(L, l) + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res += <span class="built_in">query</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res += <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r , L, R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="线段树二分">线段树二分</h2><p>线段树本身看起来就是个很二分的结构。那么我们不妨直接利用这个结构特性来进行二分。</p><p>类比于我们在线段树基本操作中的单点修改，我们发现这个其实就是一个不断二分的过程。</p><p>这样的时间复杂度可以维持在 <span class="math inline">\(O(\logn)\)</span>。</p><h1 id="线段树进阶">线段树进阶</h1><h2 id="值域线段树">值域线段树</h2><p>还是先来看一个问题：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次询问。</p><p>每次询问给定 <span class="math inline">\(k\)</span>，求序列第 <spanclass="math inline">\(k\)</span> 小。</p><p><span class="math inline">\(1\leq n,q\leq 10^5,1\leq a_i\leq10^9\)</span>。</p></blockquote><p>想要解决这个问题，我们需要用到“值域线段树”。</p><p>值域线段树，也被称作“权值线段树”，但是值域线段树这个名字更加严谨一点。</p><p>佛说：诞生了数组之后，就诞生了桶。同样，诞生了线段树之后，就诞生了值域线段树。</p><p>具体来说，值域线段树也是一种线段树，但是它维护的范围从 <spanclass="math inline">\(n\)</span> 变成了整个值域（因此需要<ahref="#动态开点">动态开点</a>），而维护的东西则是一段区间内数的出现次数。形象化地说，就是在桶上建立了一颗线段树。</p><p>那么想想如何查询第 <span class="math inline">\(k\)</span>小。通过刚才线段树二分的思想，我们每次将当前节点左右儿子的值与 <spanclass="math inline">\(k\)</span>比较，然后二分地寻找应该存在的地方。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.luogu.com.cn/upload/image_hosting/zzzzpqlt.png"                     alt="值域线段树"                 ><figcaption aria-hidden="true">值域线段树</figcaption></figure><p>如图，对于序列 <spanclass="math inline">\(\{1,2,3,4,2,3,4,3,4,4\}\)</span>，我们可以建立如上值域线段树。例如我们现在要查询<spanclass="math inline">\(k=5\)</span>，红色的节点和边就是我们查询的路径。值得注意的是，我们的<span class="math inline">\(k\)</span> 应该是在当前节点区间内的 <spanclass="math inline">\(k\)</span>，这意味着如果我们递归到了右子树，需要减去左子树的值。</p><p>类似地，值域线段树也支持单点修改，以及查询某个数出现个数等等。</p><p>注意到，普通值域线段树只支持全局查询。若需要区间查询，则需要对值域线段树进行可持久化，即<ahref="#主席树">主席树</a>。</p><h2 id="扫描线">扫描线</h2><p>具体来说，扫描线是一种思想，而不是一种数据结构。</p><p>扫描线比较经典的问题就是求矩形面积并了。</p><blockquote><p>给定若干四边平行于坐标轴的矩形。</p><p>求它们的面积并（重合部分只算一次）。</p><p><span class="math inline">\(n\leq 10^5,|x_i|,|y_i|\leq10^9\)</span>。</p></blockquote><h3 id="线段树维护矩形面积并">线段树维护矩形面积并</h3><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/08/31/qVf7EtHWwBbjXo2.gif"                     alt="扫描线"                 ><figcaption aria-hidden="true">扫描线</figcaption></figure><p>如上图所示，我们将蓝绿两个矩形通过虚线分割成了三块。显然，答案应该是三段的线段长度<span class="math inline">\(len\)</span> 分别乘上这段竖着的长度之和<span class="math inline">\(sum\)</span>。</p><p>前者我们已经知道了，我们只需要快速维护后者即可。可以用线段树维护。</p><p>具体来说，我们通过一根红色的“扫描线”从下向上扫。记矩形的下边界为<span class="math inline">\(+1\)</span>，上边界为 <spanclass="math inline">\(-1\)</span>，同时维护 <spanclass="math inline">\(sum\)</span> 即可。</p><p>由于范围很大，因此需要离散化。如果你不想离散化，还可以使用动态开点+标记永久化，代码会更短。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].tag) tr[k].sum = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> tr[k].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].tag += v, <span class="built_in">pushup</span>(k, l, r));</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="本质">本质</h3><p>我们来思考一下扫描线的本质：考虑一下我们刚才引入的这条“扫描线”在干什么？在枚举。而我们为了达到同时枚举<span class="math inline">\(x,y\)</span> 的目的，在扫描 <spanclass="math inline">\(y\)</span> 的同时，快速更新 <spanclass="math inline">\(x\)</span> 的贡献。这就是扫描线思想。</p><p>也就是说，对于 <span class="math inline">\((x,y)\)</span>的枚举，我们可以枚举其中一维，并同时通过数据结构快速维护另一维，以求出答案。</p><h2 id="李超线段树">李超线段树</h2><blockquote><p>要求在平面直角坐标系下维护两个操作：</p><ol type="1"><li><p>在平面上加入一条线段。记第 <span class="math inline">\(i\)</span>条被插入的线段的标号为 <span class="math inline">\(i\)</span>；</p></li><li><p>给定一个数 <span class="math inline">\(k\)</span>，询问与直线<span class="math inline">\(x = k\)</span>相交的线段中，交点纵坐标最大的线段的最小编号。</p></li></ol><p>强制在线。<span class="math inline">\(n\leq 10^5\)</span>。</p></blockquote><p>这个问题普通线段树无法解决，这个时候，李超线段树就派上用场了。李超树由浙江学军中学的李超发明，用于维护这样一类普通线段树无法维护的问题。</p><p>李超线段树维护 <span class="math inline">\(x=mid\)</span>时最大的线段信息。记我们现在的最优线段为 <spanclass="math inline">\(l\)</span>，新加入的线段（完全覆盖此区间）为 <spanclass="math inline">\(l&#39;\)</span>。那么，我们将 <spanclass="math inline">\(l\)</span> 与 <spanclass="math inline">\(l&#39;\)</span> 比较，若 <spanclass="math inline">\(l&#39;\)</span> 在 <spanclass="math inline">\(mid\)</span> 处更优，则交换 <spanclass="math inline">\(l\)</span> 与 <spanclass="math inline">\(l&#39;\)</span>。</p><p>接下来，对于 <span class="math inline">\(l&#39;\)</span> 在 <spanclass="math inline">\(mid\)</span> 处不比 <spanclass="math inline">\(l\)</span> 优的情况，有下列几种：</p><ol type="1"><li>在左端点 <span class="math inline">\(l&#39;\)</span> 优于 <spanclass="math inline">\(l\)</span>，则一定在左区间中产生交点，递归左子树。</li><li>在右端点 <span class="math inline">\(l&#39;\)</span> 优于 <spanclass="math inline">\(l\)</span>，则一定在右区间中产生交点，递归右子树。</li><li>在左右端点均不优，则不需要修改。</li></ol><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/01/guCdZAKXMOS3ahG.png"                     alt="李超线段树"                 ><figcaption aria-hidden="true">李超线段树</figcaption></figure><p>如上图，蓝线是我们的原来最优线段 <spanclass="math inline">\(l\)</span>，红线、绿线、紫线依次表示三种情况。</p><p>以红线为例：在 <span class="math inline">\(L\)</span> 时，<spanclass="math inline">\(l&#39;_L&gt;l_L\)</span>，说明 <spanclass="math inline">\(l\)</span> 和 <spanclass="math inline">\(l&#39;\)</span> 一定在 <spanclass="math inline">\([L,mid]\)</span> 有交点，那么我们就递归 <spanclass="math inline">\([L,mid]\)</span> 的区间。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x - y &gt; eps) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y - x &gt; eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> dis)</span></span>&#123;<span class="keyword">return</span> a[k].b + a[k].k * dis;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;v = tr[k], mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> xmid = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, mid), <span class="built_in">calc</span>(v, mid));</span><br><span class="line">    <span class="keyword">if</span>(xmid == <span class="number">1</span> || (!xmid &amp;&amp; u &lt; v)) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="type">int</span> xl = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, l), <span class="built_in">calc</span>(v, l)), xr = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, r), <span class="built_in">calc</span>(v, r));</span><br><span class="line">    <span class="keyword">if</span>(xl == <span class="number">1</span> || (!xl &amp;&amp; u &lt; v)) <span class="built_in">modify</span>(ls, l, mid, u);</span><br><span class="line">    <span class="keyword">if</span>(xr == <span class="number">1</span> || (!xr &amp;&amp; u &lt; v)) <span class="built_in">modify</span>(rs, mid + <span class="number">1</span>, r, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)<span class="built_in">modify</span>(k, l, r, u);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, u);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查询 <span class="math inline">\(x\)</span> 时，从根节点走到 <spanclass="math inline">\([x,x]\)</span> 的所有最优线段在 <spanclass="math inline">\(x\)</span>处的极值即为答案，类似于标记永久化。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pdi <span class="title">pmax</span><span class="params">(pdi x, pdi y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.fi, y.fi) == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.fi, y.fi) == <span class="number">-1</span>) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.se &lt; y.se ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pdi <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; x || x &gt; r) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> res = <span class="built_in">calc</span>(tr[k], x);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> &#123;res, tr[k]&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pmax</span>(&#123;res, tr[k]&#125;, <span class="built_in">pmax</span>(<span class="built_in">query</span>(ls, l, mid, x), <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, x)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="zkw-线段树">zkw 线段树</h2><p>zkw线段树，即非递归式线段树，由张昆玮发明的一种更加快速、方便、易写的线段树。</p><h3 id="结构-1">结构</h3><p>我们将线段树开成<strong>满二叉树</strong>。容易发现这样一些性质：</p><ol type="1"><li>记当前节点编号为 <spanclass="math inline">\(k\)</span>，则左儿子编号为 <spanclass="math inline">\(k&lt;&lt;1\)</span>，右儿子编号为 <spanclass="math inline">\(k&lt;&lt;1|1\)</span>。反之，父亲节点编号为 <spanclass="math inline">\(k&gt;&gt;1\)</span>。</li><li>前 <span class="math inline">\(n\)</span> 层节点数为 <spanclass="math inline">\(2^n-1\)</span>，第 <spanclass="math inline">\(n\)</span> 层节点数为 <spanclass="math inline">\(2^{n-1}\)</span>。</li><li>叶子是一段连续的编号，且与原序列可一一对应。</li></ol><p>一反之前线段树自上向下递归的方式，zkw线段树一般采用从叶子向根节点的非递归方式。</p><h3 id="建树-1">建树</h3><p>根据刚才的性质，我们只需要把原序列填到这段叶子序列上即可。第一个叶子节点的编号可以<span class="math inline">\(O(\log n)\)</span> 地求出。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(N = <span class="number">1</span>; N &lt;= n + <span class="number">1</span>; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tr[N + i] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) tr[i] = tr[i &lt;&lt; <span class="number">1</span>] + tr[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中，<span class="math inline">\(N\)</span> 为非叶子结点的个数。</p><h3 id="单点修改区间查询">单点修改、区间查询</h3><p>很简单，我们只需要找到对应的叶子节点，一路走到根节点修改即可。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(k += N; k; k &gt;&gt;= <span class="number">1</span>) tr[k] += v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>实际代码写起来只有一行，非常简短。</p><p>接下来思考区间查询。从叶子节点向上，我们怎么实现区间查询呢？</p><p>这里有一个非常巧妙的思想：从我们当前要查询的叶子区间的左右两个节点分别记一个<span class="math inline">\(l,r\)</span>值，然后不断向父亲节点跳，直到其父亲节点为同一个点为止。</p><p>在跳的过程中，若 <span class="math inline">\(l\)</span>为左儿子，则计算右儿子的贡献；若 <span class="math inline">\(r\)</span>为右儿子，则记录左儿子的贡献。</p><p>简单证明一下这么做的正确性：</p><p>会被计算贡献的只有 <span class="math inline">\((l,r)\)</span>的部分。在向上跳的过程中，<span class="math inline">\((l,r)\)</span>间显然不会出现不被计算的情况。<span class="math inline">\(l\)</span>若为左儿子，则其兄弟节点一定在 <spanclass="math inline">\((l,r)\)</span>中，否则其右侧的点一定会被上一层计算到。而线段树需要计算的节点显然只会在最两边，因此这样计算是正确的。</p><p>那么我们可以写出如下代码：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = N + l - <span class="number">1</span>, r = N + r + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(~l &amp; <span class="number">1</span>) ans += tr[l ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(r &amp; <span class="number">1</span>) ans += tr[r ^ <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中用到的位运算：</p><ol type="1"><li><code>l ^ r ^ 1</code>：若 <span class="math inline">\(l,r\)</span>互为兄弟，则一定为 <span class="math inline">\(2k\)</span> 与 <spanclass="math inline">\(2k+1\)</span>，其异或值 <spanclass="math inline">\(1\)</span>。</li><li><code>l &gt;&gt;= 1</code>：跳父节点。<code>r &gt;&gt;= 1</code>同理。</li><li><code>~l &amp; 1</code>：若 <span class="math inline">\(l\)</span>为左儿子，则末尾为 <span class="math inline">\(0\)</span>，否则为 <spanclass="math inline">\(1\)</span>，将末尾取反后再按位与 <spanclass="math inline">\(1\)</span>即可判断是否为左儿子。<code>r &amp; 1</code> 同理。</li></ol><h3 id="区间修改区间查询">区间修改、区间查询</h3><p>区间修改，就势必要打标记。如果我们不能下放标记，那该怎么办呢？</p><p><a href="#标记永久化">标记永久化</a>！</p><p>因此区间修改、区间查询的代码可以这么写：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> numl = <span class="number">0</span>, numr = <span class="number">0</span>, num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = N + l - <span class="number">1</span>, r = N + r + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, num &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[l] += v * numl, tr[r] += v * numr;</span><br><span class="line">        <span class="keyword">if</span>(~l &amp; <span class="number">1</span>) tag[l ^ <span class="number">1</span>] += v, tr[l ^ <span class="number">1</span>] += v * num, numl += num;</span><br><span class="line">        <span class="keyword">if</span>(r &amp; <span class="number">1</span>) tag[r ^ <span class="number">1</span>] += v, tr[r ^ <span class="number">1</span>] += v * num, numr += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; l; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) tr[l] += v * numl, tr[r] += v * numr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> numl = <span class="number">0</span>, numr = <span class="number">0</span>, num = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = N + l - <span class="number">1</span>, r = N + r + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, num &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[l]) ans += tag[l] * numl;</span><br><span class="line">        <span class="keyword">if</span>(tag[r]) ans += tag[r] * numr;</span><br><span class="line">        <span class="keyword">if</span>(~l &amp; <span class="number">1</span>) ans += tr[l ^ <span class="number">1</span>], numl += num;</span><br><span class="line">        <span class="keyword">if</span>(r &amp; <span class="number">1</span>) ans += tr[r ^ <span class="number">1</span>], numr += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; l; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) ans += tag[l] * numl, ans += tag[r] * numr;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="多线段树操作">多线段树操作</h1><h2 id="线段树合并">线段树合并</h2><p>线段树合并，顾名思义，将两颗线段树合并为一颗新的线段树。</p><p>线段树合并其实极为暴力。一般来说，对于两颗动态开点的值域线段树，我们可以从<span class="math inline">\(1\)</span>开始递归合并。若当前节点一颗为空，另一颗不为空，则直接返回不为空的节点。若递归到叶子节点，直接合并。最后更新即可。</p><p>时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p><p>例如，对于将两颗值域线段树按加法合并，可以这么写：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(k) tr[k].lson</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(k) tr[k].rson</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b) <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[a].val += t[b].val;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ls</span>(a) = <span class="built_in">merge</span>(<span class="built_in">ls</span>(a), <span class="built_in">ls</span>(b), l, mid);</span><br><span class="line">    <span class="built_in">rs</span>(a) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(a), <span class="built_in">rs</span>(b), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当然，你也可以选择新开一颗线段树合并进去。优点是不会破坏原来线段树的结构，缺点是需要较大的空间。</p><h2 id="线段树分裂">线段树分裂</h2><p>线段树分裂是线段树合并的逆操作。</p><p>类似于 FHQ-Treap。先挖个坑。</p><h1 id="主席树">主席树</h1><h2 id="简介">简介</h2><p>主席树，全称可持久化值域线段树，因其发明者黄嘉泰名字首字母与某位历史上的主席相同，因此称为主席树。</p><p>主席树一般用于解决<strong>静态</strong>区间第 <spanclass="math inline">\(k\)</span> 小问题。</p><h2 id="结构-2">结构</h2><p>如果是全局第 <span class="math inline">\(k\)</span>小问题，那么我们显然可以用<a href="#值域线段树">值域线段树</a>完成。</p><p>值域线段树维护的是区间内数字出现次数。这个是一个可减信息。那么运用前缀和的思想，我们分别建立出维护区间<span class="math inline">\([1,i]\)</span> 的值域线段树 <spanclass="math inline">\(T_i\)</span>，最后将查询到的信息相减不就好了？</p><p>等等。一颗线段树的空间复杂度就是 <span class="math inline">\(O(n\logn)\)</span> 的了，建 <span class="math inline">\(n\)</span>颗岂不是炸飞了？</p><p>我们考虑能否在建立 <span class="math inline">\(T_i\)</span>的时候充分利用 <span class="math inline">\(T_{i-1}\)</span> 的信息。由于<span class="math inline">\(T_{i-1}\rightarrow T_i\)</span>实际上相当于单点修改，因此我们只会影响到 <spanclass="math inline">\(O(\log n)\)</span> 个节点，只需要把这 <spanclass="math inline">\(O(\log n)\)</span> 个节点多开出来就可以了。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/01/3XampzrlZA4jKqN.jpg"                     alt="主席树"                 ><figcaption aria-hidden="true">主席树</figcaption></figure><p>过于抽象？来看张图。</p><p>在这张图中，黑色节点与蓝色节点共同构成了 <spanclass="math inline">\(T_{i-1}\)</span>，黑色节点与红色节点共同构成了<spanclass="math inline">\(T_i\)</span>。一条红色箭头代表了该蓝色节点被影响后，重建出来的红色节点。如果我们忽视所有的虚线，那么得到的就是新线段树。</p><p>如果你的空间想象能力足够强大，那么你可以这么理解：线段树通常被画为二维平面的图像。而不同的版本意味着我们再引入一条垂直于平面的坐标轴“版本轴”，或者“时间轴”。对于影响到的节点，我们直接在新的版本平面内建立出来，而对于还可以利用的节点，我们连接向上一个版本平面的节点。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/01/1WbXFMpIDqfTS47.png"                     alt="立体主席树1"                 ><figcaption aria-hidden="true">立体主席树1</figcaption></figure><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/01/8TLzMn56NGHDpa9.png"                     alt="立体主席树2"                 ><figcaption aria-hidden="true">立体主席树2</figcaption></figure><h2 id="操作">操作</h2><p>查询的时候，我们在两颗线段树上分别查询就可以了，这个没有太大的问题。同样，单点修改也没有太大的问题。</p><p>那么，我们可以写出如下代码；</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lson, rson;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt[MAXN &lt;&lt; <span class="number">5</span>], cnt; <span class="comment">//rt 表示每个版本的根</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(k), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(k), mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nk = ++cnt;</span><br><span class="line">    tr[nk] = tr[k], tr[nk].val++; <span class="comment">//建立新的节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> nk;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= mid) <span class="built_in">ls</span>(nk) = <span class="built_in">update</span>(<span class="built_in">ls</span>(nk), l, mid, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">rs</span>(nk) = <span class="built_in">update</span>(<span class="built_in">rs</span>(nk), mid + <span class="number">1</span>, r, v);</span><br><span class="line">    <span class="keyword">return</span> nk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x,y 分别表示两个版本的根节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = tr[<span class="built_in">ls</span>(y)].val - tr[<span class="built_in">ls</span>(x)].val;</span><br><span class="line">    <span class="keyword">if</span>(num &gt;= v) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(x), <span class="built_in">ls</span>(y), l, mid, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(x), <span class="built_in">rs</span>(y), mid + <span class="number">1</span>, r, v - num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="区间修改">区间修改</h2><p>对于一颗普通的可持久化线段树，如果我们要区间修改，貌似还有些麻烦。</p><p>保证线段树复杂度正确性的一个重要部分是懒惰标记 <spanclass="math inline">\(tag\)</span>。但是当一个节点被多个版本的父亲公用，就出现了问题：如果我们直接将标记打到儿子节点，那么多个版本就会受到影响，正确性是错的。</p><p>面对这种问题，一般有两种方法：</p><p>第一种：在 pushdown的时候，如果要下放的节点不在当前版本，那就在当前版本新建节点。由于每次至多新建两个节点，因此时间复杂度仍然是<span class="math inline">\(O(\log n)\)</span>；</p><p>第二种：运用标记永久化的思想，不进行标记下放。</p><p>一般来说，第二种更加方便、好写，但也有部分无法处理的情况。如果使用第一种方法，则update 和 query 时都要 pushdown 新建节点。</p><p>至此，线段树基本内容已经处理完毕。</p><h1 id="线段树再进阶">线段树再进阶</h1><h2 id="吉司机线段树">吉司机线段树</h2><p>吉司机线段树（Segment Tree Beats!）。</p><p>我不会。</p><h2 id="kinetic-tournament-tree">Kinetic Tournament Tree</h2><p>势能竞赛树（我瞎翻译的），简称KTT，是一类求解下述特殊问题的线段树变种：</p><blockquote><p>给定 <spanclass="math inline">\(\mathbb{R}\rightarrow\mathbb{R}\)</span>上的一次函数序列 <spanclass="math inline">\(\{f_n\},f_i=k_ix+b_i\)</span>，以及一个自变量序列<span class="math inline">\(\{x_n\}\)</span>，有以下两种操作：</p><ol type="1"><li><p>给定 <span class="math inline">\(l,r,v\)</span>，<spanclass="math inline">\(\forall i\in[l,r],x_i\leftarrowx_i+v\)</span>；</p></li><li><p>给定 <span class="math inline">\(l,r\)</span>，求 <spanclass="math inline">\(\max\limits_{i=l}^{r}f_{i}(x_i)\)</span>。</p></li></ol></blockquote><p>KTT 以这样的方式解决上述问题：</p><p>维护一颗线段树，每个节点维护取到 <span class="math inline">\(\maxf_i(x_i)\)</span> 的 <spanclass="math inline">\(f_i\)</span>，即对应自变量下，函数值最大的<strong>函数</strong>，称其为<strong>区间最优函数</strong>。同时记录一个阈值<span class="math inline">\(th\)</span>，表示当该区间 <spanclass="math inline">\(x_i\leftarrow x_i+v\)</span>后，区间最优函数发生改变的<strong>最小</strong> <spanclass="math inline">\(v\)</span>值，称其为区间最优函数的<strong>最近切换点</strong>。</p><p>区间修改时，若 <span class="math inline">\(v&lt;th\)</span>，则直接操作即可；否则继续递归，暴力修改左右子树。</p><p>上传信息时，除了要上传原本的信息，还要计算阈值的最小值。</p><p>时间复杂度分析详见 2020 国家集训队论文《浅谈函数最值的动态维护》，为<span class="math inline">\(O(n\log^2 n+m\log^3 n+q\logn)\)</span>，其中 <span class="math inline">\(m,q\)</span> 分别为 <spanclass="math inline">\(1,2\)</span> 操作的次数。</p><p><a href="#ei-的第六分块">例题</a>。</p><h1 id="题目随解">题目随解</h1><h2 id="k-maximum-subsequence-sum">k-Maximum Subsequence Sum</h2><p><a class="link"   href="https://codeforces.com/contest/280/problem/D" >CF280Dk-Maximum Subsequence Sum</a></p><blockquote><p>在给定序列 <span class="math inline">\(\{a_n\}\)</span> 中选取不超过<span class="math inline">\(k\)</span> 段不相交的区间 <spanclass="math inline">\([l_i, r_i](l_i\leq r_i)\)</span>，使 <spanclass="math inline">\(\sum\limits_{i=1}^{k}\sum\limits_{j=l_i}^{r_i}a_{j}\)</span>最大。</p><p>需要支持单点覆盖。</p><p><span class="math inline">\(1\leq n,q\leq 10^5,k\leq20\)</span>。</p></blockquote><p>当 <span class="math inline">\(k=1\)</span>时，题目变为区间最大子段和。这个问题我们在<ahref="#维护区间最大子段和">上面</a>已经学过。</p><p>那么 <span class="math inline">\(k&gt;1\)</span>的时候呢？考虑一个贪心：每次选取当前最大子段和，并将其 <spanclass="math inline">\(\times -1\)</span>，重复 <spanclass="math inline">\(k\)</span> 次，然后取 <spanclass="math inline">\(1\sim k\)</span> 中的最大值。</p><p>这个贪心的正确性可以用费用流证明：<spanclass="math inline">\(S\rightarrow i,i\rightarrow T\)</span>连一条流量为 <span class="math inline">\(1\)</span>，费用为 <spanclass="math inline">\(0\)</span> 的边，<spanclass="math inline">\(i\rightarrow i+1\)</span> 连一条流量为 <spanclass="math inline">\(1\)</span>，费用为 <spanclass="math inline">\(a_i\)</span> 的边。那么一条 <spanclass="math inline">\(S\rightarrow i\rightarrow j \rightarrow T\)</span>的流表示选择了 <spanclass="math inline">\([i,j-1]\)</span>。之后引入反流，每次将前一项 <spanclass="math inline">\(\times -1\)</span>，新区间 <spanclass="math inline">\([l,r]\)</span> 与旧区间 <spanclass="math inline">\([x,y]\)</span> 若有交集，则说明 <spanclass="math inline">\([x,y]\)</span> 有一部分被反悔。显然，<spanclass="math inline">\([l,r]\)</span> 与 <spanclass="math inline">\([x,y]\)</span> 不可能存在包含关系。因此 <spanclass="math inline">\(k\)</span> 轮增广之后，我们就得到了答案。</p><p>考虑要维护什么：区间最大子段和的必须品区间和 <spanclass="math inline">\(sum\)</span>，左端点开始的最大子段和 <spanclass="math inline">\(lft\)</span>，右端点开始的最大子段和 <spanclass="math inline">\(rgt\)</span>，区间最大子段和最 <spanclass="math inline">\(ans\)</span>。由于要取反，我们还要维护一个左端点开始的最小子段和，右端点开始的最小子段和，区间最小子段和。可以分别用两个结构体封装，方便以后的操作。由于我们要记录反转哪里，所以还需要分别维护最大最小的子段和左端点<span class="math inline">\(ansl\)</span>、右端点 <spanclass="math inline">\(ansr\)</span>，左端点开始的子段和右端点 <spanclass="math inline">\(lftr\)</span>，右端点开始的子段和左端点 <spanclass="math inline">\(rgtl\)</span>，以及一个翻转标记 <spanclass="math inline">\(tag\)</span>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sub</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ans, lft, rgt;</span><br><span class="line">    <span class="type">int</span> ansl, ansr, lftr, rgtl;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span></span>&#123;ans = lft = rgt = x; <span class="keyword">if</span>(i != <span class="number">-1</span>) ansl = ansr = lftr = rgtl = i;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mul_1</span><span class="params">()</span></span>&#123;ans *= <span class="number">-1</span>, lft *= <span class="number">-1</span>, rgt *= <span class="number">-1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    sub big, sml;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">    <span class="comment">//以上为区间和</span></span><br><span class="line">    <span class="keyword">if</span>(tr[ls].big.ans &gt; tr[rs].big.ans) tr[k].big.ans = tr[ls].big.ans, tr[k].big.ansl = tr[ls].big.ansl, tr[k].big.ansr = tr[ls].big.ansr;</span><br><span class="line">    <span class="keyword">else</span> tr[k].big.ans = tr[rs].big.ans, tr[k].big.ansl = tr[rs].big.ansl, tr[k].big.ansr = tr[rs].big.ansr;</span><br><span class="line">    <span class="keyword">if</span>(tr[ls].big.rgt + tr[rs].big.lft &gt; tr[k].big.ans) tr[k].big.ans = tr[ls].big.rgt + tr[rs].big.lft, tr[k].big.ansl = tr[ls].big.rgtl, tr[k].big.ansr = tr[rs].big.lftr;</span><br><span class="line">    <span class="comment">//以上为区间最大子段和</span></span><br><span class="line">    <span class="keyword">if</span>(tr[ls].sum + tr[rs].big.lft &gt; tr[ls].big.lft) tr[k].big.lft = tr[ls].sum + tr[rs].big.lft, tr[k].big.lftr = tr[rs].big.lftr;</span><br><span class="line">    <span class="keyword">else</span> tr[k].big.lft = tr[ls].big.lft, tr[k].big.lftr = tr[ls].big.lftr;</span><br><span class="line">    <span class="comment">//以上为左端点开始的最大子段和</span></span><br><span class="line">    <span class="keyword">if</span>(tr[rs].sum + tr[ls].big.rgt &gt; tr[rs].big.rgt) tr[k].big.rgt = tr[rs].sum + tr[ls].big.rgt, tr[k].big.rgtl = tr[ls].big.rgtl;</span><br><span class="line">    <span class="keyword">else</span> tr[k].big.rgt = tr[rs].big.rgt, tr[k].big.rgtl = tr[rs].big.rgtl;</span><br><span class="line">    <span class="comment">//以上为右端点开始的最大子段和</span></span><br><span class="line">    <span class="keyword">if</span>(tr[ls].sml.ans &lt; tr[rs].sml.ans) tr[k].sml.ans = tr[ls].sml.ans, tr[k].sml.ansl = tr[ls].sml.ansl, tr[k].sml.ansr = tr[ls].sml.ansr;</span><br><span class="line">    <span class="keyword">else</span> tr[k].sml.ans = tr[rs].sml.ans, tr[k].sml.ansl = tr[rs].sml.ansl, tr[k].sml.ansr = tr[rs].sml.ansr;</span><br><span class="line">    <span class="keyword">if</span>(tr[ls].sml.rgt + tr[rs].sml.lft &lt; tr[k].sml.ans) tr[k].sml.ans = tr[ls].sml.rgt + tr[rs].sml.lft, tr[k].sml.ansl = tr[ls].sml.rgtl, tr[k].sml.ansr = tr[rs].sml.lftr;</span><br><span class="line">    <span class="keyword">if</span>(tr[ls].sum + tr[rs].sml.lft &lt; tr[ls].sml.lft) tr[k].sml.lft = tr[ls].sum + tr[rs].sml.lft, tr[k].sml.lftr = tr[rs].sml.lftr;</span><br><span class="line">    <span class="keyword">else</span> tr[k].sml.lft = tr[ls].sml.lft, tr[k].sml.lftr = tr[ls].sml.lftr;</span><br><span class="line">    <span class="keyword">if</span>(tr[rs].sum + tr[ls].sml.rgt &lt; tr[rs].sml.rgt) tr[k].sml.rgt = tr[rs].sum + tr[ls].sml.rgt, tr[k].sml.rgtl = tr[ls].sml.rgtl;</span><br><span class="line">    <span class="keyword">else</span> tr[k].sml.rgt = tr[rs].sml.rgt, tr[k].sml.rgtl = tr[rs].sml.rgtl;</span><br><span class="line">    <span class="comment">//以上为最小子段和的维护</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(tr[k].big, tr[k].sml);</span><br><span class="line">    tr[k].sum *= <span class="number">-1</span>, tr[k].big.<span class="built_in">mul_1</span>(), tr[k].sml.<span class="built_in">mul_1</span>(), tr[k].tag ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[k].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">f</span>(ls), <span class="built_in">f</span>(rs);</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum = a[l];</span><br><span class="line">        tr[k].big.<span class="built_in">init</span>(a[l], l), tr[k].sml.<span class="built_in">init</span>(a[l], l);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].big.<span class="built_in">init</span>(v, <span class="number">-1</span>), tr[k].sml.<span class="built_in">init</span>(v, <span class="number">-1</span>), tr[k].sum = v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">update</span>(ls, l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f</span>(k);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">change</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">change</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[k];</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Node ll, rr, res;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid &amp;&amp; mid &lt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        ll = <span class="built_in">query</span>(ls, l, mid, L, R), rr = <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">        res.sum = ll.sum + rr.sum;</span><br><span class="line">        <span class="keyword">if</span>(ll.big.ans &gt; rr.big.ans) res.big.ans = ll.big.ans, res.big.ansl = ll.big.ansl, res.big.ansr = ll.big.ansr;</span><br><span class="line">        <span class="keyword">else</span> res.big.ans = rr.big.ans, res.big.ansl = rr.big.ansl, res.big.ansr = rr.big.ansr;</span><br><span class="line">        <span class="keyword">if</span>(ll.big.rgt + rr.big.lft &gt; res.big.ans) res.big.ans = ll.big.rgt + rr.big.lft, res.big.ansl = ll.big.rgtl, res.big.ansr = rr.big.lftr;</span><br><span class="line">        <span class="keyword">if</span>(ll.sum + rr.big.lft &gt; ll.big.lft) res.big.lft = ll.sum + rr.big.lft, res.big.lftr = rr.big.lftr;</span><br><span class="line">        <span class="keyword">else</span> res.big.lft = ll.big.lft, res.big.lftr = ll.big.lftr;    </span><br><span class="line">        <span class="keyword">if</span>(rr.sum + ll.big.rgt &gt; rr.big.rgt) res.big.rgt = rr.sum + ll.big.rgt, res.big.rgtl = ll.big.rgtl;</span><br><span class="line">        <span class="keyword">else</span> res.big.rgt = rr.big.rgt, res.big.rgtl = rr.big.rgtl;</span><br><span class="line">        <span class="keyword">if</span>(ll.sml.ans &lt; rr.sml.ans) res.sml.ans = ll.sml.ans, res.sml.ansl = ll.sml.ansl, res.sml.ansr = ll.sml.ansr;</span><br><span class="line">        <span class="keyword">else</span> res.sml.ans = rr.sml.ans, res.sml.ansl = rr.sml.ansl, res.sml.ansr = rr.sml.ansr;</span><br><span class="line">        <span class="keyword">if</span>(ll.sml.rgt + rr.sml.lft &lt; res.sml.ans) res.sml.ans = ll.sml.rgt + rr.sml.lft, res.sml.ansl = ll.sml.rgtl, res.sml.ansr = rr.sml.lftr;</span><br><span class="line">        <span class="keyword">if</span>(ll.sum + rr.sml.lft &lt; ll.sml.lft) res.sml.lft = ll.sum + rr.sml.lft, res.sml.lftr = rr.sml.lftr;</span><br><span class="line">        <span class="keyword">else</span> res.sml.lft = ll.sml.lft, res.sml.lftr = ll.sml.lftr;</span><br><span class="line">        <span class="keyword">if</span>(rr.sum + ll.sml.rgt &lt; rr.sml.rgt) res.sml.rgt = rr.sum + ll.sml.rgt, res.sml.rgtl = ll.sml.rgtl;</span><br><span class="line">        <span class="keyword">else</span> res.sml.rgt = rr.sml.rgt, res.sml.rgtl = rr.sml.rgtl;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了方便合并，当需要合并的时候我们直接合并，合并方式与 pushup 类似</span></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><p>思考：区间覆盖该怎么办？</p><h2 id="等差子序列">等差子序列</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P2757" >【国家集训队】等差子序列</a></p><blockquote><p>给一个 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(N\)</span> 的排列 <spanclass="math inline">\(\{A_i\}\)</span>，询问是否存在</p><p><span class="math display">\[1 \lep_1&lt;p_2&lt;p_3&lt;p_4&lt;p_5&lt;…&lt;p_{Len} \le N (Len \ge3)\]</span></p><p>使得 <spanclass="math inline">\(Ap_1,Ap_2,Ap_3,\cdots,Ap_{Len}\)</span>是一个等差序列。</p><p><span class="math inline">\(1 \leq N \leq 5\times10^5\)</span>，<span class="math inline">\(5s\)</span>。</p></blockquote><p>只需要求出一个长度为 <span class="math inline">\(3\)</span>的等差子序列即可，即找到 <spanclass="math inline">\(i&lt;j&lt;k\)</span>，使得 <spanclass="math inline">\(A_i,A_j,A_k\)</span> 为等差序列。</p><p>一个很显然的套路是枚举中间值，判断是否存在 <spanclass="math inline">\(A_i=A_j-x(i&lt;j)\)</span> 和 <spanclass="math inline">\(A_k=A_j+x(k&gt;j)\)</span> 即可。</p><p>而因为 <span class="math inline">\(\{A_n\}\)</span>是排列，因此这两个数一定存在（合法情况下），且一定位于 <spanclass="math inline">\(A_j\)</span>的左侧或右侧。那我们不妨建立类似于值域线段树的东西，若 <spanclass="math inline">\(A_i\)</span> 在 <spanclass="math inline">\(A_j\)</span> 左侧，则第 <spanclass="math inline">\(A_i\)</span> 叶子节点为 <spanclass="math inline">\(0\)</span>，否则为 <spanclass="math inline">\(1\)</span>。</p><p>显然，对于 <spanclass="math inline">\(A_j\)</span>，想要不存在等差子序列，必须满足 <spanclass="math inline">\(A_{j-x}=A_{j+x}\)</span>。那么对于区间 <spanclass="math inline">\([j-1,1],[j+1,n]\)</span>，两者必须完全相同。（这里的<span class="math inline">\([j-1,1]\)</span> 表示序列 <spanclass="math inline">\(A_{j-1},A_{j-2}\cdots A_1\)</span>）</p><p>怎么维护是否相同呢？字符串哈希！</p><p>线段树维护 <span class="math inline">\([l,r]\)</span>的哈希值即可！对于不同的 <spanclass="math inline">\(j\)</span>，由于只会影响到至多两个点，因此单点修改即可。</p><p><del>（但是这题我写的树状数组，就不放代码了。）</del></p><h2 id="双面棋盘">双面棋盘</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P4121" >【WC2005】双面棋盘</a></p><blockquote><p>给定 <span class="math inline">\(n\times n\)</span> 的 <spanclass="math inline">\(01\)</span> 四连通矩阵（即，上下左右）。</p><p>每次取反一个数，求 <span class="math inline">\(0\)</span>、<spanclass="math inline">\(1\)</span> 连通块分别的数量。</p><p><span class="math inline">\(1\leq n\leq 200,1\leq q\leq10^4\)</span>。</p></blockquote><p>不加修改操作怎么做？并查集即可。</p><p>加上修改操作呢？只需要线段树维护并查集就可以了！</p><p>因此线段树套并查集，线段树节点维护 <spanclass="math inline">\([l,r]\)</span> 行的并查集，合并的时候合并 <spanclass="math inline">\([l,mid]\)</span> 与 <spanclass="math inline">\([mid + 1,r]\)</span>，只需要暴力合并 <spanclass="math inline">\(mid,mid+1\)</span> 即可。</p><p>单次合并用路径压缩+按秩合并并查集，时间复杂度 <spanclass="math inline">\(O(\alpha(n))\)</span>，每次合并操作 <spanclass="math inline">\(O(n\alpha(n))\)</span>，总复杂度 <spanclass="math inline">\(O(qn\alpha(n)\log n)\)</span>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> mp[MAXN][MAXN]; <span class="comment">//0 wt 1 bk</span></span><br><span class="line"><span class="type">int</span> fa[MAXN * MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wt, bk;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> lson[MAXN], rson[MAXN];</span><br><span class="line">&#125;t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x * n + y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].lson[i] = t[ls].lson[i];</span><br><span class="line">        t[k].rson[i] = t[rs].rson[i];</span><br><span class="line">        fa[t[ls].lson[i]] = t[ls].lson[i];</span><br><span class="line">        fa[t[rs].lson[i]] = t[rs].lson[i];</span><br><span class="line">        fa[t[ls].rson[i]] = t[ls].rson[i];</span><br><span class="line">        fa[t[rs].rson[i]] = t[rs].rson[i];</span><br><span class="line">    &#125;</span><br><span class="line">    t[k].bk = t[ls].bk + t[rs].bk;</span><br><span class="line">    t[k].wt = t[ls].wt + t[rs].wt;</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[mid][i] == mp[mid + <span class="number">1</span>][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> L = <span class="built_in">get</span>(t[ls].rson[i]);</span><br><span class="line">            <span class="type">int</span> R = <span class="built_in">get</span>(t[rs].lson[i]);</span><br><span class="line">            <span class="keyword">if</span>(L != R)</span><br><span class="line">            &#123;</span><br><span class="line">                fa[L] = R;</span><br><span class="line">                mp[mid][i] == <span class="number">0</span> ? t[k].wt-- : t[k].bk--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].lson[i] = <span class="built_in">get</span>(t[k].lson[i]);</span><br><span class="line">        t[k].rson[i] = <span class="built_in">get</span>(t[k].rson[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].l = l;</span><br><span class="line">    t[k].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lson[i] = <span class="built_in">id</span>(l, i);</span><br><span class="line">            t[k].rson[i] = <span class="built_in">id</span>(l, i);</span><br><span class="line">            fa[<span class="built_in">id</span>(l, i)] = <span class="built_in">id</span>(l, i);</span><br><span class="line">            mp[l][i] == <span class="number">0</span> ? t[k].wt++ : t[k].bk++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[l][i] == mp[l][i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                t[k].lson[i] = fa[<span class="built_in">id</span>(l, i - <span class="number">1</span>)];</span><br><span class="line">                t[k].rson[i] = fa[<span class="built_in">id</span>(l, i - <span class="number">1</span>)];</span><br><span class="line">                fa[<span class="built_in">id</span>(l, i)] = fa[<span class="built_in">id</span>(l, i - <span class="number">1</span>)];</span><br><span class="line">                mp[l][i] == <span class="number">0</span> ? t[k].wt-- : t[k].bk--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].l == t[k].r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].wt = <span class="number">0</span>;</span><br><span class="line">        t[k].bk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lson[i] = <span class="built_in">id</span>(p, i);</span><br><span class="line">            t[k].rson[i] = <span class="built_in">id</span>(p, i);</span><br><span class="line">            fa[<span class="built_in">id</span>(p, i)] = <span class="built_in">id</span>(p, i);</span><br><span class="line">            mp[p][i] == <span class="number">0</span> ? t[k].wt++ : t[k].bk++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[p][i] == mp[p][i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                t[k].lson[i] = fa[<span class="built_in">id</span>(p, i - <span class="number">1</span>)];</span><br><span class="line">                t[k].rson[i] = fa[<span class="built_in">id</span>(p, i - <span class="number">1</span>)];</span><br><span class="line">                fa[<span class="built_in">id</span>(p, i)] = fa[<span class="built_in">id</span>(p, i - <span class="number">1</span>)];</span><br><span class="line">                mp[p][i] == <span class="number">0</span> ? t[k].wt-- : t[k].bk--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[ls].r &gt;= p) <span class="built_in">update</span>(ls, p);</span><br><span class="line">    <span class="keyword">if</span>(t[rs].l &lt;= p) <span class="built_in">update</span>(rs, p);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><h2 id="决战圆锥曲线">决战圆锥曲线</h2><p><a class="link"   href="https://uoj.ac/problem/119" >【UR #8】决战圆锥曲线</a></p><blockquote><p>给定伪随机序列 <spanclass="math inline">\(\{a_n\}\)</span>，有三种操作：</p><ol type="1"><li><p>给定 <span class="math inline">\(x,v\)</span>，<spanclass="math inline">\(a_x\leftarrow v\)</span>；</p></li><li><p>给定 <span class="math inline">\(l,r\)</span>，<spanclass="math inline">\(\forall a_i\in[l,r],a_i\leftarrow10^5-a_i\)</span>；</p></li><li><p>给定 <span class="math inline">\(l,r,x,y,z\)</span>，求 <spanclass="math inline">\(\max\limits_{i=l}^{r}\{xi+ya_i+zia_i\}\)</span>。</p></li></ol><p><span class="math inline">\(1\leq n\leq 10^5,1\leq q\leq10^6\)</span>，<span class="math inline">\(2s\)</span>。</p></blockquote><p>操作 <span class="math inline">\(1,2\)</span>显然都是好做的，直接搞就可以了。</p><p>而对于操作 <spanclass="math inline">\(3\)</span>，我们可以这么做：因为若 <spanclass="math inline">\(j&lt;i\land a_j&lt;a_i\)</span>，则 <spanclass="math inline">\(j\)</span> 必然不可能被选中。因此选择当前区间中<span class="math inline">\(a_i\)</span> 的最大值，之后查询所有 <spanclass="math inline">\(a_j(j&gt;i)\)</span> 即可。</p><p>分析一下时间复杂度：我们一次查询操作相当于再找上升子段。在随机数据的情况下，最长上升子段的长度期望近似于<span class="math inline">\(O(\log n)\)</span>，<a class="link"  href="https://mathoverflow.net/questions/16817/longest-consecutive-subsequence-of-a-random-permutation" >严格证明可以看这里</a>。那么一次线段树的查询操作就是<span class="math inline">\(O(\log^2 n)\)</span>，总时间复杂度 <spanclass="math inline">\(O(q\log^2n)\)</span></p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minn, maxx;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].maxx = <span class="built_in">max</span>(tr[ls].maxx, tr[rs].maxx);</span><br><span class="line">    tr[k].minn = <span class="built_in">min</span>(tr[ls].minn, tr[rs].minn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].tag ^= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">swap</span>(tr[k].maxx, tr[k].minn);</span><br><span class="line">    tr[k].minn = mod4 - <span class="number">1</span> - tr[k].minn;</span><br><span class="line">    tr[k].maxx = mod4 - <span class="number">1</span> - tr[k].maxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[k].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">f</span>(ls), <span class="built_in">f</span>(rs);</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].maxx = tr[k].minn = a[l]);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].maxx = tr[k].minn = v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">change</span>(ls, l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(rs, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f</span>(k);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((res = x * r + y * tr[k].maxx + z * r * tr[k].maxx) &lt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="type">void</span>)(ans = res);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R, x, y, z);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">query</span>(ls, l, mid, L, R, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><h2 id="rikka-with-phi">Rikka with Phi</h2><p><a class="link"   href="http://acm.hdu.edu.cn/showproblem.php?pid=5634" >HDU5634Rikka with Phi</a></p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，诸如：</p><ol type="1"><li><p>给定 <span class="math inline">\(l,r\)</span>，<spanclass="math inline">\(\forall a_i\in [l,r],a_i\leftarrow\varphi(a_i)\)</span>；</p></li><li><p>给定 <span class="math inline">\(l,r,x\)</span>，<spanclass="math inline">\(\forall a_i\in[l,r],a_i\leftarrowx\)</span>；</p></li><li><p>查询区间和。</p></li></ol><p><span class="math inline">\(1\leq n,q\leq 3\cdot 10^5,1\leq a_i\leq10^7\)</span>。</p></blockquote><p>没有区间覆盖怎么做？</p><p>与区间开根类似。一个数 <span class="math inline">\(n\)</span> 最多被<span class="math inline">\(\varphi\)</span> 过 <spanclass="math inline">\(\log n\)</span> 次之后就会变成 <spanclass="math inline">\(1\)</span>。那么我们暴力更改一个点的时间复杂度是<span class="math inline">\(O(\log^2n)\)</span> 的，总时间复杂度均摊为<span class="math inline">\(O(n\log^2 n)\)</span>。</p><p>那加上区间覆盖操作呢？区间覆盖有一个很重要的性质：经过操作之后，序列会被分成若干块。那么我们不妨维护一下当前区间是否相同，如果相同，求<span class="math inline">\(\varphi\)</span>后还是相同。时间复杂度仍然是均摊的 <spanclass="math inline">\(O(n\log^2n)\)</span>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tree[MAXN &lt;&lt; <span class="number">2</span>], andd[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k] = tree[<span class="built_in">lc</span>(k)] + tree[<span class="built_in">rc</span>(k)];</span><br><span class="line">    <span class="keyword">if</span>(andd[<span class="built_in">lc</span>(k)] == andd[<span class="built_in">rc</span>(k)]) andd[k] = andd[<span class="built_in">lc</span>(k)];</span><br><span class="line">    <span class="keyword">else</span> andd[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(andd[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        andd[<span class="built_in">lc</span>(k)] = andd[<span class="built_in">rc</span>(k)] = andd[k];</span><br><span class="line">        tree[<span class="built_in">lc</span>(k)] = andd[<span class="built_in">lc</span>(k)] * (mid - l + <span class="number">1</span>);</span><br><span class="line">        tree[<span class="built_in">rc</span>(k)] = andd[<span class="built_in">rc</span>(k)] * (r - mid);</span><br><span class="line">        andd[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k] = andd[k] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(k), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt; R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(andd[k] &amp;&amp; l == L &amp;&amp; r == R)</span><br><span class="line">    &#123;</span><br><span class="line">        andd[k] = phi[andd[k]];</span><br><span class="line">        tree[k] = andd[k] * (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(k), l, mid, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">lc</span>(k), l, mid, L, mid);</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update2</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt; R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == L &amp;&amp; r == R)</span><br><span class="line">    &#123;</span><br><span class="line">        andd[k] = v;</span><br><span class="line">        tree[k] = andd[k] * (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="built_in">update2</span>(<span class="built_in">lc</span>(k), l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="built_in">update2</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update2</span>(<span class="built_in">lc</span>(k), l, mid, L, mid, v);</span><br><span class="line">        <span class="built_in">update2</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tree[k];</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">lc</span>(k), l ,mid, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">lc</span>(k), l ,mid, L, mid) + <span class="built_in">query</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><p><del>一年前写的代码，好丑。</del></p><h2 id="wall">Wall</h2><p><a class="link"  href="https://www.luogu.com.cn/problem/P4560" >【IOI2014】Wall</a></p><blockquote><p>给定初始全部为 <span class="math inline">\(0\)</span> 的序列 <spanclass="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(k\)</span> 次操作：</p><ol type="1"><li><p>给定 <span class="math inline">\(l,r,h\)</span>，<spanclass="math inline">\(\forall a_i\in [l,r],a_i\leftarrow\min(a_i,h)\)</span>；</p></li><li><p>给定 <span class="math inline">\(l,r,h\)</span>，<spanclass="math inline">\(\forall a_i\in [l,r],a_i\leftarrow\max(a_i,h)\)</span>；</p></li></ol><p><span class="math inline">\(1\leq n\leq 2\cdot 10^6,1\leq k\leq5\cdot 10^5\)</span>。</p></blockquote><p>这题作为一道 IOI 题，感觉有点过于水了。</p><p>我们发现这两个操作实际上相当于划定了某个区间的上界和下界，<spanclass="math inline">\(1\)</span> 操作是对上界的操作，相当于把 <spanclass="math inline">\(h\)</span> 上面的数字都映射到 <spanclass="math inline">\(h\)</span> 上，<spanclass="math inline">\(2\)</span> 操作是对下界的操作。</p><p>既然这样，那么我们不妨维护一个当前区间上下界。合并很好合并，考虑一下如何修改。</p><p>先讨论上界的变动：</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/09/Ck2y8B5967bFaKO.png"                     alt="更改"                 ><figcaption aria-hidden="true">更改</figcaption></figure><p>如图，两条实线是我们目前的上下界，而我们更改的 <spanclass="math inline">\(h\)</span>有三种可能：高于上界（红色虚线）、在上下界间（绿色虚线）、低于下界（粉色虚线<del>（这到底是粉色还是紫色啊）</del> ）。</p><p>第一种情况：高于上界。由于我们现在所有的数都在蓝线之间了，将上界拉高不会产生什么实质性的影响，因此上界不变。</p><p>第二种情况：在上下界间。此时在上蓝线与绿线中间的数字要被映射到绿线上，因此上界被压倒绿色虚线，更改上界。</p><p>第三种情况：低于下界。此时新更新的上界已经比原来的下界还要低了，现在所有的点都要被映射到粉线上，上下界都需要更改到粉线。</p><p>下界的变动也类似，按照上例讨论即可。最后的答案即是下界的值。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxx, minn;</span><br><span class="line">    <span class="type">int</span> mxtg = <span class="number">-1</span>, mntg = <span class="number">-1</span>;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].maxx = <span class="built_in">max</span>(tr[ls].maxx, tr[rs].maxx);</span><br><span class="line">    tr[k].minn = <span class="built_in">min</span>(tr[ls].minn, tr[rs].minn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].minn = <span class="built_in">max</span>(tr[k].minn, v);</span><br><span class="line">    tr[k].maxx = <span class="built_in">max</span>(tr[k].maxx, tr[k].minn); </span><br><span class="line">    tr[k].mxtg = tr[k].maxx;</span><br><span class="line">    tr[k].mntg = tr[k].minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].maxx = <span class="built_in">min</span>(tr[k].maxx, v);</span><br><span class="line">    tr[k].minn = <span class="built_in">min</span>(tr[k].maxx, tr[k].minn); </span><br><span class="line">    tr[k].mxtg = tr[k].maxx;</span><br><span class="line">    tr[k].mntg = tr[k].minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].mntg != <span class="number">-1</span>) <span class="built_in">f1</span>(ls, tr[k].mntg), <span class="built_in">f1</span>(rs, tr[k].mntg), tr[k].mntg = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].mxtg != <span class="number">-1</span>) <span class="built_in">f2</span>(ls, tr[k].mxtg), <span class="built_in">f2</span>(rs, tr[k].mxtg), tr[k].mxtg = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f1</span>(k, v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">add</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">add</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rmv</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f2</span>(k, v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">rmv</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">rmv</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> tr[k].minn;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(ls, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><p>PS：一开始 query 的 <code>if-else</code> 没写<code>return</code>，导致开了 <span class="math inline">\(O2\)</span>就会 RE。死因：有返回值函数不返回是 UB，警钟敲烂。</p><p>PS2：我宣布这个代码的区间修改函数是线段树区间修改函数最美丽的形态！！1</p><h2 id="树状数组">树状数组</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P3688" >【ZJOI2017】树状数组</a></p><blockquote><p>题面很难简述，看原题吧。</p></blockquote><p>首先，题目给的树状数组并不是错误写法，而是一种经典的树状数组应用：将query 和 add 的 lowbit同时写反，原本对前缀的操作就会变成对后缀操作。</p><p>但是 query 函数中，他对于一段区间的操作仍然是 <spanclass="math inline">\(\text{Find}(r)-\text{Find}(l-1)\)</span>，这就导致了我们查询的结果并不是<span class="math inline">\([l,r]\)</span>，而是向左偏移了一位，变成了<span class="math inline">\([l-1,r-1]\)</span>。</p><p>加 <span class="math inline">\(1\)</span> 再取模 <spanclass="math inline">\(2\)</span>的操作相当于布尔型取反，的这意味着我们可以只关心 <spanclass="math inline">\(A_{l-1}\)</span> 和 <spanclass="math inline">\(A_r\)</span> 是否相同即可。</p><p>这里有一个理所当然的误区：我们可能很容易想到维护 <spanclass="math inline">\(B_i\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个数为 <spanclass="math inline">\(1\)</span> 的概率，那么对于一段长度为 <spanclass="math inline">\(len\)</span> 的区间，每个数变成 <spanclass="math inline">\(1\)</span> 的概率就会是 <spanclass="math inline">\(\dfrac{1}{len}\)</span>。但是这时有一个反例：如果对于区间<span class="math inline">\([1,2]\)</span> 执行一次操作，<spanclass="math inline">\(B_1=B_2=\dfrac{1}{2}\)</span>，此时如果暴力计算，<spanclass="math inline">\(A_1,A_2\)</span> 相等的概率就变成了 <spanclass="math inline">\(\dfrac{1}{4}\)</span>，然而实际上这个结果应该是<span class="math inline">\(0\)</span>。</p><p>这实际上断绝了我们直接考虑每个数的概率的可行性。</p><p>那么我们不妨维护每个点对 <span class="math inline">\((l,r)\)</span>表示 <span class="math inline">\(A_l,A_r\)</span>相等的概率。此时我们的操作区间可以分成三种：</p><ol type="1"><li>只涵盖了一个点的区间：此时会产生 <spanclass="math inline">\(\dfrac{1}{len}\)</span> 的影响。</li><li>涵盖了两个点的区间：此时会产生 <spanclass="math inline">\(\dfrac{2}{len}\)</span> 的影响。</li><li>一个点都没涵盖的区间：不管。</li></ol><p>此时有一个非常巧妙的做法：我们不妨将 <spanclass="math inline">\((l,r)\)</span>的点对看作一个二维网格，那么我们对于一次区间操作 <spanclass="math inline">\((L,R)\)</span>，考虑他对每个点对的影响。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/19/TVFfdGP8zyk57K6.png"                     alt="二维网格"                 ><figcaption aria-hidden="true">二维网格</figcaption></figure><p>举个例子：如上图，如果我们对原序列 <spanclass="math inline">\([3,5]\)</span>进行操作，那么第一种情况的点对对应的就是红色区域，第二种情况的点对对应的就是黄色区域，第三种情况对应的白色区域。</p><p>现在就显然可以用二维线段树（或者叫线段树套线段树）维护了。中间黄色三角形不太好维护，可以直接填满矩形。</p><p>不过还有一个问题：你发现这个树状数组的 <spanclass="math inline">\(\text{Find}\)</span>比一般的要长一点；因为他加了一个特判。当 <spanclass="math inline">\(l=1\)</span> 的时候，<spanclass="math inline">\(x\)</span> 会变成 <spanclass="math inline">\(0\)</span>，此时会直接返回 <spanclass="math inline">\(0\)</span>，相当于问你区间 <spanclass="math inline">\([r,n]\)</span> 是否为 <spanclass="math inline">\(0\)</span> 了，特别处理一下即可。</p><p>时空复杂度均为 <span class="math inline">\(O(n\log^2n)\)</span>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rt[MAXN &lt;&lt; <span class="number">2</span>], lson[MAXN * <span class="number">375</span>], rson[MAXN * <span class="number">375</span>], res[MAXN * <span class="number">375</span>];</span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(ll x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; y; x = x * x % mod, y &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>&#123;<span class="keyword">return</span> (<span class="number">1ll</span> * p * q % mod + <span class="number">1ll</span> * ((<span class="number">1</span> + mod - p) % mod) * ((<span class="number">1</span> + mod - q) % mod) % mod) % mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt, res[k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)(res[k] = <span class="built_in">calc</span>(res[k], v));</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(lson[k], l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rson[k], mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span> L2, <span class="type">int</span> R2, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L1 &lt;= l &amp;&amp; r &lt;= R1) <span class="keyword">return</span> <span class="built_in">update</span>(rt[k], <span class="number">1</span>, n, L2, R2, v);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L1 &lt;= mid) <span class="built_in">Update</span>(ls, l, mid, L1, R1, L2, R2, v);</span><br><span class="line">    <span class="keyword">if</span>(R1 &gt; mid) <span class="built_in">Update</span>(rs, mid + <span class="number">1</span>, r, L1, R1, L2, R2, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> res[k];</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="keyword">return</span> <span class="built_in">calc</span>(res[k], <span class="built_in">query</span>(lson[k], l, mid, x));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">calc</span>(res[k], <span class="built_in">query</span>(rson[k], mid + <span class="number">1</span>, r, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x1, <span class="type">int</span> x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> <span class="built_in">query</span>(rt[k], <span class="number">1</span>, n, x2);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x1 &lt;= mid) <span class="keyword">return</span> <span class="built_in">calc</span>(<span class="built_in">query</span>(rt[k], <span class="number">1</span>, n, x2), <span class="built_in">Query</span>(ls, l, mid, x1, x2));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">calc</span>(<span class="built_in">query</span>(rt[k], <span class="number">1</span>, n, x2), <span class="built_in">Query</span>(rs, mid + <span class="number">1</span>, r, x1, x2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, l, r;</span><br><span class="line">        <span class="built_in">read</span>(op, l, r);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">qpow</span>(r - l + <span class="number">1</span>, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(l &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">1</span>, l - <span class="number">1</span>, l, r, (<span class="number">1</span> + mod - x) % mod);</span><br><span class="line">                <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, l - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">if</span>(r &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, r + <span class="number">1</span>, n, (<span class="number">1</span> + mod - x) % mod);</span><br><span class="line">                <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">0</span>, <span class="number">0</span>, r + <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, l, r, (<span class="number">1</span> + <span class="number">2ll</span> * mod - <span class="number">2ll</span> * x) % mod);</span><br><span class="line">            <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">0</span>, <span class="number">0</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">0</span>, n, l - <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><h2 id="楼房重建">楼房重建</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P4198" >洛谷P4198楼房重建</a></p><blockquote><p>在一个二维平面上有 <span class="math inline">\(N\)</span> 栋楼房。小A 在平面上 <span class="math inline">\((0,0)\)</span> 点的位置，第 <spanclass="math inline">\(i\)</span> 栋楼房可以用一条连接 <spanclass="math inline">\((i,0)\)</span> 和 <spanclass="math inline">\((i,H_i)\)</span> 的线段表示，其中 <spanclass="math inline">\(H_i\)</span> 为第 <spanclass="math inline">\(i\)</span>栋楼房的高度。如果这栋楼房上任何一个高度大于 <spanclass="math inline">\(0\)</span> 的点与 <spanclass="math inline">\((0,0)\)</span>的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。</p><p>施工队的建造总共进行了 <span class="math inline">\(M\)</span>天。初始时，所有楼房都还没有开始建造，它们的高度均为 <spanclass="math inline">\(0\)</span>。在第 <spanclass="math inline">\(i\)</span> 天，建筑队将会将横坐标为 <spanclass="math inline">\(X_i\)</span> 的房屋的高度变为 <spanclass="math inline">\(Y_i\)</span>。请你帮小 A数数每天在建筑队完工之后，他能看到多少栋楼房?</p><p><span class="math inline">\(1 \le X_i \le N\)</span>，<spanclass="math inline">\(1 \le Y_i \le 10^9\)</span>，<spanclass="math inline">\(1\le N,M \le 10^5\)</span>。</p></blockquote><p>根据我们小学二年级学过的几何知识，我们可以把这个题目转化一下：题目等同于维护<span class="math inline">\((i,H_i)\)</span> 到 <spanclass="math inline">\((0,0)\)</span> 连线的斜率 <spanclass="math inline">\(k_i\)</span>，并求出从 <spanclass="math inline">\(1\)</span>开始、贪心的上升子序列（即如果当前点大于最大值，则一定选取它）。</p><p>考虑用线段树去维护它。考虑怎么把两端信息合并。</p><p>首先，左区间和右区间合并的时候，左区间一定全选，而右区间会选择大于左区间<span class="math inline">\(max\)</span> 的部分。这个东西怎么求？</p><p>线段树二分！</p><p>我们只需要在合并的时候同时二分右区间即可。时间复杂度 <spanclass="math inline">\(O(n\log^2 n)\)</span>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].maxx &lt;= x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (tr[k].maxx &gt; x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[ls].maxx &lt;= x) <span class="keyword">return</span> <span class="built_in">get</span>(rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(ls, l, mid, x) + tr[k].len - tr[ls].len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[k].len = tr[ls].len + <span class="built_in">get</span>(rs, mid + <span class="number">1</span>, r, tr[ls].maxx);</span><br><span class="line">    tr[k].maxx = <span class="built_in">max</span>(tr[ls].maxx, tr[rs].maxx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == x &amp;&amp; r == x) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].maxx = <span class="number">1.00</span> * v / x, tr[k].len = <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">update</span>(ls, l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><h2 id="大魔法师">大魔法师</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P7453" >【THUSCH2017】大魔法师</a></p><p>如果是互不影响的几个值，那么用线段树很好维护。但是现在是几个相互影响的值，考虑该怎么办。</p><p>一个非常巧妙的想法是用矩阵维护这些关系。我们把每个水晶球看作一个行向量<spanclass="math inline">\((A_i,B_i,C_i,v)\)</span>，前三者表示不同的属性，第四者是常数项，初始为<span class="math inline">\(1\)</span>，表示区间元素个数。</p><p>那么我们推出来各个操作的转移矩阵：</p><p><span class="math display">\[\text{Opt}_1=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\1 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span> <span class="math display">\[\text{Opt}_2=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span> <span class="math display">\[\text{Opt}_3=\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span> <span class="math display">\[\text{Opt}_4=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\v &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span> <span class="math display">\[\text{Opt}_5=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; v &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span> <span class="math display">\[\text{Opt}_6=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 0 &amp; v &amp; 1\end{bmatrix}\]</span></p><p>然后直接用线段树维护矩阵就可以了。</p><p>但是这题有些卡常，这里有一些可以使用的卡常技巧：</p><ol type="1"><li>循环展开：将矩阵加法和乘法最内层的循环展开，可以优化大量时间；</li><li>注意到我们实际维护的只是一个行向量，因此没有必要按照 <spanclass="math inline">\(4\times 4\)</span> 矩阵维护；</li><li>不要开 long long。</li></ol><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span>+ (Matrix &amp;A) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix B;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            B.a[i][<span class="number">0</span>] = (a[i][<span class="number">0</span>] + A.a[i][<span class="number">0</span>]) % mod;</span><br><span class="line">            B.a[i][<span class="number">1</span>] = (a[i][<span class="number">1</span>] + A.a[i][<span class="number">1</span>]) % mod;</span><br><span class="line">            B.a[i][<span class="number">2</span>] = (a[i][<span class="number">2</span>] + A.a[i][<span class="number">2</span>]) % mod;</span><br><span class="line">            B.a[i][<span class="number">3</span>] = (a[i][<span class="number">3</span>] + A.a[i][<span class="number">3</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span>* (Matrix &amp;A) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix B;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                B.a[i][j] = (B.a[i][j] + (<span class="number">1ll</span> * a[i][<span class="number">0</span>] * A.a[<span class="number">0</span>][j]) % mod) % mod;</span><br><span class="line">                B.a[i][j] = (B.a[i][j] + (<span class="number">1ll</span> * a[i][<span class="number">1</span>] * A.a[<span class="number">1</span>][j]) % mod) % mod;</span><br><span class="line">                B.a[i][j] = (B.a[i][j] + (<span class="number">1ll</span> * a[i][<span class="number">2</span>] * A.a[<span class="number">2</span>][j]) % mod) % mod;</span><br><span class="line">                B.a[i][j] = (B.a[i][j] + (<span class="number">1ll</span> * a[i][<span class="number">3</span>] * A.a[<span class="number">3</span>][j]) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>== (Matrix &amp;A) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A.a[i][<span class="number">0</span>] != a[i][<span class="number">0</span>]) <span class="keyword">goto</span> FALSE;</span><br><span class="line">            <span class="keyword">if</span>(A.a[i][<span class="number">1</span>] != a[i][<span class="number">1</span>]) <span class="keyword">goto</span> FALSE;</span><br><span class="line">            <span class="keyword">if</span>(A.a[i][<span class="number">2</span>] != a[i][<span class="number">2</span>]) <span class="keyword">goto</span> FALSE;</span><br><span class="line">            <span class="keyword">if</span>(A.a[i][<span class="number">3</span>] != a[i][<span class="number">3</span>]) <span class="keyword">goto</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        FALSE:<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix opt[<span class="number">7</span>], I;</span><br><span class="line"><span class="type">int</span> A[MAXN], B[MAXN], C[MAXN];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix sum, tag;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) opt[i].<span class="built_in">getI</span>();</span><br><span class="line">    opt[<span class="number">1</span>].a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    opt[<span class="number">2</span>].a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    opt[<span class="number">3</span>].a[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].tag == I) <span class="keyword">return</span>;</span><br><span class="line">    tr[ls].sum = tr[ls].sum * tr[k].tag;</span><br><span class="line">    tr[rs].sum = tr[rs].sum * tr[k].tag;</span><br><span class="line">    tr[ls].tag = tr[ls].tag * tr[k].tag;</span><br><span class="line">    tr[rs].tag = tr[rs].tag * tr[k].tag;</span><br><span class="line">    tr[k].tag.<span class="built_in">getI</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].tag.<span class="built_in">getI</span>();</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum.a[<span class="number">0</span>][<span class="number">0</span>] = A[l];</span><br><span class="line">        tr[k].sum.a[<span class="number">0</span>][<span class="number">1</span>] = B[l];</span><br><span class="line">        tr[k].sum.a[<span class="number">0</span>][<span class="number">2</span>] = C[l];</span><br><span class="line">        tr[k].sum.a[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, Matrix v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum = tr[k].sum * v;</span><br><span class="line">        tr[k].tag = tr[k].tag * v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix Ans;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[k].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) Ans = <span class="built_in">query</span>(ls, l, mid, L, R) + Ans;</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) Ans = <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R) + Ans;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    I.<span class="built_in">getI</span>();</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">read</span>(A[i], B[i], C[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, l, r, v;</span><br><span class="line">        <span class="built_in">read</span>(op, l, r);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, opt[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, opt[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>) <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, opt[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>) <span class="built_in">read</span>(v), opt[<span class="number">4</span>].a[<span class="number">3</span>][<span class="number">0</span>] = v, <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, opt[<span class="number">4</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">5</span>) <span class="built_in">read</span>(v), opt[<span class="number">5</span>].a[<span class="number">1</span>][<span class="number">1</span>] = v, <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, opt[<span class="number">5</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">6</span>) <span class="built_in">read</span>(v), opt[<span class="number">6</span>].a[<span class="number">3</span>][<span class="number">2</span>] = v, opt[<span class="number">6</span>].a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>, <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, opt[<span class="number">6</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Matrix ans = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, ans.a[<span class="number">0</span>][<span class="number">0</span>], ans.a[<span class="number">0</span>][<span class="number">1</span>], ans.a[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><h2 id="ei-的第六分块">EI 的第六分块</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P5693" >洛谷P5693 EI的第六分块</a></p><blockquote><p>给定一个整数序列 <spanclass="math inline">\(a\)</span>，支持两种操作：</p><ol type="1"><li><p><code>1 l r x</code> 表示给区间 <spanclass="math inline">\([l,r]\)</span> 中每个数加上 <spanclass="math inline">\(x\)</span>；</p></li><li><p><code>2 l r</code> 表示查询区间 <spanclass="math inline">\([l,r]\)</span> 的最大子段和（可以为空）。</p></li></ol><p><span class="math inline">\(1\le n,q \le 4\times 10^5\)</span>，<spanclass="math inline">\(|a_i| \le 10^9\)</span>，<spanclass="math inline">\(1 \le x \le 10^6\)</span>。</p></blockquote><p><del>虽然题目名字叫分块，但是我叛逆！</del></p><p>这道题是 <a href="#kinetic-tournament-tree">KTT</a> 板题。</p><p>首先，朴素的<ahref="#维护区间最大子段和">不带修区间最大子段和</a>是很经典的。我们仿照这个问题，依旧维护<span class="math inline">\(sum,ans,pre,suf\)</span>表示区间和、区间最大子段和、前缀最大子段和、后缀最大子段和。</p><p>现在每个变量不再是一个值，而是一个一次函数 <spanclass="math inline">\(y=kx+b\)</span>，我们简记为 <spanclass="math inline">\((k,b)\)</span>。其中 <spanclass="math inline">\(k\)</span> 表示当前区间的长度，<spanclass="math inline">\(b\)</span> 表示初始值。</p><p>如果一次操作之后，区间最优函数没有改变，即修改没有达到最近切换点，那么答案直接变成<span class="math inline">\((kx,b)\)</span> 即可。</p><p>如果当前操作使得区间最优函数改变，那么就直接暴力向下递归。</p><p>现在考虑如何合并。加入我们现在分别有 <spanclass="math inline">\(p=(k_p,b_p),q=(k_q,b_q)\)</span>。不难发现，最近切换点就是两个一次函数的交点。如果焦点在<span class="math inline">\(x\)</span> 负半轴，记为 <spanclass="math inline">\(\inf\)</span> 即可。</p><p>当一次修改超过最近切换点，那么 <spanclass="math inline">\(ans,pre,suf\)</span> 其中至少一个会被改变，取<span class="math inline">\(\min\)</span> 即可。</p><p>具体复杂度分析，详见 <a class="link"  href="https://entropyincreaser.blog.uoj.ac/blog/5217" >EI'sBlog</a>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Func</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">friend</span> Func <span class="keyword">operator</span>+(<span class="type">const</span> Func &amp;A, <span class="type">const</span> Func &amp;B) &#123;<span class="keyword">return</span> &#123;A.k + B.k, A.b + B.b&#125;;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;b += k * x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;Func, <span class="type">int</span>&gt; <span class="title">max</span><span class="params">(Func A, Func B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.k &lt; B.k || A.k == B.k &amp;&amp; A.b &lt; B.b) <span class="built_in">swap</span>(A, B);</span><br><span class="line">    <span class="keyword">if</span>(A.b &gt;= B.b) <span class="keyword">return</span> <span class="built_in">mp</span>(A, INF);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">mp</span>(B, (B.b - A.b) / (A.k - B.k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KTT</span></span><br><span class="line">&#123;</span><br><span class="line">    Func sum, ans, pre, suf;</span><br><span class="line">    <span class="type">int</span> th;</span><br><span class="line">    <span class="keyword">friend</span> KTT <span class="keyword">operator</span>+(<span class="type">const</span> KTT &amp;A, <span class="type">const</span> KTT &amp;B)</span><br><span class="line">    &#123;</span><br><span class="line">        KTT res;</span><br><span class="line">        pair&lt;Func, <span class="type">int</span>&gt; tmp;</span><br><span class="line">        res.th = <span class="built_in">min</span>(A.th, B.th);</span><br><span class="line">        tmp = <span class="built_in">max</span>(A.pre, A.sum + B.pre);</span><br><span class="line">        res.pre = tmp.fi;</span><br><span class="line">        res.th = <span class="built_in">min</span>(res.th, tmp.se);</span><br><span class="line">        tmp = <span class="built_in">max</span>(B.suf, B.sum + A.suf);</span><br><span class="line">        res.suf = tmp.fi;</span><br><span class="line">        res.th = <span class="built_in">min</span>(res.th, tmp.se);</span><br><span class="line">        tmp = <span class="built_in">max</span>(A.ans, B.ans);</span><br><span class="line">        res.th = <span class="built_in">min</span>(res.th, tmp.se);</span><br><span class="line">        tmp = <span class="built_in">max</span>(tmp.fi, A.suf + B.pre);</span><br><span class="line">        res.ans = tmp.fi;</span><br><span class="line">        res.th = <span class="built_in">min</span>(res.th, tmp.se);</span><br><span class="line">        res.sum = A.sum + B.sum;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sum.<span class="built_in">add</span>(v), ans.<span class="built_in">add</span>(v), pre.<span class="built_in">add</span>(v), suf.<span class="built_in">add</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    KTT a;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, Q, A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].a = tr[ls].a + tr[rs].a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].tag += v;</span><br><span class="line">    tr[k].a.th -= v;</span><br><span class="line">    tr[k].a.<span class="built_in">add</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].tag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">f</span>(ls, tr[k].tag), <span class="built_in">f</span>(rs, tr[k].tag);</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        Func c = &#123;<span class="number">1</span>, A[l]&#125;;</span><br><span class="line">        tr[k].a = &#123;c, c, c, c, INF&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">defeat</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= tr[k].a.th) <span class="keyword">return</span> <span class="built_in">f</span>(k, v);</span><br><span class="line">    <span class="built_in">defeat</span>(ls, tr[k].tag + v);</span><br><span class="line">    <span class="built_in">defeat</span>(rs, tr[k].tag + v);</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">defeat</span>(k, v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">KTT <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[k].a;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(rs, mid+ <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(ls, l, mid, L, mid) + <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><h2 id="火事待做">火事（待做）</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P6881" >【JOI2020Final】火事</a></p><blockquote><p>给定一个长为 <span class="math inline">\(N\)</span> 的序列 <spanclass="math inline">\(S_i\)</span>，刚开始为时刻 <spanclass="math inline">\(0\)</span>。定义 <spanclass="math inline">\(t\)</span> 时刻第 <spanclass="math inline">\(i\)</span> 个数为 <spanclass="math inline">\(S_i(t)\)</span>，且满足：</p><p><span class="math display">\[\left\{\begin{array}{ll}S_0(t)=0\\S_i(0)=S_i\\S_i(t)=\max\{S_{i-1}(t-1),S_i(t-1)\}\end{array}\right.\]</span></p><p><span class="math inline">\(Q\)</span> 次询问，每次给定 <spanclass="math inline">\(L,R,T\)</span>，求：</p><p><span class="math display">\[\sum\limits_{k=L}^{R}S_k(T)\]</span></p><p><span class="math inline">\(1\leq N,Q\leq 2\cdot 10^5\)</span>。</p></blockquote><h1 id="参考与鸣谢">参考与鸣谢</h1><h2 id="参考">参考</h2><ol type="1"><li>《妈妈再也不用担心我的线段树了》——孙耀峰；</li><li><a class="link"   href="https://oi-wiki.org/" >OI Wiki</a>；</li><li><a class="link"  href="https://www.luogu.com.cn/blog/dowhiletrue/solution-p4097" >do_while_true的李超树博客</a>；</li><li>RainAir 在 SDSC2023 上的课件；</li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/646644617" >碎月关于 KTT的知乎文章</a>；</li><li>《浅谈函数最值的动态维护》——李白天。</li></ol><h2 id="鸣谢">鸣谢</h2><ol type="1"><li><a class="link"   href="https://www.cnblogs.com/-Complex-/" >EXODUS</a>对本文的勘误与启示；</li><li><a class="link"   href="https://www.cnblogs.com/do-while-true" >do_while_true</a>针对李超线段树的指导。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;《线段树浅记~从 0 开始的线段树生活》&lt;/p&gt;
&lt;p&gt;系统复盘了一下线段树，发现网上现有博客鲜有将线段树各种操作一步一步讲明白的，故结合自己理解写此文。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="线段树" scheme="http://summace.cc/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>SDOI2023 游记</title>
    <link href="http://summace.cc/SDOI2023/"/>
    <id>http://summace.cc/SDOI2023/</id>
    <published>2023-04-30T16:00:00.000Z</published>
    <updated>2023-09-15T01:16:32.659Z</updated>
    
    <content type="html"><![CDATA[<p>体验省选。</p><span id="more"></span><h1 id="day--1">Day -1</h1><p>本来没想到可以来省选，毕竟 NOIP考的太拉了。甚至是正式选手，RMB-700。</p><p>周五中午从学校开润，下午到了平邑。</p><p>然后遇到了百年难得一遇的街区停电。</p><p>晚上去试机，Win7炸场，键盘拉跨，但是和美婷、庞队在一个考场，好耶。</p><h1 id="day1">Day1</h1><p><span class="math inline">\(8:00\)</span>就进考场了，先敲了线段树和快读，不知道能不能用上。</p><p><span class="math inline">\(8:30\)</span> 开考，先瞄一眼题目。T1看起来可做，T2 图论一眼弃，T3 应该能做。</p><p>于是开始写 T1。发现这不是萌萌题吗，省选怎么会出这么简单的题。<spanclass="math inline">\(9:17\)</span> 过了 <spanclass="math inline">\(3\)</span> 个样例，润润润。</p><p>然后就直接开始看T3。想了想，感觉暴力能写，于是开始写暴力，差不多写了两百多行，突然发现暴力思路是寄的。寄寄寄。</p><p>因为本来也没有希望进队，写出来一题感觉十分满足，于是就检查了下T1，一直到 <span class="math inline">\(13:00\)</span> 收卷。</p><p>然后学校统一安排了午饭。这真的是我在学校里吃过的有史以来最丰盛的一次。就是队伍非常long long，排了很久。</p><p>下午摆摆摆。</p><h1 id="day2">Day2</h1><p><span class="math inline">\(8:30\)</span> 开考，先瞄一眼题目。T1过河卒，感觉暴力可做。T2T3 看起来很难，先做 T1。</p><p>T1 的 <span class="math inline">\(20pts\)</span>是好拿的，很顺利拿下来了。</p><p>第二个 <span class="math inline">\(10pts\)</span> 就是红色和黑色1v1，手玩了半天没怎么会，先润。</p><p>然后发现第四个 <span class="math inline">\(20pts\)</span>是能拿的，于是敲了个大暴力。</p><p>T2 把最基本暴力分拿了。T3 想当然认为直接 <spanclass="math inline">\(1 0\)</span> 就行了，然后喜提 <spanclass="math inline">\(0pts\)</span>。</p><p>吃饭，润，美婷身份证丢了，于是陪着美婷润了两遍食堂-考场，很热。</p><p>然后就润回来了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;体验省选。&lt;/p&gt;</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>NOIP2022 爆零记</title>
    <link href="http://summace.cc/NOIP2022/"/>
    <id>http://summace.cc/NOIP2022/</id>
    <published>2022-11-30T16:00:00.000Z</published>
    <updated>2023-09-15T01:16:10.913Z</updated>
    
    <content type="html"><![CDATA[<p>一次愉快的 NOIP，而又是与他们最后的诀别。</p><span id="more"></span><h1 id="day--8">Day -8</h1><p>由于 CSP-S 和高一的同学们脱轨了，因此乖乖回去学whk。本来以为没啥希望了，结果晚上 🍬一通电话通知居然能去了。非常惊讶。但是一段时间没学 OI了，感觉更菜了。就当是体验一下。</p><h1 id="day--7">Day -7</h1><p>要在下午 <span class="math inline">\(17:00\)</span> 之前到平邑，因此<span class="math inline">\(14:30\)</span>就要走。学校要求交艺术节作品，趁上午写了写结果写挂了，气急败坏。RP--。</p><p>然后下午睡了一路之后来到平邑，住在很豪华的全季酒店，感觉从来没住过如此豪华。酒店临着河（好像叫浚河，祊河支流），还算是河景房，环境非常优美。</p><p>睡得很安稳。</p><h1 id="day--6">Day -6</h1><p>上午 vp 了一下 CF，没切出 F，RP--。</p><p>题目里面有道题叫做 The Humanoid，是 ZTMY 歌名，RP++。</p><p>酒店居然有咖啡机。喝了一杯，好苦。</p><h1 id="day--5">Day -5</h1><p>写了几道线段树，感觉对线段树理解更深了一点。</p><p>写了几篇题解，但是发现自己换硬盘重装系统忘了把 Blog文件夹拷过来，只能等 m.2-&gt;usb 买来了在部署了，先写着。</p><p>鸭子可爱捏。</p><p>晚上和 <span class="citation" data-cites="chiptune">@chiptune</span>一起 vp 了一场 abc，没切出来 F，自闭了，RP--。</p><h1 id="day--4">Day -4</h1><p>下雨了。</p><p>测了下分院帽，Slytherin。</p><p>下午 vp 了一场 div4，本来想涨涨信心，结果没 AK，自闭了，RP--。</p><p>鸭子给了一首<a class="link"  href="https://music.163.com/#/song?id=557581315" >好听的歌</a>，单循了，RP++。</p><p>感觉自己菜炸了，模板都不会了。</p><p>调整作息，<span class="math inline">\(22:00\)</span>就睡了，我真规律。</p><h1 id="day--3">Day -3</h1><p>上午敲了敲板子，愣神。</p><p>感觉自己没救了。</p><p>鸭子又给了一首<a class="link"  href="https://music.163.com/#/song?id=1347630432" >好听的歌</a>，单循了，但是没有VIP，气得我满地乱爬。于是从 B 站下载音频上传到云盘，我真聪明。</p><p>写了个攒 RP 的程序，开始跑了。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld, %lld, RP++\n&quot;</span>, i, <span class="built_in">clock</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>梦神锐评：“你是真无聊。”</p><p>晚上头巨疼。不知道为什么。疼死我了。于是早早睡了。</p><p>有点后怕，别上考场再头疼。</p><h1 id="day--2">Day -2</h1><p>🍬 给了一场 GMOJ 的比赛，难炸了，只拿了 B 题 20pts 暴力分。</p><p>查询小w精神状态，结果为：就你还想打 NOIP？</p><p>出考场了，5考场。</p><p>测了一下 mbti，ENFJ-A。</p><p>下午被精度给整自闭了。但是美婷姐姐理我了，很开心，RP++。</p><p>写游记了。</p><h1 id="day--1">Day -1</h1><p>考前最后一天。上午意识到这一点有些紧张。</p><p>然后就肆无忌惮地摆了一天。看了看KMP、逆元，感觉还可以。</p><p>一直到晚上🍬开了个会，希望明天不要自闭吧。</p><p>鸭子请了一杯奶茶，芋泥+珍珠，很好喝。</p><p>领了前瞻的 300 原石，抽了一下，没想到 16抽就出了卢老爷，根据运气守恒定律，感觉明天会寄。</p><p>早点睡觉吧。还是有点紧张。</p><h1 id="day-1">Day 1</h1><p>早上六点起床，早饭没吃凉的，吃的不多，有点担心会不会饿。但是实际上并没有。</p><p>然后就坐（站）着大巴去 pyyz。终于见到 ss,lz1,lzy,zzk,lmt了，很开心。</p><p>带着手机去结果根本没查码。</p><p>上考场先把快读和对拍敲了，结果两个都没用到。</p><p>考试还有个小风波，一开始给的密码不对，后来又给了，导致拖后了十分钟，不过在后面补上了。没想到是双重密码，pdf的密码是一开始给的。</p><p>解压包的密码是 <code>biu#2019miss</code>，是不是在暗示错过了 2019年？（2019刚好疫情开始捏。）</p><p>pdf 的密码是 <code>solo@2022</code>，是不是暗示 2022年单身啊呜呜。</p><p>先看一遍题。T1 感觉可做，T2 是啥啊，名字倒是挺好听的。T3一眼图论，一眼要跑 Tarjan，一眼我不会。T4 一眼大数据结构，一眼不会。</p><p>然后感觉先看看 T1。然后就想到可以对于每列 <spanclass="math inline">\(j\)</span> 的每行 <spanclass="math inline">\(i\)</span>预处理一下最长可以向上延伸多少，然后就可以想到对于每行 <spanclass="math inline">\(i\)</span>维护最多可以向右延伸多少，然后就可以想到统计。但是是 <spanclass="math inline">\(O(n^4)(假设n,m同阶)\)</span> 的。</p><p>然后稍微一考虑就能想到前缀和优化一下到 <spanclass="math inline">\(O(n^2)\)</span>，然后就过了 <spanclass="math inline">\(114\ 514\)</span> 的大样例。好像也没法对拍，大概是<span class="math inline">\(10:00\)</span>，润了。</p><p>然后看了看 T2，感觉是很牛逼的构造，不会。之后 T4暴力跑线段树维护最大值 <span class="math inline">\(O(Qn^2\log n)8pts\)</span> 跑路了。</p><p>之后一直在 T4 和 T2 纠结，感觉都拿不到分。已经有点慌了。</p><p>然后感觉 T2 <span class="math inline">\(k=2n-2\)</span>的部分分好像可做，想了很长时间感觉可以每个分配两种颜色，最后一个栈做闲余栈，写了写过了样例，自己造了几组也过了。</p><p>然后感觉很没有头猪。又一直在想 T2 <spanclass="math inline">\(k=2n-1,n=2\)</span> 的部分分，写了一个 <spanclass="math inline">\(8\)</span> 个 <code>if</code>的大分类讨论，一直调不过去。眼看还有 <spanclass="math inline">\(10min\)</span>，先把东西都整理到 E盘，然后最后两分钟突然调出来了，过了样例，赶紧复制到文件里。感觉差不多了。</p><p>估分 <span class="math inline">\(100+30+0+8=138pts\)</span>，但是T1、T2 都很不稳。</p><p>水杯还落到教室里了，意识到的时候已经走了好几公里了，遂作罢。</p><p>lmt 说能 <span class="math inline">\(255pts\)</span>，结果 T2假了，<span class="math inline">\(200pts\)</span> 左右。</p><p>感觉是打的最烂的一次比赛。</p><p>T2 果然是 zrf 投的题啊……果然恶心。</p><p>luogu 测了一下 T1，过了，感觉安心一点了。</p><p>luogu 和 infoj 测了所有的，一分没挂。感觉是打的最好的一次比赛。</p><h1 id="days-later">Days Later</h1><p>T1 挂了，省二。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一次愉快的 NOIP，而又是与他们最后的诀别。&lt;/p&gt;</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LuoguP1133 教主的花园</title>
    <link href="http://summace.cc/LGP1133/"/>
    <id>http://summace.cc/LGP1133/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:13:14.057Z</updated>
    
    <content type="html"><![CDATA[<p>经典线性dp。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>典型的线性dp，首先考虑二维：</p><p>记 <span class="math inline">\(f_{i,j}\)</span> 表示当前为第 <spanclass="math inline">\(i\)</span> 位，放第 <spanclass="math inline">\(j\)</span> 种树的最大值。</p><p>然后我们发现我们没办法很好地表示树之间的高低关系，于是我们再加一维：</p><p>记 <span class="math inline">\(f_{i,j,0/1}\)</span> 表示当前为第<span class="math inline">\(i\)</span> 位，放第 <spanclass="math inline">\(j\)</span> 种树，当前树比上一位树 <spanclass="math inline">\(0(高)/1(低)\)</span> 的最大值。</p><p>我们可以很顺利地推出转移方程：</p><p><span class="math display">\[f_{i,j,0} = \max\limits_{k&lt;j}\{f_{i-1,k,1}\}\\f_{i,j,0} = \max\limits_{k&gt;j}\{f_{i-1,k,0}\}\]</span></p><p>如果这题只是一条线，那么这题到此为止就已经完成了。但是这道题是在环上，所以我们还要考虑如何处理头和尾。在记一维<span class="math inline">\(s\)</span> 表示第一位是那种树。即变成：</p><p>记 <span class="math inline">\(f_{i,j,s,0/1}\)</span> 表示当前为第<span class="math inline">\(i\)</span> 位，放第 <spanclass="math inline">\(j\)</span> 种树，第一位放 <spanclass="math inline">\(s\)</span> 种树，当前树比上一位树 <spanclass="math inline">\(0(高)/1(低)\)</span> 的最大值。</p><p><span class="math display">\[\text{if}\ \ 2\leq i&lt;n\begin{cases}    f_{i,j,s,0} = \max\limits_{k&lt;j}\{f_{i-1,k,s,1}\}\\    f_{i,j,s,1} = \max\limits_{k&gt;j}\{f_{i-1,k,s,0}\}\\\end{cases}\\\text{if}\ \ i=n\begin{cases}    f_{n,j,s,0} = \max\limits_{k&lt;j}\{f_{n-1,k,s,1}\}&amp; \text{if}\j&gt;s\\    f_{n,j,s,0} = \max\limits_{k&gt;j}\{f_{n-1,k,s,0}\}&amp; \text{if}\j&lt;s\\\end{cases}\]</span></p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN][<span class="number">4</span>], f[MAXN][<span class="number">4</span>][<span class="number">4</span>][<span class="number">2</span>]; <span class="comment">//f(i,j,s,0/1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i][<span class="number">1</span>], &amp;a[i][<span class="number">2</span>], &amp;a[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">f[<span class="number">1</span>][j][j][<span class="number">0</span>] = f[<span class="number">1</span>][j][j][<span class="number">1</span>] = a[<span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt;= <span class="number">3</span>; s++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= <span class="number">3</span>; k++) f[i][j][s][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j][s][<span class="number">1</span>], f[i - <span class="number">1</span>][k][s][<span class="number">0</span>] + a[i][j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--) f[i][j][s][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j][s][<span class="number">0</span>], f[i - <span class="number">1</span>][k][s][<span class="number">1</span>] + a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt;= <span class="number">3</span>; s++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s &lt; j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--) f[n][j][s][<span class="number">0</span>] = <span class="built_in">max</span>(f[n][j][s][<span class="number">0</span>], f[n - <span class="number">1</span>][k][s][<span class="number">1</span>] + a[n][j]);</span><br><span class="line">            <span class="keyword">if</span>(s &gt; j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= <span class="number">3</span>; k++) f[n][j][s][<span class="number">1</span>] = <span class="built_in">max</span>(f[n][j][s][<span class="number">1</span>], f[n - <span class="number">1</span>][k][s][<span class="number">0</span>] + a[n][j]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(f[n][j][s][<span class="number">0</span>], f[n][j][s][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典线性dp。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LuoguP1253 扶苏的问题</title>
    <link href="http://summace.cc/LGP1253/"/>
    <id>http://summace.cc/LGP1253/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:13:32.166Z</updated>
    
    <content type="html"><![CDATA[<p>线段树。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>实际上相当于维护一颗线段树，支持区间覆盖、区间加和区间查询最大值。</p><p>维护最大值很好办，区间覆盖和区间加我们怎么维护呢？</p><p>首先，区间覆盖和区间加一定都分别需要记一个懒标记。我们把区间覆盖的懒标记记为<span class="math inline">\(ctag\)</span>，区间加的懒标记记为 <spanclass="math inline">\(atag\)</span>，那么我们如何把标记 <spanclass="math inline">\(\text{pushdown}\)</span> 呢？</p><p>首先，初始化要选择一个尽量不影响之后操作的值。<spanclass="math inline">\(atag\)</span> 显然选择 <spanclass="math inline">\(0\)</span> 即可。由于要更改的数字有正有负，<spanclass="math inline">\(ctag\)</span> 可以选取 <spanclass="math inline">\(-\infty\)</span>，在程序中我选用了 <spanclass="math inline">\(1e18+7\)</span> 作为 <spanclass="math inline">\(\text{INF}\)</span>。</p><p>考虑到如果我们当前节点有一个 <spanclass="math inline">\(atag\)</span> 标记，之后又打上了一个 <spanclass="math inline">\(ctag\)</span>标记，那么<strong>要覆盖的值会直接把要加的值覆盖</strong>，也就是说<span class="math inline">\(ctag\)</span> 会直接清除 <spanclass="math inline">\(atag\)</span>。而如果先打上 <spanclass="math inline">\(ctag\)</span>，再打上 <spanclass="math inline">\(atag\)</span>，则需要<strong>先把 <spanclass="math inline">\(ctag\)</span> 下放，再下放 <spanclass="math inline">\(atag\)</span></strong>。那么我们的 <spanclass="math inline">\(\text{pushdown}\)</span> 可以这么写：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span> <span class="comment">//把下放的操作封装一下可以使代码更简洁</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx += v;</span><br><span class="line">    t[k].atag += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = v;</span><br><span class="line">    t[k].ctag = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpushdown</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">//ctag 的下放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].ctag == -INF) <span class="keyword">return</span>; <span class="comment">//如果没有标记，返回</span></span><br><span class="line">    t[ls].atag = t[rs].atag = <span class="number">0</span>; <span class="comment">//抹除 atag</span></span><br><span class="line">    <span class="built_in">cf</span>(ls, t[k].ctag), <span class="built_in">cf</span>(rs, t[k].ctag); <span class="comment">//ctag 下放</span></span><br><span class="line">    t[k].ctag = -INF; <span class="comment">//当前节点 ctag 清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apushdown</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">//atag 的下放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].atag == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//如果没有标记，返回</span></span><br><span class="line">    <span class="built_in">cpushdown</span>(k); <span class="comment">//先把 ctag 下放</span></span><br><span class="line">    <span class="built_in">af</span>(ls, t[k].atag), <span class="built_in">af</span>(rs, t[k].atag); <span class="comment">//atag 下放</span></span><br><span class="line">    t[k].atag = <span class="number">0</span>; <span class="comment">//当前节点 atag 清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">apushdown</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次 pushdown 操作包括 ctag 的下放和 atag 的下放，都要进行</span></span><br></pre></td></tr></table></figure></div><p>那么操作呢？区间加操作和之前一样即可，区间覆盖操作需要清除当前节点的<span class="math inline">\(atag\)</span>。</p><p>其他部分即为普通线段树模板。</p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxx;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> atag, ctag;</span><br><span class="line">&#125;t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = <span class="built_in">max</span>(t[ls].maxx, t[rs].maxx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx += v;</span><br><span class="line">    t[k].atag += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = v;</span><br><span class="line">    t[k].ctag = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].ctag == -INF) <span class="keyword">return</span>;</span><br><span class="line">    t[ls].atag = t[rs].atag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cf</span>(ls, t[k].ctag), <span class="built_in">cf</span>(rs, t[k].ctag);</span><br><span class="line">    t[k].ctag = -INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].atag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">af</span>(ls, t[k].atag), <span class="built_in">af</span>(rs, t[k].atag);</span><br><span class="line">    t[k].atag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">apushdown</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].l = l;</span><br><span class="line">    t[k].r = r;</span><br><span class="line">    t[k].atag = <span class="number">0</span>;</span><br><span class="line">    t[k].ctag = -INF;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].maxx = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">af</span>(k, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].atag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cf</span>(k, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">cover</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">cover</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r) <span class="keyword">return</span> t[k].maxx;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(ls, l, r));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(rs, l, r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">cover</span>(<span class="number">1</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;线段树。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="http://summace.cc/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>NOI2013 快餐店</title>
    <link href="http://summace.cc/LGP1399/"/>
    <id>http://summace.cc/LGP1399/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:13:54.705Z</updated>
    
    <content type="html"><![CDATA[<p>图片炸了，难过。本地也没有存。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>一道很经典的基环树上dp题。<del>调了一年</del>。</p><p>首先，如果没有环的话，这就是一道简单的求树上重心的题目。众所周知，树的重心一定在直径的中点上。</p><p>但是现在在一个基环树上做，应该怎么求呢？我们先画一个图：</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://c2.im5i.com/2022/09/23/HW8Pz.png"                      alt="基环树"                 ><figcaption aria-hidden="true">基环树</figcaption></figure><p>为了方便，我们先设边权全部为 <spanclass="math inline">\(1\)</span>。</p><p>首先，我们可以想到断一条环上的边，然后求断边后的树的直径。</p><blockquote><p>略证：考虑到直径一定不会经过一整个环，所以依次断边后求直径一定不会漏掉真正的直径。</p></blockquote><p>这样的复杂度是 <span class="math inline">\(O(n^2)\)</span>的，我们考虑一下如何优化。</p><p>在刚刚的过程中，我们从环上的第一条边一直到最后一条边依次断开，而我们每次断开都要重新计算一次直径，这中间显然是有重合的部分的，于是我们可以考虑用类似于dp 的东西优化。</p><p>考虑有两种情况:</p><ol type="1"><li>直径没有经过环；</li><li>直径经过了环。</li></ol><p>第一个情况很好搞，第二种情况略有麻烦，也是我们刚刚复杂度的瓶颈所在。</p><p>先上结论：</p><ul><li>记 <span class="math inline">\(pre_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之前某以环上节点为根节点的子树的直径加上该点距离环上 <spanclass="math inline">\(1\)</span> 号点的距离的最大值；</li><li>记 <span class="math inline">\(suf_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之后某以环上节点为根节点的子树的直径加上该点距离环上 <spanclass="math inline">\(m\)</span> 号点的距离的最大值；</li><li>记 <span class="math inline">\(pres_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之前环上某两节点的子树直径加上两点之间的距离的最大值；</li><li>记 <span class="math inline">\(sufs_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之后环上某两节点的子树直径加上两点之间的距离的最大值；</li><li>记 <span class="math inline">\(w_{(i,j)}\)</span> 表示 <spanclass="math inline">\(i,j\)</span> 两点的距离。</li></ul><p>那么第 <span class="math inline">\(i\)</span> 号点的答案即为 <spanclass="math inline">\(\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\)</span>。</p><p>最终答案即为 <spanclass="math inline">\(\min\limits_{i=1}^{m-1}\{\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\}\)</span></p><p>是不是到现在已经有些晕了？没关系，我们从图上举例说明一下。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://c2.im5i.com/2022/09/23/HX5t8.png"                      alt="删边"                 ><figcaption aria-hidden="true">删边</figcaption></figure><p>例如，我们现在有一只删了一条环边 <spanclass="math inline">\((4,5)\)</span> 的基环树。</p><p>我们仔细复盘一下刚刚的几句话。</p><p>先看 <span class="math inline">\(pre_i\)</span> 和 <spanclass="math inline">\(suf_i\)</span>。由于两个很像，所以重点解释 <spanclass="math inline">\(pre_i\)</span>。</p><blockquote><p>记 <span class="math inline">\(pre_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 点之前 <spanclass="math inline">\(//\)</span> 某以环上节点为根节点的子树的直径 <spanclass="math inline">\(//\)</span> 加上该点距离环上 <spanclass="math inline">\(1\)</span> 号点的距离 <spanclass="math inline">\(//\)</span> 的最大值。</p></blockquote><p>形式化的来说，我们要找的就是：</p><p><spanclass="math inline">\(pre_i=\max\limits_{j=1}^{i}\{dep_j+w_{(1,j)}\}\)</span></p><p>来看张图。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://c2.im5i.com/2022/09/23/H21O4.png"                      alt="pre和suf"                 ><figcaption aria-hidden="true">pre和suf</figcaption></figure><p><em>可能有多种方案，图中仅展示一种。</em></p><p>图中绿色的部分即为 <spanclass="math inline">\(pre_4\)</span>，橙色的部分即为 <spanclass="math inline">\(suf_5\)</span>。</p><p>可以看出来 <span class="math inline">\(pre_i\)</span> 和 <spanclass="math inline">\(suf_i\)</span> 其实就是一棵子树的直径 <spanclass="math inline">\(+\)</span> 它前面（后面）的链的长度。</p><p>接下来再看看 <span class="math inline">\(pres_i\)</span> 和 <spanclass="math inline">\(sufs_i\)</span>，同样重点解释 <spanclass="math inline">\(pres_i\)</span>。</p><blockquote><p>记 <span class="math inline">\(pres_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 点之前 <spanclass="math inline">\(//\)</span> 环上某两节点的子树直径 <spanclass="math inline">\(//\)</span> 加上两点之间的距离的最大值。</p></blockquote><p>形式化的来说，我们要找的就是：</p><p><spanclass="math inline">\(pres_i=\max\limits_{j=1}^{i}\{dep_i+dep_j+w_{(i,j)}\}\)</span></p><p>再来看张图。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://c2.im5i.com/2022/09/23/H2fal.png"                      alt="pres和sufs"                 ><figcaption aria-hidden="true">pres和sufs</figcaption></figure><p><em>可能有多种方案，图中仅展示一种。</em></p><p>图中蓝色的部分即为 <spanclass="math inline">\(pres_4\)</span>，黄色的部分即为 <spanclass="math inline">\(sufs_5\)</span>。</p><p>好，弄清楚这 <span class="math inline">\(4\)</span>个，我们来看看结果的式子：</p><blockquote><p>那么第 <span class="math inline">\(i\)</span> 号点的答案即为 <spanclass="math inline">\(\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\)</span>。</p></blockquote><p>我们考虑到删掉边 <span class="math inline">\((i,i+1)\)</span>的时候，直径有三种可能：</p><ol type="1"><li>直径在 <span class="math inline">\([1,i]\)</span> 之间；</li><li>直径在 <span class="math inline">\([i+1,m]\)</span> 之间；</li><li>直径跨过了边 <span class="math inline">\((1,m)\)</span>。</li></ol><p>对于第一种情况，我们惊喜地发现，<spanclass="math inline">\(pres_i\)</span> 即为我们所求。</p><p>对于第二种情况，我们再次惊喜地发现，<spanclass="math inline">\(sufs_{i+1}\)</span> 即为我们所求。</p><p>对于第三种情况，我们发现，由于 <spanclass="math inline">\(pre_i\)</span> 一直延伸到 <spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(suf_{i+1}\)</span> 一直延伸到 <spanclass="math inline">\(m\)</span>，所以我们再加上 <spanclass="math inline">\(w_{(1,m)}\)</span> 即可，也就是 <spanclass="math inline">\(pre_i+suf_{i+1}+w_{(1,m)}\)</span>。</p><p>最后我们遍历一遍，统计最小值即可。</p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt, w;</span><br><span class="line">&#125;e[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], ent;</span><br><span class="line"><span class="type">int</span> fa[MAXN], tnt, dfn[MAXN], dis[MAXN];</span><br><span class="line"><span class="type">bool</span> iscyc[MAXN];</span><br><span class="line"><span class="type">int</span> cyc[MAXN], cnt, cycdis[MAXN];</span><br><span class="line">ll dep[MAXN];</span><br><span class="line">ll pre[MAXN], suf[MAXN], presub[MAXN], sufsub[MAXN];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++ent].to = v;</span><br><span class="line">    e[ent].w = w;</span><br><span class="line">    e[ent].nxt = head[u];</span><br><span class="line">    head[u] = ent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++tnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[v] = u;</span><br><span class="line">            dis[v] = e[i].w;</span><br><span class="line">            <span class="built_in">dfs1</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &gt; dfn[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(; v != u; v = fa[v])</span><br><span class="line">            &#123;</span><br><span class="line">                iscyc[v] = <span class="literal">true</span>;</span><br><span class="line">                cyc[++cnt] = v;</span><br><span class="line">                cycdis[cnt] = dis[v];</span><br><span class="line">            &#125;</span><br><span class="line">            iscyc[u] = <span class="literal">true</span>;</span><br><span class="line">            cyc[++cnt] = u;</span><br><span class="line">            cycdis[cnt] = e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!iscyc[v] &amp;&amp; v != father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">            ans = <span class="built_in">max</span>((ll)dep[u] + dep[v] + e[i].w, ans);</span><br><span class="line">            dep[u] = <span class="built_in">max</span>(dep[u], dep[v] + e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add_edge</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add_edge</span>(b, a, c);</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="built_in">dfs2</span>(cyc[i], <span class="number">0</span>);</span><br><span class="line">    ll sum = <span class="number">0</span>, maxdep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += cycdis[i - <span class="number">1</span>];</span><br><span class="line">        pre[i] = <span class="built_in">max</span>(pre[i - <span class="number">1</span>], dep[cyc[i]] + sum);</span><br><span class="line">        presub[i] = <span class="built_in">max</span>(presub[i - <span class="number">1</span>], sum + maxdep + dep[cyc[i]]);</span><br><span class="line">        maxdep = <span class="built_in">max</span>(maxdep, dep[cyc[i]] - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    sum = maxdep = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp = cycdis[cnt];</span><br><span class="line">    cycdis[cnt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += cycdis[i];</span><br><span class="line">        suf[i] = <span class="built_in">max</span>(suf[i + <span class="number">1</span>], dep[cyc[i]] + sum);</span><br><span class="line">        sufsub[i] = <span class="built_in">max</span>(sufsub[i + <span class="number">1</span>], sum + maxdep + dep[cyc[i]]);</span><br><span class="line">        maxdep = <span class="built_in">max</span>(maxdep, dep[cyc[i]] - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = presub[cnt];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">        res = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(presub[i], sufsub[i + <span class="number">1</span>]), pre[i] + suf[i + <span class="number">1</span>] + tmp), res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>, (<span class="type">double</span>)<span class="built_in">max</span>(ans, res) / <span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;图片炸了，难过。本地也没有存。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>HAOI2012 高速公路</title>
    <link href="http://summace.cc/LGP2221/"/>
    <id>http://summace.cc/LGP2221/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:14:16.861Z</updated>
    
    <content type="html"><![CDATA[<p>一道非常好的线段树题。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>优先想到线段树，考虑怎么维护。</p><p>记第 <span class="math inline">\(i\)</span> 到第 <spanclass="math inline">\(i+1\)</span> 条边为第 <spanclass="math inline">\(i\)</span> 条边，将问题转化成维护 <spanclass="math inline">\(n-1\)</span> 个数。</p><p>那么，我们维护一个前缀和 <spanclass="math inline">\(sum\)</span>，根据题意：</p><p><span class="math display">\[Ans=\frac{\sum\limits_{i=l}^{r}\sum\limits_{j=l}^{r}sum_j-sum_i}{\binom{r-l+1}{2}}(i\neqj)\]</span></p><p>下面的东西很好算，重点是上面的东西怎么维护。</p><p>我们把上面的东西记作 <spanclass="math inline">\(ans\)</span>，考虑枚举每条边被计算的次数，可以理解成枚举每个点左右两条路。</p><p>所以：</p><p><span class="math display">\[\begin{split}ans &amp;=\sum\limits_{i=l}^{r}a_i\times (r-i+1)(i-l+1)\\    &amp;=\sum\limits_{i=l}^{r}a_i\times (ir-lr+r-i^2+il-i+i-l+1)\\    &amp;=\sum\limits_{i=l}^{r}a_i\times (-i^2+(l+r)i-lr+r-l+1)\\    &amp;=-\sum\limits_{i=l}^{r}a_i\timesi^2+(l+r)\sum\limits_{i=l}^{r}a_i\timesi+(r-l-lr+1)\sum\limits_{i=l}^{r}a_i\end{split}\]</span></p><p>现在需要维护 <spanclass="math inline">\(sum_1=\sum_{i=l}^{r}a_i\times i^2\)</span>，<spanclass="math inline">\(sum_2=\sum_{i=l}^{r}a_i\times i\)</span>，<spanclass="math inline">\(sum_3=\sum_{i=l}^{r}a_i\)</span>。</p><p>即变成：</p><p><spanclass="math display">\[ans=-sum1+(l+r)sum2+(r-l-lr+1)sum3\]</span></p><p>考虑 <code>pushup</code> 的时候，直接相加就可以了。</p><p>考虑在区间 <span class="math inline">\([L,R]\)</span> 加上一个 <spanclass="math inline">\(x\)</span> 的时候怎么做：</p><p><span class="math display">\[\begin{split}sum_3&#39;&amp;= \sum\limits_{i=L}^{R}(a_i+x)\\&amp;= (R-L+1)x+\sum\limits_{i=L}^{R}a_i\\&amp;= (R-L+1)x+sum_3\\\Delta sum_3 &amp;= (R-L+1)x\end{split}\]</span></p><p>直接维护。</p><p><span class="math display">\[\begin{split}sum_2&#39;&amp;= \sum\limits_{i=L}^{R}i(a_i+x)\\&amp;= \sum\limits_{i=L}^{R}i\times a_i+\sum\limits_{i=L}^{R}ix\\&amp;= \sum\limits_{i=L}^{R}i\times a_i+x\sum\limits_{i=L}^{R}i\\&amp;= x\sum\limits_{i=L}^{R}i+sum_2\\\Delta sum_2 &amp;= x\sum\limits_{i=L}^{R}i\end{split}\]</span></p><p>维护区间和。</p><p><span class="math display">\[\begin{split}sum_1&#39;&amp;= \sum\limits_{i=L}^{R}i^2(a_i+x)\\&amp;= \sum\limits_{i=L}^{R}i^2\times a_i+\sum\limits_{i=L}^{R}i^2x\\&amp;= \sum\limits_{i=L}^{R}i^2\times a_i+x\sum\limits_{i=L}^{R}i^2\\&amp;= x\sum\limits_{i=L}^{R}i^2+sum_1\\\Delta sum_1 &amp;= x\sum\limits_{i=L}^{R}i^2\end{split}\]</span></p><p>维护区间平方和。</p><p>最后求期望约分即可。</p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans1, ans2, ans3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum1, sum2, sum3, sum4, sum5;</span><br><span class="line">            <span class="type">int</span> lazy;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">        &#125;tree[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].lazy += v;</span><br><span class="line">tree[k].sum1 += (tree[k].r - tree[k].l + <span class="number">1</span>) * v;</span><br><span class="line">            tree[k].sum2 += v * tree[k].sum5;</span><br><span class="line">            tree[k].sum3 += v * tree[k].sum4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].sum1 = tree[<span class="built_in">lc</span>(k)].sum1 + tree[<span class="built_in">rc</span>(k)].sum1;</span><br><span class="line">            tree[k].sum2 = tree[<span class="built_in">lc</span>(k)].sum2 + tree[<span class="built_in">rc</span>(k)].sum2;</span><br><span class="line">            tree[k].sum3 = tree[<span class="built_in">lc</span>(k)].sum3 + tree[<span class="built_in">rc</span>(k)].sum3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">lc</span>(k), tree[k].lazy);</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">rc</span>(k), tree[k].lazy);</span><br><span class="line">tree[k].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].lazy = <span class="number">0</span>;</span><br><span class="line">            tree[k].l = l;</span><br><span class="line">            tree[k].r = r;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[k].sum4 = l * l;</span><br><span class="line">                tree[k].sum5 = l;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">lc</span>(k), l, mid);</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r);</span><br><span class="line">tree[k].sum4 = tree[<span class="built_in">lc</span>(k)].sum4 + tree[<span class="built_in">rc</span>(k)].sum4;</span><br><span class="line">            tree[k].sum5 = tree[<span class="built_in">lc</span>(k)].sum5 + tree[<span class="built_in">rc</span>(k)].sum5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= tree[k].l &amp;&amp; tree[k].r &lt;= R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">f</span>(k, v);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(k);</span><br><span class="line"><span class="type">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(k), L, R, v);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(k), L, R, v);</span><br><span class="line"><span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= tree[k].l &amp;&amp; tree[k].r &lt;= R)</span><br><span class="line">            &#123;</span><br><span class="line">                ans1 += tree[k].sum1;</span><br><span class="line">                ans2 += tree[k].sum2;</span><br><span class="line">                ans3 += tree[k].sum3;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="built_in">pushdown</span>(k);</span><br><span class="line"><span class="type">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) <span class="built_in">query</span>(<span class="built_in">lc</span>(k), L, R);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) <span class="built_in">query</span>(<span class="built_in">rc</span>(k), L, R);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> l, r, v;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        r--;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;v);</span><br><span class="line">            t.<span class="built_in">update</span>(<span class="number">1</span>, l, r, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans1 = ans2 = ans3 = <span class="number">0</span>;</span><br><span class="line">            t.<span class="built_in">query</span>(<span class="number">1</span>, l, r);</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            a = (r - l + <span class="number">1</span> - r * l) * ans1 + (r + l) * ans2 - ans3;</span><br><span class="line">            b = (r - l + <span class="number">2</span>) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            c = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; l &lt;&lt; r &lt;&lt; b;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, a / c, b / c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道非常好的线段树题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="http://summace.cc/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>SDOI2006 保安站岗</title>
    <link href="http://summace.cc/LGP2458/"/>
    <id>http://summace.cc/LGP2458/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:14:41.830Z</updated>
    
    <content type="html"><![CDATA[<p>一道很经典的树形dp题目。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>很明显的树形dp，先把方程设出来：</p><p><span class="math inline">\(f_{x,0/1/2}\)</span> 表示当前节点为 <spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(0(自己覆盖)/1(儿子覆盖)/2(父亲覆盖)\)</span>，且其子节点都已全部覆盖的最小权值。</p><p>很套路的树形dp方程，分别考虑如何转移：</p><p>记 <span class="math inline">\(son(i)\)</span> 表示 <spanclass="math inline">\(i\)</span> 的所有子节点，<spanclass="math inline">\(k_i\)</span> 表示控制 <spanclass="math inline">\(i\)</span> 点所需的代价。</p><h2 id="f_x0自己覆盖">1. <spanclass="math inline">\(f_{x,0}\)</span>（自己覆盖）</h2><p><span class="math inline">\(f_{x,0} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1},f_{y,2}\}+k_x\)</span></p><p>解释：由于当前节点自己覆盖自己，所以不需考虑其他的节点，在所有子节点中找到最小值转移即可。</p><h2 id="f_x1儿子覆盖">2. <spanclass="math inline">\(f_{x,1}\)</span>（儿子覆盖）</h2><p><span class="math inline">\(f_{x,1} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\}\)</span></p><p>解释：当当前节点被儿子覆盖时，说明当前节点不可能覆盖儿子节点，也就无法从<span class="math inline">\(f_{y,2}\)</span> 转移。</p><p>但是有一种这样的情况：当儿子节点全部选择 <spanclass="math inline">\(f_{y,1}\)</span>时，即儿子节点全部被它的儿子节点覆盖，在这种情况下 <spanclass="math inline">\(x\)</span> 节点无法被儿子节点覆盖。</p><p>所以我们在转移的时候记一个 <span class="math inline">\(q\)</span>表示是否全部选择的 <spanclass="math inline">\(f_{y,1}\)</span>，如果是，则强制选择一个节点让其选择<spanclass="math inline">\(f_{y,0}\)</span>。我们要向最小化代价，显然要让强制选择的节点<span class="math inline">\(f_{y,0}\)</span> 与 <spanclass="math inline">\(f_{y,1}\)</span>的差值最小。所以现在转移方程如下：</p><p><span class="math inline">\(f_{x,1} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\},\text{if all choose }f_{y,1},\text{then}+\min\limits_{y\inson(x)}\{f_{y,0}-f_{y,1}\}\)</span></p><h2 id="f_x2父亲覆盖">3. <spanclass="math inline">\(f_{x,2}\)</span>（父亲覆盖）</h2><p><span class="math inline">\(f_{x,2} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\}\)</span></p><p>解释：这个就比较简单了，当当前节点被父亲覆盖，直接从可能的方式转移即可。</p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125;e[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], k[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = k[x];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, minn = INF;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">        f[x][<span class="number">0</span>] += <span class="built_in">min</span>(f[y][<span class="number">0</span>], <span class="built_in">min</span>(f[y][<span class="number">1</span>], f[y][<span class="number">2</span>]));</span><br><span class="line">        f[x][<span class="number">2</span>] += <span class="built_in">min</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> tmp = <span class="built_in">min</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">        f[x][<span class="number">1</span>] += tmp;</span><br><span class="line">        <span class="keyword">if</span>(tmp == f[y][<span class="number">0</span>]) flag = <span class="literal">false</span>;</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, f[y][<span class="number">0</span>] - f[y][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) f[x][<span class="number">1</span>] += minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">        k[x] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add_edge</span>(x, y);</span><br><span class="line">            <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道很经典的树形dp题目。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>CTSC2012 电阻网络</title>
    <link href="http://summace.cc/LGP4020/"/>
    <id>http://summace.cc/LGP4020/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:15:18.541Z</updated>
    
    <content type="html"><![CDATA[<p>在各学科交叉应用的潮流下，一道具有超前预见性的好题。</p><span id="more"></span><h1 id="solution">Solution</h1><h2 id="前置知识">前置知识</h2><h3 id="欧姆定律">欧姆定律</h3><p>在同一电路中，通过某段导体的电流跟这段导体两端的电压成正比，跟这段导体的电阻成反比。</p><p><span class="math display">\[I=\frac{U}{R}\]</span></p><p>其中 <span class="math inline">\(I\)</span> 为电流，<spanclass="math inline">\(U\)</span> 为电压，<spanclass="math inline">\(R\)</span> 为电阻。</p><h3 id="基尔霍夫第一定律">基尔霍夫第一定律</h3><p>会合于任意节点的电流和等于零。</p><p><span class="math display">\[\sum I=0\]</span></p><h2 id="solution-1">Solution</h2><p>本题中全部为相同电阻，所以答案与电阻大小无关，记电阻大小为 <spanclass="math inline">\(R\)</span>，钦定一个叶子节点为根。</p><p>考虑第 <span class="math inline">\(i\)</span> 个节点，记 <spanclass="math inline">\(i\)</span> 的父亲为 <spanclass="math inline">\(fa\)</span>，儿子集合为 <spanclass="math inline">\(son\)</span>，<spanclass="math inline">\(fa\rightarrow i\)</span> 的电流为 <spanclass="math inline">\(I_i\)</span>。</p><p>则从 <span class="math inline">\(fa\)</span> 到 <spanclass="math inline">\(i\)</span>的过程中，电势差的产生可以看作两部分，一部分是电阻导致的电势的下降，一部分是电源导致的电势的上升，这两部分之和等于电势差。即：</p><p><spanclass="math display">\[\varphi_i=\varphi_{fa}-I_iR+E_i\]</span></p><p>移项得：</p><p><spanclass="math display">\[I_i=\frac{\varphi_{fa}-\varphi_i+E_i}{R}\]</span></p><p>这是 <span class="math inline">\(i\)</span>祖先方向的电流，同理，对于儿子方向的任意 <spanclass="math inline">\(x\in son\)</span>，我们有：</p><p><spanclass="math display">\[\varphi_x=\varphi_{i}-I_xR+E_x\]</span></p><p>得：</p><p><spanclass="math display">\[I_x=\frac{\varphi_{i}-\varphi_x+E_x}{R}\]</span></p><p>求和得：</p><p><span class="math display">\[\sum\limits_{x\inson}I_x=\sum\limits_{x\inson}\frac{\varphi_{i}-\varphi_x+E_x}{R}\]</span></p><p>根据基尔霍夫第一定律：</p><p><span class="math display">\[I_i=\sum\limits_{x\inson}I_x\]</span></p><p>即：</p><p><spanclass="math display">\[\frac{\varphi_{fa}-\varphi_i+E_i}{R}=\sum\limits_{x\inson}\frac{\varphi_{i}-\varphi_x+E_x}{R}\]</span></p><p>继续化简：</p><p><spanclass="math display">\[\varphi_{fa}-\varphi_i+E_i=\sum\limits_{x\inson}(\varphi_{i}-\varphi_x+E_x)\]</span></p><p><spanclass="math display">\[\varphi_{fa}-\varphi_i+E_i=|son|\varphi_i-\sum\limits_{x\inson}(\varphi_x-E_x)\]</span></p><p><spanclass="math display">\[(|son|+1)\varphi_i=\varphi_{fa}+E_i+\sum\limits_{x\inson}(\varphi_x-E_x)\]</span></p><p>注意到 <span class="math inline">\(|son|\)</span>是儿子集合，相当于当前节点向儿子方向的度数；<spanclass="math inline">\(1\)</span> 相当于当前节点向父亲方向的度数，所以<span class="math inline">\(|son|+1\)</span> 实际上相当于节点 <spanclass="math inline">\(i\)</span> 的度数，记为 <spanclass="math inline">\(\deg_i\)</span>。</p><p><spanclass="math display">\[\deg_i\varphi_i=\varphi_{fa}+E_i+\sum\limits_{x\inson}(\varphi_x-E_x)\]</span></p><p>设 <spanclass="math inline">\(\varphi_i=K_i\varphi_{fa}+B_i\)</span>，其中 <spanclass="math inline">\(K_i,B_i\)</span> 都是只与 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(son\)</span> 有关的常量。</p><p>把 <span class="math inline">\(\varphi_x\)</span>用刚刚的形式表示出来：</p><p><spanclass="math display">\[\varphi_x=K_x\varphi_{i}+B_x\]</span></p><p>代入原式：</p><p><spanclass="math display">\[\varphi_i=\frac{\varphi_{fa}+E_i+\sum\limits_{x\inson}(K_x\varphi_{i}+B_x-E_x)}{\deg_i}\]</span></p><p>把这个式子表示成刚刚的形式：</p><p><spanclass="math display">\[\deg_i\varphi_i=\varphi_{fa}+E_i+\sum\limits_{x\inson}(K_x\varphi_{i}+B_x-E_x)\]</span></p><p><spanclass="math display">\[\deg_i\varphi_i=\varphi_{fa}+E_i+\varphi_i\sum\limits_{x\inson}K_x+\sum\limits_{x\in son}(B_x-E_x)\]</span></p><p><span class="math display">\[\varphi_i(\deg_i-\sum\limits_{x\inson}K_x)=\varphi_{fa}+E_i+\sum\limits_{x\in son}(B_x-E_x)\]</span></p><p><spanclass="math display">\[\varphi_i=\frac{1}{\deg_i-\sum\limits_{x\inson}K_x}\varphi_{fa}+\frac{\sum\limits_{x\inson}(B_x-E_x)+E_i}{\deg_i-\sum\limits_{x\in son}K_x}\]</span></p><p>我们发现此时已经表示成 <spanclass="math inline">\(\varphi_i=K_i\varphi_{fa}+B_i\)</span>的形式了。那么：</p><p><span class="math display">\[K_i=\frac{1}{\deg_i-\sum\limits_{x\inson}K_x}\]</span></p><p><span class="math display">\[B_i=\frac{\sum\limits_{x\inson}(B_x-E_x)+E_i}{\deg_i-\sum\limits_{x\inson}K_x}=K_i(\sum\limits_{x\in son}(B_x-E_x)+E_i)\]</span></p><p>因为我们要求 <span class="math inline">\(i\)</span>到地面，所以特判一下叶子。叶子度数为 <spanclass="math inline">\(2\)</span>，一条边连向地面，地面电势为 <spanclass="math inline">\(0\)</span>。</p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="type">int</span> rt, n, m;</span><br><span class="line"><span class="type">int</span> deg[MAXN], fa[MAXN];</span><br><span class="line"><span class="type">double</span> k[MAXN], b[MAXN], sumb[MAXN], ph[MAXN], sumph[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt] = (Edge)&#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    edge[++cnt] = (Edge)&#123;u, head[v]&#125;;</span><br><span class="line">    head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    <span class="type">double</span> sumk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v != f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">init</span>(v, u);</span><br><span class="line">            sumk += k[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k[u] = <span class="number">1.0</span> / (deg[u] - sumk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sumb[fa[u]] -= b[u];</span><br><span class="line">        b[u] = (sumb[u] + sumph[u] - ph[u]) * k[u];</span><br><span class="line">        sumb[fa[u]] += b[u];</span><br><span class="line">        <span class="built_in">add</span>(fa[u], e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[v] == u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">        e = -e;</span><br><span class="line">    &#125;</span><br><span class="line">    ph[u] -= e;</span><br><span class="line">    sumph[v] -= e;</span><br><span class="line">    <span class="built_in">add</span>(u, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> k[u] * <span class="built_in">query</span>(fa[u]) + b[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v);</span><br><span class="line">        deg[u]++, deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_edge</span>(i, <span class="number">0</span>);</span><br><span class="line">            deg[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">1</span>) deg[i] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, <span class="built_in">query</span>(u));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u, v, e;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;e);</span><br><span class="line">            <span class="built_in">modify</span>(u, v, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在各学科交叉应用的潮流下，一道具有超前预见性的好题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="物理" scheme="http://summace.cc/tags/%E7%89%A9%E7%90%86/"/>
    
    <category term="数学" scheme="http://summace.cc/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="递推" scheme="http://summace.cc/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
</feed>
