<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏花盛开，佑浅浅而归</title>
  
  <subtitle>夏佑随记</subtitle>
  <link href="http://summace.cc/atom.xml" rel="self"/>
  
  <link href="http://summace.cc/"/>
  <updated>2023-09-26T12:08:23.372Z</updated>
  <id>http://summace.cc/</id>
  
  <author>
    <name>夏佑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈希学习笔记（NJU）</title>
    <link href="http://summace.cc/Hashing-Sketching/"/>
    <id>http://summace.cc/Hashing-Sketching/</id>
    <published>2023-09-25T16:00:00.000Z</published>
    <updated>2023-09-26T12:08:23.372Z</updated>
    
    <content type="html"><![CDATA[<p>南京大学研究生课程 Advanced Algorithm。</p><span id="more"></span><h1 id="birthday-paradox">Birthday Paradox</h1><p>在一个 <span class="math inline">\(m&gt;57\)</span>人的班里，有两个人生日相同的概率 <spanclass="math inline">\(&gt;99\%\)</span>。</p><p>形式化地说：<span class="math inline">\(n\)</span> 个球放进 <spanclass="math inline">\(m\)</span> 个箱子。定义事件 <spanclass="math inline">\(\mathscr{E}\)</span>：每个箱子有 <spanclass="math inline">\(\leq 1\)</span> 个球。</p><p><span class="math display">\[\Pr[\mathscr{E}]=\prod\limits_{i=0}^{n-1}\left(1-\dfrac{i}{m}\right)\approxe^{-n^2/2m}\]</span></p><p><span class="math display">\[\text{when}\ n=\sqrt{2m\ln\dfrac{1}{p}}\Rightarrow\Pr[\mathscr{E}]=(1\pmo(1))p\]</span></p><h1 id="hashing">Hashing</h1><h2 id="simple-uniform-hash-assumption">Simple Uniform HashAssumption</h2><p>完美哈希。使用随机哈希函数。简称 SUHA。</p><p><span class="math inline">\(m=n^2\)</span> 的空间，可以做到冲突概率<span class="math inline">\(&lt;\dfrac{1}{2}\)</span>（生日悖论）的概率完美哈希。</p><h2 id="k-universal-hash-family">k-Universal Hash Family</h2><p>称哈希函数 <span class="math inline">\(U\rightarrow [m]\)</span> 的family <span class="math inline">\(\mathscr{H}\)</span> 是 k-universal的，当对于一些不同的 <span class="math inline">\(x_1\cdots x_k\inU\)</span>，满足：</p><p><span class="math display">\[\Pr\limits_{h\in \mathscr{H}}[h(x_1)=\cdots =h(x_k)]\leq \dfrac{1}{m^{k-1}}\]</span></p><h2 id="linear-congruential-hashing">Linear Congruential Hashing</h2><p>线性同余哈希：<span class="math inline">\(h_{a,b}(x)=((ax+b)\bmodp)\bmod m\)</span></p><h2 id="back-to-birthday-paradox">Back to Birthday Paradox</h2><p>用 2-universal hashing 解释。</p><p>总 collision pairs：</p><p><span class="math display">\[Y=\sum\limits_{i&lt;j}I[X_i=X_j]\]</span></p><p>其线性期望</p><p><span class="math display">\[\mathbb{E}[Y]=\sum\limits_{i&lt;j}\Pr[X_i=X_j]\leq {n\choose2}\dfrac{1}{m}\]</span></p><blockquote><p>Markov's Inequality：</p><p><span class="math display">\[\Pr[X\geq t]\leq\dfrac{\mathbb{E}[X]}{t}\]</span></p></blockquote><p><span class="math display">\[\Pr[\lnot \mathscr{E}]=\Pr[Y\geq 1]\leq \mathbb{E}[Y]\leq \mathbb{E}\(\text{when}\ n\leq\sqrt{2m\epsilon})\]</span></p><p>因此可以将 SUHA 换为线性同余函数。</p><p>不完美哈希概率 <span class="math inline">\(\leq\dfrac{n(n-1)}{2m}&lt;1\)</span>。因此一定可以找一个哈希方式 <spanclass="math inline">\(h\in \mathscr{H}\)</span> 使得其成为完美哈希，且<span class="math inline">\(\mathscr{H}\)</span> 很小。</p><p>但是空间仍为平方级别。</p><h2 id="fks-prefect-hashing">FKS Prefect Hashing</h2><p>用一个 primary hashing 随机哈希将 <spanclass="math inline">\(N\)</span> 个元素分为 <spanclass="math inline">\(n\)</span> 个 buckets，每个 bucket开一个平方空间的完美哈希表。</p><p>时间复杂度是显然的 <spanclass="math inline">\(O(1)\)</span>，空间呢？</p><p><span class="math inline">\(n\)</span> 个球放进 <spanclass="math inline">\(n\)</span> 个buckets，其平方和为线性的。为什么？因为 collision pairs的期望是线性的。因此期望空间花费为 <spanclass="math inline">\(O(n)\)</span>。</p><p>形式化地说：</p><p><span class="math display">\[\mathbb{E}\left[\sum\limits_{i=1}^{n}|B_i|^2\right]=\dfrac{n(n-1)}{m}+n\leq2n\]</span></p><p>总空间 <span class="math inline">\(O(n\log N)\)</span> bits。</p><h1 id="bloom-filters">Bloom Filters</h1><p>布隆过滤器。用于近似查询。</p><p><span class="math inline">\(k\)</span> 个随机独立哈希函数 <spanclass="math inline">\(h_1\sim h_k:U\rightarrow [m]\)</span>。</p><p>共用一个 bit 串，每次插入映射 <span class="math inline">\(k\)</span>个位置。</p><p>查询时候查询 <span class="math inline">\(k\)</span> 个映射，如果有<spanclass="math inline">\(0\)</span>，则一定不在集合中。否则有概率误判。</p><p>显然，<span class="math inline">\(x\in S\)</span> 总正确。</p><p>错误概率：</p><p><span class="math display">\[\begin{align}\Pr[\forall 1\leq j\leq k:v[h_j(x)]=1]&amp;\leq (1-(1-1/m)^{kn})^k\\&amp;\approx(1-e^{-kn/m})^k\\&amp;=2^{-c\ln 2}\leq (0.6185)^c\end{align}\]</span></p><p>选取 <span class="math inline">\(k=c\ln 2\)</span>。空间 <spanclass="math inline">\(m=cn\)</span> bits，时间 <spanclass="math inline">\(k=c\ln 2\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;南京大学研究生课程 Advanced Algorithm。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="哈希" scheme="http://summace.cc/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="概率论" scheme="http://summace.cc/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>概率论学习笔记（NJU）</title>
    <link href="http://summace.cc/Probability-Theory/"/>
    <id>http://summace.cc/Probability-Theory/</id>
    <published>2023-09-25T16:00:00.000Z</published>
    <updated>2023-09-26T12:54:21.973Z</updated>
    
    <content type="html"><![CDATA[<p>南京大学本科课程概率论。</p><span id="more"></span><h1 id="全概率公式">全概率公式</h1><p>记 <span class="math inline">\(A_i,B\)</span> 为事件，<spanclass="math inline">\(B\)</span> 为结果，<spanclass="math inline">\(A_i\)</span> 为条件，则有全概率公式：</p><p><span class="math display">\[P(B)=\sum\limits_{i=1}^{n}P(BA_i)=\sum\limits_{i=1}^{n}P(A_i)P(B|A_i)\]</span></p><p>其中，<span class="math inline">\(P(AB)\)</span> 表示满足条件 <spanclass="math inline">\(A\land B\)</span> 的概率，<spanclass="math inline">\(P(B|A)\)</span> 表示条件 <spanclass="math inline">\(A\)</span> 下发生 <spanclass="math inline">\(B\)</span> 的概率。</p><h1 id="贝叶斯公式">贝叶斯公式</h1><p>遵循上述约定，若有 <spanclass="math inline">\(P(B)&gt;0\)</span>，则有贝叶斯公式：</p><p><span class="math display">\[P(A_i|B)=\dfrac{P(A_iB)}{P(B)}=\dfrac{P(A_i)P(B|A_i)}{\sum\limits_{j=1}^{n}P(A_j)P(B|A_j)}\]</span></p><p>其中 <span class="math inline">\(P(A|B)\)</span> 表示事件 <spanclass="math inline">\(B\)</span> 由 <spanclass="math inline">\(A\)</span> 引发的概率。</p><p>特别地，若 <span class="math inline">\(n=1\)</span>，则有：</p><p><span class="math display">\[P(A|B)=\dfrac{P(AB)}{P(B)}=\dfrac{P(A)P(B|A)}{P(A)P(B|A)+P(\overline{A})P(B|\overline{A})}\]</span></p><p>其中 <span class="math inline">\(\overline{A}\)</span> 表示 <spanclass="math inline">\(A\)</span> 的反事件。</p><p>全概率公式和贝叶斯公式均需要得知 <spanclass="math inline">\(P(A_i)\)</span> 与 <spanclass="math inline">\(P(B|A_i)\)</span>，不同之处在于全概率公式是通过这些概率推出<span class="math inline">\(B\)</span>的概率，即由因推果。而贝叶斯公式则是在已知 <spanclass="math inline">\(B\)</span> 发生的概率下，求出 <spanclass="math inline">\(A_i\)</span> 对其的影响，即由果推因。</p><p>由此观之，全概率公式与贝叶斯公式呈现因果颠倒的关系。</p><p>我们称 <span class="math inline">\(P(A_i)\)</span> 为先验概率，称<span class="math inline">\(P(A_i|B)\)</span> 为后验概率，<spanclass="math inline">\(P(B)\)</span> 为证据概率，<spanclass="math inline">\(P(B|A_i)\)</span>为似然度，则贝叶斯公式可用下式表示：</p><p><span class="math display">\[\text{后验概率}=\dfrac{\text{先验概率}}{\text{证据概率}}\times\text{似然度}\]</span></p><p>许多算法为提高后验概率，会尽量提高似然度。</p><p>贝叶斯公式存在的争议：先验概率可能不存在或者存在主观性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;南京大学本科课程概率论。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="概率论" scheme="http://summace.cc/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    <category term="数学" scheme="http://summace.cc/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>AGC020D Min Max Repetition</title>
    <link href="http://summace.cc/AGC020D/"/>
    <id>http://summace.cc/AGC020D/</id>
    <published>2023-09-24T16:00:00.000Z</published>
    <updated>2023-09-25T01:40:50.855Z</updated>
    
    <content type="html"><![CDATA[<p>有生之年想出来的 AGC 构造题，值得记一下。</p><span id="more"></span><p><a class="link"  href="https://atcoder.jp/contests/agc020/tasks/agc020_d" >Link</a></p><blockquote><p>多组询问。每个询问给定四个整数 <spanclass="math inline">\(A,B,C,D\)</span>，求一个满足这个条件的字符串：</p><ol type="1"><li><p>长度为 <span class="math inline">\(A+B\)</span>，由 <spanclass="math inline">\(A\)</span> 个字符 <spanclass="math inline">\(\mathtt{A}\)</span> 和 <spanclass="math inline">\(B\)</span> 个字符 <spanclass="math inline">\(\mathtt{B}\)</span> 构成。</p></li><li><p>在此基础上，连续的相同字符个数的最大值最小。</p></li><li><p>在此基础上，字典序最小。</p></li></ol><p>输出这个字符串的第 <span class="math inline">\(C\)</span> 位到第<span class="math inline">\(D\)</span> 位。</p></blockquote><p>不妨先考虑一下，<span class="math inline">\(A=B\)</span>的时候我们会如何安排。显然，由于要满足条件 <spanclass="math inline">\(2\)</span>，我们一定会交叉放置。而由于条件 <spanclass="math inline">\(3\)</span>，我们会安排成 <spanclass="math inline">\(\underbrace{\mathtt{AB\cdotsAB}}_{若干个\mathtt{AB}}\)</span>。</p><p>现在如果我们放了上述个 <spanclass="math inline">\(\mathtt{A,B}\)</span>，还多出若干个 <spanclass="math inline">\(\mathtt{A}\)</span>，那么多出的 <spanclass="math inline">\(\mathtt{A}\)</span> 就一定会插入到前半部分的 <spanclass="math inline">\(\mathtt{AB}\)</span> 中，形成 <spanclass="math inline">\(\mathtt A\underbrace{\cdots}_{若干个\mathtt{A}}\mathtt B\)</span>。经过这样操作之后，我们发现我们条件 <spanclass="math inline">\(2\)</span> 的需求放宽了，也就是说我们原本的某些<span class="math inline">\(\mathtt{B}\)</span>可以向后调整。最终，整个序列会变成这样：</p><p><span class="math display">\[\mathtt{(A\cdots B)\cdots|A\cdots AB\cdots B|(B\cdots A)\cdots}\]</span></p><p>其中 <span class="math inline">\(\cdots\)</span>表示前部分的反复。</p><p>容易得到 <spanclass="math inline">\(k=\lceil\dfrac{a+b}{\min(a,b)+1}\rceil\)</span>，<spanclass="math inline">\(k\)</span> 是的连续相同字符个数，</p><p>那么我们可以二分出来中间的 <spanclass="math inline">\(\mathtt{A\cdots AB\cdots B}\)</span> 的 <spanclass="math inline">\(\mathtt{AB}\)</span>中界，然后就可以按照构造的方式输出。发现如果我们当前还剩 <spanclass="math inline">\(a\)</span> 个 <span class="math inline">\(\mathttA\)</span>，<span class="math inline">\(b\)</span> 个 <spanclass="math inline">\(\mathtt B\)</span>，我们需要满足 <spanclass="math inline">\(b&gt;ak\)</span>。输出的时候分为左右两边判断即可。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = A - mid / (k + <span class="number">1</span>) * k - mid % (k + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> b = B - mid / (k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> b &lt;= a * k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(A, B, C, D);</span><br><span class="line">    k = (A + B) / (<span class="built_in">min</span>(A, B) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = A + B + <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a = A - l / (k + <span class="number">1</span>) * k - l % (k + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> b = B - l / (k + <span class="number">1</span>);</span><br><span class="line">    r = l + <span class="number">1</span> + b - a * k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C; i &lt;= D; i++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= l) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (i % (k + <span class="number">1</span>)) ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ((i - r) % (k + <span class="number">1</span>)) ? <span class="string">&#x27;B&#x27;</span> : <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;有生之年想出来的 AGC 构造题，值得记一下。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="二分" scheme="http://summace.cc/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="构造" scheme="http://summace.cc/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>摆烂日志</title>
    <link href="http://summace.cc/training/"/>
    <id>http://summace.cc/training/</id>
    <published>2023-09-21T16:00:00.000Z</published>
    <updated>2023-09-28T01:29:03.891Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="出错。">  <script id="hbeData" type="hbeData" data-hmacdigest="2f387da8c078216fa65c351b5acd85189a85fe0deeab847d70b2f3324f6594cc">5aa0328b97108558c86b2b536108318893d9eba501c3fe88bc1723179fe487199986a82e7ddc4f12d91e44f9f6e28d68e4c0a0ecdbe16177e10ff750695ba285ecec038f8bfc95c15698a421937066abcd869db20dd5e9ef8013d9c5ed1f02429e0fa2113d0758991d464327429e3aeb6196128463485e8e463ee670ec2b774be20d9f0043cf3bc74c4ae7ff2a10cec8dd27bd0378f9f5e2b647d5d7a3a6020bed49e33d41c24ddf0fe92bb4688fe4c56ab8bed5f956daf137f247e703fbb54cfdf353173812c3f250776b94031d497a2b64e22bb17ceb79c4e6edce1cf47e6fdea92369f7f723f54f690a79aefcfee975855dfd215c696b8603fa0289027b043d317f3a0dd3d132405a7ad2f90c4a0cbde9b73f3b3724bee54635d31fc3477570e25e34a9685327731972777e145c4ea231a2a5191324b10de6b5427163db629b23ff08d789458e3e3ffc276070dd62d936df4e0f15612fa1b044a4de3f972fc724cccfe4083caba78b80bfbfb8df4fabd6e104504f19f665f8f663d58036a0de59d12edd0584019cdea8ccaaec6bfeff3c9eb55923b5d30701d4a291c799f3e975675e480fb7d06a79a962b031dcd7279c9c614129e5a0413a391ce969bfdedfbbd2581a4134d6be535812af4da1ad301f0cae7874875853803b9dc05a28feafdf4e76927acfea2707dc48758acba2599e74d4fa3809919ce8e2d9f309985478080cda49dc28ed82e9ec3b6e3b6988db4b5cf56f865c8baeb92162fa273e5aa30108798b177586969577ab3d82ad644b6b74bf4b56e516c132b53e60f225b3a1bb06af091fa2edc747394801503654bb242a8c1ebe36f361bf022b5e025e7808aaddba0f1382e323b90f295f5bd04997fd1c5013eb3c5f0d5ee9bfc316d5d0450c282de652bbc74a11ca2188942a30c3c4be7daf16c3dad42e5ce8458945f5f9c41c9ff1e474360930e70f73a27cda41695ecd2a417246d1e72510a15ff058552d7c05887b3e2a9d235dc639e1865ddb06cb50f767a3e95b12b0f0a6a45f20336af882a7ae58308df268c16b9bc6d223862e3fb486d9299136155ebb63575206d253889f323807cc38828121318f3fb0ce1701bf60b4e6794d4b6287c877d108068a1d0db7a3449c6f98eaf4d4d3fc884e0e25dc80827b4c527854f7af08ae8a6c8315d9137b1d73e56812824ad78f3d2e4de1642171587cdfe7d71f0959b192146b815ba9384e09fa7714ea80377d7e0dc44842d3ed5833ac027edbcb0b29d1952e6f577f0359a80bd184abeaba0820e554c3dd5159f5a8707a6f9f5593114eefecbb02ef628e4b5d20fad5f9a0716508c7cd6dbeaf77f45f0cd53a9bfc52d8acb9c76af34b022d4ba59b85a145720f49cbef3d23c0485ba3cca1327cb1feb20c947fd4d26294c089b1f2e93e295427c6d66a88d6ca1513dafcb7b378b0e447b2195fc80242a6098effc62b44f9f4919d7477b8be33e065ca7db63b2cbfa85c2102891c5a8f9e8b250d88c41a551129878fc20bd6b5281081d91704da9f567d84957b9725da5aae5ad671ac90d2cffd5141bcd52f7f93825d86c0b25b8f553b2af2d8171351bd0147eba56d8bf958439cf0c51407a1b43f20216c325973d73d0daf64b0af35c44ab105603f5c97f20a0153a17dc73aa5346ab7856d5cbef367ceada94158de14cc504cd1b78a8b94c5493a27dc12289b0d8fc4126587431d3277da63e32aa8cb22c3886a3fd19c5d94668248c010b1eacd69aba80b77aaec4dba398bc30f0465ecd33073cf72fb5321b54f279c80e1d2eaf30a580c70fdf5f163f687500bedbb4fa726c49490798e5719b170fee7dcd6269fa53968a50ea8917ba9b1d4b0df271b973c186536de2f7b5166c6534ade53b8295ebe856fffa9af014e8d3b9f8dbb71c394a0de061d04f42be1fe902b5384f8c7b18919af44a2180185567852eb32fe6678d685ecb819ff7557f684a514171423cf490e40690733e485b663bfcc804c40cb6ae2a1adf075e96891fa398aa872ebeb753550fab3f07f996dbf6105b768b66fce41f8658e419a464578059d23a2569843acddeeac2d14e1039e57d1a69078e8f3ecfe41a76d602fdf5a1ac5febb7ff1f64f4808c883db0ce78c032c592cd4f92d7ae13f5675225680b3a663667301cc92e75962c366b370b0228240be791c37260f7631cdd947906c067b024e17d21c1ed04af501c4d5a805085c2a0c9a484e9f1d6a82e0e552996e77e0fceada0d05bf0b3d89c40c3bc8af77e3e7296aad9d70dd25f64d2fe9d8ee3a7da856f185eb92259bd0fc99005a9e16397c3190aa49a226731483dff90d25289c1d5a31ddb8bf033bb0491dccba83de5577a39a63caeb70d98260daae9549de6a4a68c49a2ca49411076daee3ed99fbb1ac56335366cca96e6083d8594d9031fa97e582405dc4661ee531ffbd10227b0c745386feceff526201dfd97cf377cb9a95510eed5591f0707da253d1f51ed9f1472202b9603adec7aac66c86bbc43422f9c1c9792973e1bfaf0c9c9201694eda5e38263ac4e1816e33d4edce1dda5f633f383ca22a0c11005d728295b0808d8a272611b7d76927681ea8f647ad80d906e26e5cbab4d9339831d1a0cb00796d102795e72dcc1cf1ae89ae326b7ab8264eb2a1d82d908b74716eecac831b746a9f98da1aa6074ff6a41792d2772c0de77f5e644ecbfeba70bd447c5c1c6a9a9d0f4c2e547c056638688c219ce15e897ff7cbabae436261ceb8d88d23a46f03dccd284faf700b6710c4d8e3cbedaaa8226e989b347bfa7eeb83faf80b03f556ac840bb7ee6fe32e659acc37e015738e6b8f0b4c602cbecb7d9d11749726bf39f3273e7523ede454fc1a77c1bc74a3233e456c06f86842c16cea4fde0cc0256b5869c797f80b783d8c4b2a3587d77e1b95926ddbaa1d50d0ab6517aac1ff9e85d3fcfa911253a1de451e87eaca17197e3bd7a2c5cfd4909f29463379399d0cab93d285dcd507daa37f3bea41ad37813df69f628695f96b00b10228f39c76e076f188f1987193773856f3471aa00a470fbb9c6ffbc4d0fa8a5abfb5e3913ff1a9e19a3d66b8c6f3dd2ccd9c5f82926671c77a045db25a4812d84bb49d5c4d8ddfccdd7b7bdf136d6535ac3b4015cf3a6c71fff9506536065a79721fe201300bbb6c846cb595d3d8c9d873403beb0496b9b51575b205226fe9767133a8886acbc5dc4c5325a8de7f6632c684ced9216d815af90ad45540e8001cecd3b40a2afb2a620f217fcb201b84a863b6677b8a443649c9cdb48e24b3d86bea765f6267ecdecd445d01dbf3a5a399fe9882b6e1f7bd6a4718c6181c0b422220d9bb916483b87353a2e1febf38f0a0728d679e5c103c30e53753de2de5b5f14d104bea7ec62850ce851262b02bd95bb0225c524398013a60b4236d56bb5e8f8d7cda7c3117289afd4820a94976c63f133c1f33ec545700316b86e62787eebb0799838e75c54e0af3e18e24792c4715f4ddc50cd45f51dd57b2903ed998cad0f4e26e7541f5443f86090e72b3aca75f561473ea0e96da1aff1a04b745199f55a48d8202c56953b1193755dcfc7a3e6b9b585c90f6bc7c1601217a9c0b0ac1b3badb131bf20a5fa1e58c2c3140ae07efd9f389730de10a3eee78ee21d0237d9b2b057e83d6eb7ba7139770deefc02bf180a77503a056faebe30b23e8cd9779da70046b1e175a148bdc40418c3c75e0f55b75114fbf0a7cf6f6b361553f99bb3eb45007904bd337fea4fc4e4649ca8757dc6c3c59634685550078e56de984269b6781db7acf4452bddd2fa750bbefac858714ea5231a9b6a740fb3c4c8dd3f1a91a99376441972608f362ee315764dbd610838f810cfa721300339d6b410dc18e6c6f822f19f91756b0cde1e61cfe0eb8d16da784efc71736e88f59243e2f8a92946a800daa165f4d9de635192723d51b96e129a48da22ef09710639429d97662473fe1394a415914c515cd32c165cf6f5d11e6708cf7ca601ef7cde55a60541102e87f2a3c28d85d33987d8c090b8319c288753472d0fc01fe8acc2518e42fe19307cd10bd8e75c598472e9b7de5abe98eaaf5f402ab29c13bb10dc4b3ddcfac02930b09c9d4c3059646625b1ffbba4d293d74a819ec0d8d9da89aecb1890be4d86b059aeb7213c3095d3b4bfa78b7cad9f24aa447c43e336ab93790f7c31c0c3ee7f4d4eb5a802f235972bafe769b6f347b82f4536103c3f77a74645c59c0f784c2f3c80ee7549f533ea2435d33a224caa728d4b18bf5eb9f7c2fc06147fe08fb57ce51dbfc9839db524cf2f04f2ed635519aad5c64747a6218b664ab9e99bb80954444131eaa22bf6093329934ac35bacfa08e741a344a65366f79d476672d8be4951f9441ebf06e9e43a1a0b5e8c3e82fada2abab042694bb577f7c13536f2093d5758e3b9cfff1bc2956b9f55b5aa0efa3cb55314fa2f7279d4a7dc93a8a2085dfa577406b0b9c87f02639449827015b537779a78e20cfee53bc81f1df98a5744346e12f5b0a8cc62d120042a88a9519f35c703bbd5f87f72c136fd839927bf026da969c7f4391bbe29557e76f079cded80fd9440350bdafa294f97ecf200d67f0a4c6e29b221f9f953aa4f3c7fe18906b2e0c3b370ede691c8fa5a0ed4daeffbb5d8e6c73fe3d65b975cdecdb8d956d96e4d11e8ce9396defd4b5eb2e99d80684a1e7814ee642ed2ad34cc32186baf7302c40734dff5f3e5d44472fd91ecf245f6627b05915debd28e23afb2ffcdcba95fdf0889f4e5925e9d3d56bca4c3f9c6132921ec09555c850224e431b1ad6a53b94645a2f242f8dedb0e712ee149b737d4b2fbda1d3cafcd7820feedb1797eb3f5c13e5c8e1dfdb9d2eb1f44819d3be7bdb2da9bc9f1a355f06e3c059a6f6ed060b9e8cac24c7440e335f88161e4c2410e6e90cef3e55c39ca308d18686e4c12877afdeccb3194bd5dbb214b5f8b9fa044b8c2a4409f917e4e56425ed533a10a134ea3be86838d7b46e20334f21adb2b62ba8175391ebb356c506e26c507efb4802cb0800ac72c7bb076c151dcd1ad57626bac6b052e96e60e4857476bcbe6bfda294420cfaf75b8982f3f9f82c335bcc178b6207570f1636e7aaa04485aacba41cc350ce310366d36b99a35fba3e7c432d598d52a69db2f4b9ef262f5b1a94df209b680e879006be8da5540225a95164f752cc550d0a9f7bd064299e0d8e27f4fb3ef2cd38bc4f7b408eec5dde6c082c531dd1c9193f1f33b1ead068fdbe448133ddab3f3f659ba5fc3b28728f6864c5f1d1248ccfc5fccf070a5ddadf1d8adcddc5c5a2aeb32de2adb79cdea4e92963d86c03ea675bb5f967655aef8fe18f4d34c061cb1818580539492bb7aa0c97a3750613a80e45bf08b199214c8130bbc8bf29f9166feaf4d53bd65a94c01b47de8c6c4597d3b250578d387e01246d2c7eaf55fc5fb780930844264ee1d91b40f4fce80d88bbbbfcc58606b1113df5bf2e2e2d11935c26b09391bc779d94d9a0b453d8b9a14166ea1c10f2ef0681dd23bb07d8ee6c43487a958ec7d0d3be56912ade00b261a24db22201e2a89e574e91177d87d05f8b2af72f3e7039cfc6a0a3c05f248b03ef20579b2b406d21c3127f093020dff610fe7011e1f4f46c44e359c28361d2fd3878d97ee7bc643cb7fd88ad1c5693c4d025552d28b8853f8b9adc7152a20588189c725de6bd1aeb332691d1eec74c86ce8a56842a04397fe7fbab030ba289cdab4d0e0234eef1b1ec78b2af13570a98fd3504569db056a5ff87bfffecee94a8fe07ce21e0b3dbe4f3d3eb08d25bf0897610a2df6cd87e069528e53956dfa252e0be2dcb45db99c9c8c7b727e0c792b26917cc92c32f85db9ca5b59d07a54faffacd5f7e0e1485af05ae14fd201c87221c82b6dd51cd7739f749ba13caae68b3879349c423870e8742c9c8d539046e3975aa579d3a12d00c53687847b05f4539cae0ba088b7b8995e275d3b2a875ef34301e47c146d0486fbb40c21ebb2cee8912fb3407fc9e14e5311a5b2830d43cc74535d091e5213d91d6c8cce3a7c54b75f4ee84909fded7c9cecdc5d25794ed6affa40d5b565f4b0fda1260bff6645680dd57968025d0974cb0f4d3afc565e6dc8b5359b9ec7cfca2964048b4adf6e5c5ebd4df0a4acc91d1ab5ee323c4f013e03b2887ca17cd96f8b5cd4ea03f4a3dd27a27900bc15d7655ea1326f1811fd6434bccb550e9306231ff331f60412623c7e6a50d4eddbcb509716502f377d30c43fc98e81c05de1ab7f22007fb54138e217daa6ba80e16dfd651db70bfe401a4bc6a52710be479fc027f1d0d3f6bff69738aeedb32b45bff2a471fe45ca5a1134c1b3c41613ec9f9017bbca33f764b5111ef7de05e55af9fa82257c1d5dfeebce40df032b988855fe3d31ffc70f4ec0a9b4c9a43eca39343fadbe28821e2f775177cc293fe31fdbc802b8b60bd9fe78ef529013cb1cbc8540942bc7401695abd901deecd4a4b3dcec12d162b1e02525244a7c5816e43379688d9d0e1215fa5f0dc2031ccad55f22ece822bf9e29e6c0cccc6809346b7833236271237067abcfb5ba2e8b86ed011ea94434cd0208abb4be5a2335b5d087186e61d604ccc9a970b994185901bb620d1917373fcf4f4107e75014e979886090589dd1f5638b8cee303f1a536e454458d5e0c7467aa51194dffe030b55226e114295f388c46f72640c41df99ec3b23bd4fabd4f8702c590cce60bb8e4f2a736c8cba403e2bec5b8d41e895c54e6692d4b5ec78a51e184d73fbb3f222beae7ce2afe666b59c721a52ebb4da6584e8f8bf2e728ddbca850f8b6b622f2de750e881aa12aa7367fc8e51a3539bde82dcb1515d5e0e7b7a7fb0519b80c26f5bd6b3b7345c9da1c78a95f4c2a3a21085b1110995452157d42203ad60c6150e64f2da47592d5d4ee8325f4fc8f5c38175231e7e114a2380f8cdae6fbfabb9d86015f2926baa432ed37eee059cc96736839bec33840f3fb6cd2bf2a17065e9cc10f214cb71ba8c60cb9f494bb1a22c396fde1b7b4ecde198bbd53b820c84081336c1c18ff64dab2377b9db00623e31c19258d60e9d1e544ba4290b6220c994ba0b8928ac39752c59bcad84a7ba4ca2cf55abe4f499b9ea7471eb521183effc7e4549138f246fc4dc95da0c9109cc2acc58a10603a5d6a025e22a324ca3dee22c50140c8ea52608639afbd4625398bf7afa6ecbb876542113ffc73976f7cea60761adb00a9a1c9842a00d7f7fd76aa7bfe820dcdb0ba1024f1a9c9d6f047f4419012c3aa8fb4268bf6234f50877610f0bd2a01a8086464606dc38142dfa0007feaea92fec175874587aca0b1931a7c7209ff8b19d589947a4da1821a2919638e7682640852f8afb058284e938cfa959ad11d43514769ae0c9eca70db10f52a0d84f05ae59199a50268475929f33a72a23bd28b76f7f9a9e5d049fb0ebc20ec6e95e6b5b2f8b10dd0d9136b7efb640402862fcc0f1fd9093d67dc6db1fe78cbfd7ce52df8d4f8b425a9cf0babb75394b0db01db2349715b42929ed01fa9bac02e82a7caed4003560bcdb10bd6217d01d764c500c0372f3045b964368a0ea9361e159496fbc4f3fe83e2b24ea290d5358bc6a9858521b138f62d422543dfc663a794c3fef6f7ef3d133a4bcd3bfc7746a8bd4782f741187ca5c26ced38812d9f18f0e43bd77ef7c6096f302e0bfaa770fd7101f0a433c891d4a13504a89e62d7fe800d88121ef720b47dba3f345801e930800cc21adc2f5c5a2d1be7b629dc79209faeba9073245fd80a8054a4f28e6ed5e6472c56ef04dead0bfc91645e9edc6432d03615ac17d7cece780c25980f81385995079f83fb9690a75e278dc55ea63f443709213b34b4768fe80d60327579396d36d464b574426ba55574c0e287a5e3d0fae463524d9825348158d82212e67f40d97cf6ca19f5563a385eb0395ecf9845c5abd0ddf5ed21a43ec64f1ce45f3d379d115e15c228628c7232e322f31680957b0cb0ea1825ccd6eb53954a3c469101521cd0aa50919cb69df8ea2b2169d53644550ba448db37772bca8b03796cb768645598ece4ed8400c6fb15ab90ca9d3365d8609f23da1e95f61ae7e33683813fb353ec846c9a2dcb3052e1d0cfedf8b50e300ed5de3c68c8b282d8b1f69525c3e6afbe5c9cde5822c26d1971d40d80589e94c8ae2b7889c4a3090cbcc87a27a3eb06a000955f53ceec8dbbe3617998ddf71bbc4343be88a094c759b4869b1904731953989a03ca5c0a0e862b13e1d7cf84e2dc4c7c610736c8678efd092887205167b90b059fa94dbc941c75621cf5703ebaab9909b6f4b419ce013fdb3cb1502d758174b516a05a5e5a8d089cf02f73281bfed6b2bf73104a108598f7903d39fc8506bfcc7ec2085638ffa5bc894068a9cb3f7b07cd34f72c3e9067a492911e51558c2a01042fab63cba9eec984c9b87a4fda83ddc19dd7082dab8e37bb98419ed7e02a2c03560811e2c77e2f29de89f107363373fcb05cb1c9467e4b1eeab63a19249763eed40cedf7ab0ec2d7d794eb1079514ab916ff1f2af6535895de2517491ddf56362968cf48adaed3fe2ef81e6d9d6b2257e8a00c74253046b249319c06b52456ead4cf83828fdca7a96072fcb5ef9da1aee5aceb2378573aead598156bb059525bde27e314aa5209494aa6c880938e5694fc1b66cb7c676807b8b2fbe1eabdb447fba8b4016f63caaf7267b20d5a6a640eac97af21ab051591e0527942d688da8b1a06091d77c6d92b6738b42a20c2bb81c50da9b0c88b5a5d9d41a0b948a18dabc508ab295138ea675c452287bcf77bf72774576b94eed882e9c5fb9483a542ee694c4a84e737d8a886aba9a417f7f9f54f4af9548f8ddc61fa637a72b2be6f1933da9b19f6fc5cc75bb34e12a175b2db06c8f3256bd4e070c31ef7cdf7eaeacc89947a2d0791f34f0054739540e7463f8ffb4e6f5a4cae271914eff3113534155fc3aa406880596f47aa8d6a91c2cccaf7e25760b8bb0303640edcca4933c29a3e6acaf33a6c19f8e323f03aa15cb0468e2d6ec01997ad93552a672902fa9c4c0853d2be3d0359612e76a1b43b6f8203101281f3eeae87d345b29ab040504b128889981e6c60f2b8d999ddfaa539f728a46a5f84ca26b9f452cec3f84b35aebbe3ed925f603dd49fe53c7feac5b97e4dbde4807aed0288d41d87bd3c3c8ef40380594c42d10dbad1690a0301f1762fe1ed1639b75378d6b112e66ddd1642f78087d8e1644e062673a559565acab7a06784133ee301b40c514277f4e08ebfb512aeb3fee5b536644a2ec9b21db3f580813f2dc57effa665a5b331929312c26a7839a233a63912336be43bc9247f83bcaa2dbdcb0993d262d4193ff8f398ffdd692135efd3f3070e5771254d393af29a97104d920ef413137d70499a46f58a3a78fc1cae3dda3ec23f7810b5c7e07f6acc92f56494f6243dec7ca4c5305d88465008f967342ac8a4bc72dfde0b3de4c3f7ed889d52bd2ea30ed83d4a00f2b37274d831817782eb83622aeed2547ddecf3fa8b298f720cc13b04a020c722fd797720bb204700a964b79fad526ab40d7673104b04415c141d0edf3e6df04871ace9e36b52e2e082a6657108188d9b966bd82a1d62aa757207f6be6bf9de18965cd898c40ec5e91bd74428bf2e6ce3f8e7bce3d50954cc075df64374dbd15a1e5d414bada54f2d4f09e68c2afde5dc72529c141aa5d4363345330d7ddfeba71c8d8229a0ac29415b4ab3cb6c16664b174d98eebf5aa2fbde8ef9b63e6185ba3bd80bc6caf303937d118510d30563762decb28c2c7fc40c651cb7036155f9a1dad9965517046dafa9b68aff0c9570bf1f8597de5c59d186571f7c5eeb8d6840a9623b63f5fc4778f80c55b738df19669354b5eedec3c328be795403571ef5952f32824946815b9d3fdda29664654bd195cbae0d61befbb415da96d4352ad70260eb47e42989528d004ae9b446b92c47d92ed5330da65341427346649216d88135d899c9329b4fe3a2f9a0a40b99f0f89a4ca1df5afd972ad1fdf7f66b1457960e0c63c799b362111dc907deb1105e6b939c542b68cf4bf576c1f8c6912bd36282d13fabe5a249faa6545f5b9a6b32d36ecd1ee3564c4bb107e6b7c047e33e3e4fe3ad524be89e08a9c8f00ae781352e5a5cb2ed0f83ec91c014287bab72ed4948d7fec6d27ada5add13d727086b22f2b8071a5200c8bbbab576492db7e29ce925d842b57007ee5f857a8210432e4cf0438af78eefcd0652a3cbab0264ec3095eac8d286b3182b8db8a0efdb003f8e945e8b3acd9612a59ca0a164b8dda4927b0a91c6f8bc4675991e4c28e105507f8fa383046c86292b868c9258c6bfad3aa2c1b752de2e848bd1b38d091c5eb9adb499d106a4336151de077fc98c335c85000c6ec04b9907c54e637f7dc1458c7c8584940e565ffb3971ff08573034b859ab4f6af32d881bdf7f52bc76bc76f5be068f73c7485d6af1fc8ba56a7ddf6a2663eab80dce774714d4dd30c45cdd18998fcddf760f9648f4475762fea142db227781e9cf888e772d585e96258e001be22a741d9fed421d0bd975027dcaef7b982cf804a1f4533b0a41ee41a767b5851e9f918ba187229982c9fc5e3a528703e76c4c93fe5cb899c020ed8e5fd993e4126b90162eed988cb761b0172ff4d0a773f4924fca8d3c8b8d846cb5b89584ec874a7934699e7c4c5683d3dabe9e649ec2f64374e273fe70d4326299097507c76619e1f9d96017d2f6c948e8b0ec79a275abec63e961f87f5ea133ba6038217bb1dc0c32a588d4b2e6340e2ec6b24469339411a31aa2b0c6e7743c5c94b7f2b47a4de79ec16e8b2c7aefa6121ed44e704076e8de1e16230581530c67bb4e571ad661b5e0eb6151be590fe9fe6bca0b0ebbcb3f72124a5a25f346cd8752c283f1eaf7af3ef2a0e601477c152836639005b53015425a29ceec4ac9bc2e2f908bc59d2a17dd4e9c284e44f230477aa65dd1b27111a4e023ee0fab90fa6d9e8efedae7dc26a6d386617fbe080aa46d33e673d2689289f2a2ae57a1b1ee41e1dd495e506882ee93221e036557b21e401cff76ef1f6eee623b9537c10708e19cb52b91e90a41376447d228ba357e032fad6d4d9680807f408ff1c7e4fd6316390bfdcf7b321b39e6328d5bf14417d3a092051f04721c92d7387c49007ef193114c890c26a2dc92af67a8dcf81e012c0df9f85a394185113b3b05fa274109ddb1fef0139d6b913f11919c05dfcd327015d79f38e61c7534d34d1eb300484b2b7b1f6950367fc1d62ee01d8c96727df2ca6a4bfac5608f010300bee6b8c0853afbd3ad0ca0ab02f851d00f9fcd2d2fec0135cd63442b099dcbb4732058e4b0d472eb379972c31858d5d3b04c3505db270bf152e3e6405b5da1de3ee2c31ffee583852c5ca1fcd2292297a87da2af3c0781eb0431dd1935949da79800b9b165d6ab38f1423b54b8384d0e69bbcff397d3ac688933708737fd2c12661b09759b38e2fd0b99826b411856fa7ce8353abe531a329dd96f8fa6bb637bf4cb626f7d1030c01d6d4455980764fd7ad74b0405149e413fdc2fec5f018f102d24e251166d7ed7c86c1fe7a960f78d15f321e9b93e175d7f2305bee17b25b50d9c195bb2a4a990329ffc4f9d37bd6ad5d1b74b5a7c4d7ebd872fe5c8cab0731714737354f391711bc235d847a9f198f168c8d1f471bcdaa041381723f34ef2e6cb679390b05c235de86c82a41103158eca399791f7c3acb546775c0cfb89fe8f1eb6b21b6113e46e4e70e336a98df6d3adfeca48f5a49bb560426c4e29a0863f308a4f4f80ebae8e1a0f1386a4d942d00404d1598b09899ab44948bbae0561158a9eaa4e3107d10cf11b4dd29f21bef8e484a087468e31cfee14b64eb99e65628bc093318ff7747a596df5a8e5826d4bf6bf32eecb39dd84e7984b3471654f3b6589b15244a86d2e213e9b05bbeaacca742b2d5c74b2a26730c32f54fd31237796e266b7ad7ec55605a8df322f6db6e5c9410ff198553f6c45314e4ae0886c8096de7b1a57fb31980850c01753fb2d3b0a8845482db5639165ce3c3e72369671762ccc19bb791f05403fb4fdbb1b8cefd98d7361df519fe627fee11d0c6317445f96f6a7916dfeb9bcccde481aa1f5c02bbd0ed6f50d6cf48bd5105acdefcb4555d4c7e19204901a9067cfc2934a173c9be084173356770c54fc60e6b43cc375530e7569651db2f08052719251f591d4f5356657f3178f2a0d5a5894e5feb513c14b9024b5d978c9e1539081e8de6e5ad2f46a2f6085fcfffd6ea314cf679e7d0ff475c4c16956decbf0b6a535707e82e23cbeb8024355cfaf35f7a5131a12066a657314f4fa9c657db7d408c5b13eaca38648218d1ef170a8322d844c220c4c69d31e62c15b1f31171328ca88d226394bd2a94f7507625b02ba1ff0c5864bc82f5c86907d598ff5298b08414fb5764a10baafd0da82b554690d0ceecba4344f1ad150a3ee8c012adc8f014c1e714650ca0303c99af833a7dfbda817235417cfab291a2096539fcb2e7d6078f9e585cc4e79fbb8581aab69f0d900ac8e8a4572b570db6fde5d5d44b7200ade6e78762f71da5982bc000c28a38ba41f86dc6dc2d6248c70f11c4d840db1662a957202edec59f8bd968866d601d71fe710653c68365c7a809d1bbbef7f57e3e821c487e34c895c74e29f1d754da5ce35a24ef2e888c41f8e8831213e46c935f48ecc000c5454db06fc5de3f806550c57e4112fd9885403291439eb4a845c41aa3ccaa2f58cea34f2642fe72e924855e65bc8eae811af85d4874337dd84c8702775e78453707a574cea5a6298cbaeeed51c82b29fdc25640fea38c47c137f9b30b45b10568dbde2cf77aab0224369844f485b3561388ed1151db7bf6c11043eb4475571ff417ff537aad95619aae57e62123d186a4489f360c00ba9bd633e103e05dc3b991fb42904c91bf57628d20e8c498014a2167fdb34daec596f484a6d72631447cf69b44719f24be62c8741d5696d691277d5794970e42d3078b3638e1d957b9f4a12ebfe57a9c103b3284f5fee173220228f245899979ada1e8c8c680dd3e4cea91c0809c50db59200aacb502cb8a2d428cf49bf9430502e40c2a47b59577aac9cf2c48eb5012e1b8234e8ec2a3cc8ff637bd22fbc1c94c6a4aa62d530a98bfe3bef90c98815ce83d640622c8e990309b6c511320bd9536b6a60b18e8c46461dc55eb289494a16dc4cf2ec4c0df6fbec791d75de3822efb9da9ced9ae93df1f50a803a771f354b9f2a8c9885cf967d815e5fe4b6ad47ab0c25210b34c1587a400170c212138e65317bbccc3417ada37412a8539de72614384fbf23195bd97af5c5aec2fd7637a429f1c414f0960c8d42edb39408239aeec1ca5f8c4c5794f9fab4595de5e1b4650dca4f2f9e600f40a0bd002998bbf54b5c772b920af12b9ba8f1906758ae8e738508e2033390a3659591d789a54fab2769e37c7b7bc202d7af49bac32e385da2bf8d51b7b38238a2010cdcbd63227bbb5a1ff89e90f94e52471bfe58595a91300c175d8cb3a0a2f22daf226ead826793e4c38483624a0eb57974ca9d2b44adb3e4c54ede54eb866abf0351bbbe4691a5d8ea2fb461b1171eb9eb30be68e6ae73a66b36a605430a033f7755a3350a22d89bef721940cdaf109c2019f5941cd673d72363c2af8552270e97e6185a1d0fe696f67fac5d59a0f9b511dada0e3d469ed85cb8bc4cdd34eb8fbf442cf6d7de9714238efbe78e8dd18b614fd82f244115eb41bcec3ddea904f228216e2ddd4809677b7fd4897832280d07547565328686062b0f50843ccbc1f419df06f714ce84965bcedc83fccb5f0d4ae569ed72d63671fe16a909d87acea95f5f490276d419a11afc5d0e36bb3ad21660d60fa85c821ee50f61f8dd67b6dcd8ca121a8ecc50a544a8bd60a36fc17660b001ea4c715412e7f77e3df02ce26a28e270cffedb3fcb76da8c02044ac8e627748d9da638be52e2b5d3c151dff46b48045b1f5ae38a35dc595b4b4ebd9d7a6927e164a9be0437d3742f73f328df8f15a8e63eb1c12e185f6cecae31041f88c5788943c6ec2c54f6fee22d355bdeca80e0bc6abe1eabb709a417949004f32328dc272b2647e9275d3efa3fbc71994575828b430e9f37bf6799e39b1e1b89aac424850ede789781e7a5d5e38588916bb726a08414131603a6583b248e1f35622a1e3739134e3b3e56a74015934420521918568fb0ca6d20fc37b5e6f07d4ffa78753d1422127ebae23719a83f3a16fbb55648f609dd3c7cb2a5c747c9149ad309069cb155b26f3300ce43a832756fc700f856cc6ad85b18b682b9de51dbab1bffb25047c7f67100bd2b7cb401c908d61760240d4498c4d317cd2e749b278c329f2ac260935ced8ff0b9515d25c8486727a10d938804b4c70d856ad1ccf6a6ade76051c4e9f3588699265cd16c6e61ac8290c864dadf68d5103c8018315e8509b3426fcd7686429e52a38871ddd2b2d5326ebcf7a7e2f68127a89822202e1e2d4dd4792d2126757a07aa8eecc0da5bbe01f083b8bc1aeed661a4b7d95850b7fcabe242431aba673168273f07481674b0df5c193e0c699fedbbcc42160692c56cb645b653bd35fe21d6dc2a29921d61ea86417144224302f6104f0368d0fa730b527c943197370a4d050c3a154e82290ff861091376417e891b19cfbb94461ab4f7e8e7e542a7567fbc8c70f13dfd9ef55ac780cde0885b37d228ca71543d648a7465008a639885ffe692b4fcf7c208331c3203f31b8b052dd0214246bf6f3b7470d2adf4c1b49f66c75bf2bc6f227ae754688</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码是 hb 房间号</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这篇文章被密码保护。</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>CTSC2011 幸福路径</title>
    <link href="http://summace.cc/LGP4308/"/>
    <id>http://summace.cc/LGP4308/</id>
    <published>2023-09-20T16:00:00.000Z</published>
    <updated>2023-09-21T01:29:12.076Z</updated>
    
    <content type="html"><![CDATA[<p>一道不错的动态规划题目，需要一定思维。</p><span id="more"></span><p><a class="link"   href="https://www.luogu.com.cn/problem/P4308" >Link</a></p><p>首先，考虑最终路径的形态：如果该路径是有限长度的，那么一定是一条简单路径；如果该路径是无限长度的，那一定是一段简单路径与一个环拼接而成。</p><p>证明：如果我们当前经过了至少一个环，那么经过这个环即是最优答案，向外扩展一定不比重复该环优。</p><p>那么我们可以记 <span class="math inline">\(f_{i,j,k}\)</span> 表示从<span class="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span>，经过了 <spanclass="math inline">\(k\)</span> 条边（不包括节点 <spanclass="math inline">\(i\)</span>）的最大收益。</p><p>计算第一种形态，此时 <span class="math inline">\(k\leqn\)</span>，也就是对于所有 <span class="math inline">\(1\leq k\leqn\)</span>，<spanclass="math inline">\(f_{i,j,k}=\max\limits_{j&#39;\rightarrowj}\{f_{i,j&#39;,k-1}+w_{j&#39;}\times\rho^k\}\)</span>。</p><p>考虑第二种形态，我们记录 <span class="math inline">\(c_i\)</span>表示从 <span class="math inline">\(i\)</span>开始重复走环的最大收益，可以利用等比数列求和公式得出，<spanclass="math inline">\(c_i=\max\limits_{k=1}^{n}\left\{\dfrac{f_{i,i,k}}{1-\rho^k}\right\}\)</span>。</p><p>之后我们可以枚举简单路径的终点，然后拼接上重复走环的收益，计算答案即可。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t : e[j])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">if</span>(f[i][j][k - <span class="number">1</span>] &gt;= -eps)</span><br><span class="line">                    f[i][t][k] = <span class="built_in">max</span>(f[i][t][k], f[i][j][k - <span class="number">1</span>] + pmi[k] * w[t]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">if</span>(f[i][i][k] &gt;= -eps) c[i] = <span class="built_in">max</span>(c[i], f[i][i][k] / (<span class="number">1.00</span> - pmi[k]));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n; k++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, w[v0] + f[v0][i][k] + c[i] * pmi[k]);</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道不错的动态规划题目，需要一定思维。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>NOIP 日记</title>
    <link href="http://summace.cc/diary/"/>
    <id>http://summace.cc/diary/</id>
    <published>2023-09-20T16:00:00.000Z</published>
    <updated>2023-09-27T14:57:48.574Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="出错。">  <script id="hbeData" type="hbeData" data-hmacdigest="bbe24ecee7631e4136367ab8223ab736cf7924b871aa2db3f53720cb023b341c">9ab61599d64bb7443567a78f19eaa4bbfe22a018854dd97a275d48fb7a080fa8c0da90925f8a2cbd4c146ecdae32376f7225e81788324510a769d5c9b7cb389807394deaa3a955138fe6c091217de68c2a93a90e05b42abea282cec1009fb67a52858487851aad26ad91d25ccc18aaf34f16a3f490d7a2e413382e0180b8e8903aaf91902d707ffbbaf5f9bee1e10619c58c50a5fc9c68eb788dea87b40e4fb3e9f02aeb335456cb0c8bd509e5c2b32219c54c70f43afecb3f0864467cbfb4ba84f1eae95fa43ecd63c8184114116e006d1c43615ab3a690ed71e256038ca708f8b69fd502ee0b473e13d218e33facbb437b6238b3c533338bf00bf6a3a5120d13a2f16153dfd360b0b2494df170adb345293904fbe1792ede67c70c78fa90aaf47e18330021d43beea3904a5c9fefb358550f4c4ec5c99a925d3ce787b928be30260eec63facfebe1e434e36b8fe86f7883866ae2d94fae280bd4d7ceb4351df35e4479f5e6e0d8f3ddbfd14b21f71733a685d327184b1b20148e129419f7efd8882c9dd48904c662307cb00298982f0d11f1f7e14d101e30e11ca6e0dcc9468fbaefa4e20724cffdffe9c02cff9179d3f7b62562e31914998635f0839adffc11588b9cbd7abdffd6e41f43cc99e2e8cb86bf680d4e14b9aa6593bd82bfa5a6daa3d3582756ecf29d3f57cf042e13bac48fe6a7a0246f0da4233d915ffecc510aa8cb89e4d3fd5a3bf9f0d70d69cb5ea3cfa5222fc7350f98dfe65620cb0df42afc32084e70dab6cbbd97a1d719543c6b16e1a59c16c12d39eb13a7aacb756c240390246675decb9bc71e7aa68e9c79f72f9cc0d5b9152fab7b492a995c888336d2ef7019b2be0c44d142c4d0face99e67aac28e4fdd14da80122c133e56dce4f6ed5f2771aa6edc4c8c70c53dab1e157678043676bb5ad52e149b6442984878d8427dc69e4d49717a778c514f1e030366bd4c74de40006d2c7c0de132cfe34e4b083661c9624a8aed0c60573e73e1bd1127205cf65580b057d0f23e5fab958164d5f5df4a34909849d7cbff697a13cc15b36cc63ea3a49c4c3054564edc4c6d32e9e8ac3d7c7856be5621f4a43b2131c300258144d2e534e37bc03e402f7bbb408f1f3555fded67b02ecac4ed55b41d0262fb9942e787548a53dc8a29cb611deb28bcc554c41cf9e593caff2c31a2fb5bc96ff8b7e50a5d605a76d21d4a690cf829fa4f0bc0841543583b896be253553b8a4b76c3a9391b1e6b127c3632e5df3a30cad7f074cca7b257e5b32a19c9bc2c8743f55a0432b63ba4fdb203c9406f9a088fd2f879f346febc2be63d073c38eb64542dfdc9c9c33c13effed5e4baa833c9e3e28b98a2119aa5d7ea1e59cde86e27631f5f99099ffdb6dd54071bf20bcc6ac041ce74db27db7f6847ca15e50cadcfad1e6a5e0697e22244159bc66ced45beb32e71c73c39e8a22c54adaec45a6d52ef806dfe78860505a6c8bfc6e0b2ee6a8ac345783f9a1b16128d9fb16f80c6d72952fe2d26c97b91970c1ce864648393601dc4a2fce09182b7e86392c34d86d26bda886f3b8b88d182187c8d84fe3c3b254b421c0f661a0e9b0bfd98109080380f6f0338e3e9334a708458dd4a95454c5513241a742a86db7ac5fd767ffd0e2c861867dcf62b8fe29757b6dff4b66ed660c8a43424e3f9fc6ffb80ba570380381c1063a23023a97b1ddb10ffce3ad7a38cfcc4cec01de0838b958f407af74574b8e9886eb41d07f669a3e065435a22f62540eee087dc159d63540f9f4e991f0a035b19cca5b570acc45819d9dc038dbeac8fe44e9e7fca2634bb34ed4df1dc05fae94bde711e012add1a17458adc3741eaafbfc093767f585396d8e9682621c6839ab1154ea0df9c0a4f1e7d677eb3f30a6f230a95846b9fd47cb3749a50acd953a3225810e1b3d3f6ae556de719618feb97f7848aa588579cb1eda4843c6db3fc3901c9800a8bce8db36fcd533732378a8d2222dfa5a1783c8d50521fc9f54cad622339f5c874880303ae99a4eeb9d1ab44d912846bb5029514631f88cf5b474dcc2e5d715f5750057b67d3c700981ade05ef9eba69fe05c8be36c276d9affba26a4e76668ffe1116cae923542071fdeaf13fb1eada223215c1c809f5653fd54a8fe04adcebe14c968e762427b19222348c4c1d0c11a87fe21c0988c8c91a6c15a500667892f88e128e8a6b7a2e3ca69d2828f54c3b08df9971d5470d2b80dc4ad06450c167b424a648b66bf9739972a9a384b212776b40758d2eb8082528d174ebfe1c34c93bbdb40ab4cf6f801793d2cad013aeca4f6dde2d8c8e08b6b94ac7f210588c43f59b082ef1ac24143a3d3147900ca3e3262dd3d6594b62f8d12ffae7e1fb38086c647200fd0f2ddc629e4bc64492041757082b6b3a76de31a0e75c6dd05184d68be5aa51060777d5eb56da71b166f47a7657581a57b1a91314f2a3b35bf59a973068dfb89fdec4568e6cad8334e8522562994bc448883bf25b0c27c6b22fae0a85487ca8a422583e1404e9f0f3b082f4c23af8094cde4315b64d1bc4fa2c6ff4297efd7f8524e047337f4dcb8fac731b29c19e553759534a1e159ea9df2d2b9346721b9eac8cb87649114c72bb4a27df2692ddaeedc9c19c6708ef856fa73257332561ebcb19c4d01622e0f9b263b82cd86c0b9ed0ee78a0c8dd5ff3232558b1fffd71b5b151f5fbe8edd26ad5f230e14fe455b9ae33f044b5fdef050eac5eb5264d56b580624ded4dd807deec9f38d340988ef486a3d9c7535bc309393edb757331d03b218b6afc1270f1314aa06e5e08299976e063346b3e91588550abcf28017aa38577dd63df0cd8498c23535e95830a349f298902a0c71f9b36d8f6f80764766350f4ce8fab0f2ecaef76be3ea042c28e89a38c7647dbd093882e0f5c8da45436d1584452e8d24327b39c818ee836491235e07bbdfe446a4b6bfb545b5c15e79a1b874c4656cc8f9f9468804f8c1075ec93b1a5aede3ed1fbfe4292812de0700fbf41d4a361a54d648921f7954c0e8bd4e07e24ec5191e9573c68433a7428f1f4a6c53f4cf488df44d09d90f6ea3b8460bf48886e4c2a5b4fb0c0c14da01a9742cfbbbbc28a9c483efd2b7ecce50b4af3e0e80efb685427dd8bb47f29e8024c171f4c7ce71f27192a169e01c97b9c1d967d0c3b75c17d3379b76fa3e01384c65d614ff3f00e7cdf8d654042ceb1b23f80172632949f78bdf87055e609015e67027ec06364532df88040bb1e6ae105327b58ae3e1aba2c89952dd3f2b0a023583db46e5afa577ab9ae086c7f8d2e5c9ade6807d9079cc15789f62b651049876138d6d971d17731abbe4cffaca911b2c78ae5a8cbbbc51325e1de4ba5d8ec275ba25e89af1cdb3b4941b4c3788b2989d6b983bc9c02419b43d0f4c3b644c3ad3ca4aeac4b80808f5d1abecec8566ddf2b2f07a3c1116c80fdf7be99c45eef3cdc6ef52c6dbb8f64ec3c2bf9f11e3be0d760ef270d5b9553b82eb225149ce749a74d1e30d3bf7afb07457fc9e4d927df7ebac6dcc407ee9a6c48bf75e7fecb789c281a48fc366af23700acb0ae83ef35f270edaada2771e51f49774473cb09d82f9dc0c788e933f634642018c91e240d3892167fea8a3dd2eaea0d896d9346dcd8df8f71bf8f55d02999c6df33a096bc0a3a40df681a09bca1055d214045c4d3e594f5a9b9c4e4b17e6c76edfc1a6afd157ce47e773445736a958e5ac4987cae3a3602d94696d1fc4cb7241e28b300dde20ea8cad960f9093552b1bf94cc5f0e17cfc5870366c33be7e8471e13a78c35168ac51741d4ba46ba3e7bdfc5485f8eabb5c6827b1f8b37ac95615c05f208e0bd7f61d18793ff12c96d744b7e55212b887597ff77f5172014fa0f33894dd4cbf04cd0f6cc625ced97445211796e09c741813200f686b15d4044d69edade8c52e327b7d12dfa32848e61d399717fe64fd4606edcc5e22c96875c8207e999982d0aae73f65153cce910574e2bd32abaee0c4b2f0b36505532c6b787c80ff39f3e19b47d97e3f182bcf37a0d00022d430670e3e31a17222c69613ae57cc37a85afd565741a3bfaed14ad343902daabca06c7dd66330b39e5c904131134cd7b2f37cca501304134f96587b3614a7815f94ab95d88132d7119efc7ba9a2ff8fc9eca09d49e9c420989439636adf26b25304804862edcb8ecf6ea4761052dc5fa2934de97c64cd399d31e13e900c508269b4e90336996c2281d9bb58266de096dd4291ffbebb43baebed1d0b27fe51da568fc46793dd9c07b5dd21187a0e4a4f7582550c6ecd7829ef8b554ab43eac25a20ad6eedd136382787195f0ecc18987d238281db79fb03ed309d5474df55aa7225167a8d59b6a495243f86d3b94d1ad9b8065a2195349d1b5aac08010fffb818afe758b60dc4c7b91d382d1f1995d6d906f7474f3e8e22609ce7e3983b6eb809d0755e75788f1e96003e5bfed26967cfc46197c8161ab53abe005f0132f6637f4d61afd7501eac5e6e88ce1760ceb8011256fd2094414849037d4890179ffa230ee2f0aafb6992baa89f35dcaa68d815cfd80dfa79a2338e8ec19b836e0770bbeb60d36ecac87fec3d6731f8aa6ba54b87f6393c3c9036984a7f3f48609e4231e14896c5a36e2f175742da6677f02806bbc8ff4ffd17f3e5fd6bf43209e2e84786ae23a015763a16db39bd963065ad25306ec91596c2115e534e00de39aec5506fad748b232d4f12425a67585d5fa162c1764cfa36c98c3fc63aa93415dc57fa47de14fb531dc268fce91d5c8c60974aeb24f23f03e1ec1b930cd68a272a51a3e66efde6d279a90298c2b45b44f7644c5a475d54eacf21abad239ccc4668874f8027f7a6b2da740494c40ad90ef7a4a4cf3beeeb87f63ccb146578a815fe2cd59942817c4ec6eb10b0bece329591333293a235645198a4caeeb95a4c7c6363c5600a193a752868d52c659070a18d4ed499dc8a83b64f4e699bfb02406668e04b1d32d6f2ece44cb49d7ddbe83621e0133c9f1e98a491235a0423e75623cc6c7ebc7032b81c96b52b33c16b9e2ce0b1973dac006b91302ab272dd126a85976a846c0b1c60d40684f05c1d93d56ac4d5f63589c278343e309e08a18f148d8cb8d821bfda798b4bfc884320f502533af9c6bac5f22753a6c1751d82d8083f2d315a5431651cb0bcc0a9f0a53764a0c1f284223c03a6d4670e887ce7b38e2b26cdc5c474a52c6da4b12317f8c4be85120055d82229a4ec7f1bcb2a8af88617acef4319e654c548bf9f245bc6c2b6011e51817091bd3b2c5fb4cc9be56d9a7cf85ab8ec1f998baa27ede58d0828bb1ae59aa4572d5ef3fc03ce30ccd11f47aab8cc18781cba717a7f4a610c41ba81b9e427b6d88cefe220ec12ad4ba696ca5959f0325cc37aa3fc42921933f35b4943a70cef4d6dbed7456c1e4512f42bc0be0e64b33cc410efa6fe6b949c031d592b32674bbc03b093c5c4a264476ed1c3a3b5352f3596989893b9d6c88a2ca82a6d269f2130442e63b91e2beab7c5078d7fa64f93a6ad990e629e5b60a2053e561e291f4c50886f4dc8fc8acb05be5da0ba8e55b2e83d18c9c4c72a286e9012bf7ebaaaba14bb4488a77cb8eaf88d38a24cd54d865f5af67ee669b2853c77ebfeef93c1837bbe25fddb652eeb81a870d8618b99f54a59605a0b2278d5cad34d15f22e924566f672f735dd9260103161c5b9cf747a73c98df8774a50c98f142aa6661d35d3ae4804adfe2ac5990882463143c84ba051df08b2413a603f1d64440d7a94837e3da82cecdd20b4c526f7ac7d97dd4ab40cc6266e08e7aab1a9d8611d8ec7313325b8da6369341a8831e1704f69ace8e811acd596052f92c77d04b9766b2e2b5bd3438dee1056ef1e166be8adba87d8890fb41d10d33400a54174cf33f166c614eefad7e6b1285bf5ace74000634be45b717f483b8c8ce586ef3e7de659ffb3d041777cc3bce32fe0074d4bee8ecc3d3d29592bd24376de11a906b7798b0ac45576555b8182f0cfea83135ba00c3068cfce0568ea69da8a17b276f7ef89a1960bab5cc3f526ad22887d365df1c7c1548c7f3b90b80260ed1d42fcba04241bb88661fd709f002d0e3b080f2c105042bb8e22b244d9417b7d2a356f70d6bf7834281a406b1f484c481041c7095cba233b9d51e2e81b268de47a4e1ec1dd05460ddb71d18671fa9b4d6d5557d0fb5c2fcb8f794dcbdc5837fbf3223646b3a6c35081fede97ce702962f9680caf845eb2ab63406db8a8524d819acd82010dacfef1c1c53b21c69ae38099474cac31f8cb7a07e673279b8c02d032411c0cd5b0509d13296707a76ef4c78920795cb00dcc2e504ccada7332a107064ae0061b2fbc8432488fa7e0c0a495d03b352a3d05c9b23364c12b21c94ada766d64a7502660e2170dd56a5d9cd2a1d497dbdc26150a2c1c4e9acf474f9e51ae93dec587db26f308157a2e14d96d12348d92713fdee00d3341ddaca42ca70d4e95eca9e1a3a9c5cd2f22cb365a932c48ae9a8f659e3345dd71e5313bfffbe951266260d261eff9a05e0c3064467cefe92884e888c18775b5240f81db6cc2e9d4c94c975d9c6ced1eed99a104a72d870eb585d5deb81fb77f9af0d9c4fc2ddd4cc4db6ab0e0b5a247d7424bce90a61dd40fc330f27475e8a768ab05fdd8abe200a4b81983d2ff90a6f6ef38e8e51e74dbe6ad0c62e950d9b05034a6fcd266daadb1c3c38afde18be0e1413e417a235727e857d7d3edb8aec34c4e8ca6b1e7b977c2404273b6b38dd5a9859e4937473c147eb2a46a03f89b244c5f67f8d088949471f432cc3091905cdbeaf7dd0c8cf09866e92e0675321253073df8bbb72c1895a45f8f56620bdfeea205faad560e2efa2c1661a75a5c1fcbc859dcd43e754fc72f9c34eb2104b15e7a0d8af8128a08228b5740d8bbb137717b89195f3a524170b5a3109d338f1cea2cccaed0fa2b333672109cbb49d5be0aef85b0d6217e50712ef6a7dc861fd38c9f7c48a71736e20e720fcbfd10a9391c96e87da44bf3dbbc1d6659944670eea1e6f3af20ca829169f3ac5da1cc15e4acb06f003b8e771cf941b2c6ca7a65faa3b3f132e31584eee6be0fb96710d8647ec080e482a056ddf708e959b27aa74752430775c20d93ede87185f6aad40855c6f421ddf98a3478ad3b1565ebbfe6e86a19bbb4be879a79306aaec2844d2169d64114baa5bb154ce032010885d82bf78041d59b1b175e96660b089d6850e89fc48f16455e26b935452f1a5c2a3602e8e6a6a4bc9c29af9757b340640483893d6d77968d8962ff24789b7623d067cd34ae81e61eb634aff0bd6e12cb07404652d51725b8c383e35b25b366d80debb4b314a7b2d2b8798276879767dcbe4f921a5e88dff2b9c79cef404d4c22613d9064b7427ea89260e72d6afb816d500596c6ff4d7ad1dcae0116c497807cfd38a87a8288ad5604efbe11f2e69809d346af274968a82a483eb4c70388492d61d7d2a5ed14aed2b1a774a6bfae3e65af4b4db885d53ed683832074d8a084f05f0dc723750903caf4d96a695b3e8193f4daa1067ac162b47b907e8b930ae3d508ff1df54a598ca5cf59692b605e23eaded8c537a0bf870f3ef920facf8a4ba4631ff302ab393703bd053afb835a3801ab973093f1c39a2938d8f6249a794d6d9784a8bd9c5e798c51622aaac0cf199a3b3e0ec1bf0aa6848787a2e798ae0a91a8872189687c3aadcd52b65b5b6d7bd1500a1600a2751de323a39b4edacf71ae01b9faa1d0c097dd48607ab594e9aa54ad5584e5e76d30f4048fcaa9b59aae6f3c24f9bb03a29b4556e1ce5302210929d24f976b15073043fa753b2bf8ac3577d858720bdadb51f6b0ea845331988d4f16a6dbd69e11ee5cefc45d9911bd65193d9dba8f10908f7d125c05d25d00970e007e16ae338870dca3c64f2d933c5cc9d641f560079ec71fad24a166b1305df67b740ecd9a1b8392f574d321ffdedd0c0d13be2d69e2cc136df21639f6f9d170d97b7350ca188616400c523fd6f3d0c155f0d9f1660b4c3ab03ddd79d5be299b689da551c617d985a6bd133521f8c06216910488110a474c8dced745f8dd05cd958614da6d1a6c26c8aac2fcba719704069974710e50452ecd7283b9f4ef8ba32cddc8531da240af2f15fc44c792bbc6d4289f479efd0246e32db21d734b07cb4e6615bd23e39fb771652c9f142b1d54e0746727b124e6d7f6b5a47f047189c89ff913170fed673ea64732dcd9d9c55fc3d41a60a429afac0cee2ff77b78678d286a59087106cc12b76cc1e5eb6da8a9cb94e3814f3529096a9d3857ddcffd81198310ca4d1bf74c01251415eae65dbae85da12ac4fd070620362a203aa1cf7e8413ab8e5926ff496fb893e62e27675afd0f0419a8823ba1819986b1a68d92143f499c287e6af99ea2991b8d964b66b53ad1648d6889131684c19f09c942684785f2e2ca35029d630745b45d64bfa69a9ba0483ffc73e2904e21a1ef2135d952e5a60036b0e3a35598e4a706fe559b24698e011cd543c8c55162983148c71c5639827bc64df45e0349d2e897589c0a125172441a53f8bb67d57c9399315bf89a122dac5ec382f6ec8b0e21bdf76e7059d052f5b110f4cfe4a7a77dfe7f6ddb9b9858ba3135c03b7f11d84ac32aba6df977e198e5a935ed67c744340a3b1802e5f2884e352fdbf857a7021aec66548a0d53432ec5b3a851a3f17ffb41ccd3c5dc59210fc57c3fbfb9874cda4bee19a14e9494ef3800b2fba6994d4d96e62b41e509df064b5414700085072b822010e3e319f9d86b720bf217cf568b0e52de3895561c5cdaebe7a769c12cce23979de3129d311797a55fae5f52f22835f8c99a5adfc79f714b0c7e232a86c887eba6a057ef3e8fdeffc59a87484bc71ed33444d4fda03cbb66bb1269dec58aadde1d095c6a1834b7aa213533df06455965333836caa97317efd11169407a09ca018cfac0f906cd8fa4a117c7c3cb495c1c33ae9cdffdb96592dce37441ae6700a04798ad38193ac7283852b10d304d146f545f4e23d281b0106a495d40931cd7b4c9c9c71950318035b38aac8416909e812c6eb87a531e22b4131789b38fb8b900a71614bd18cc3140ae678be6c2c165bc9ea0a91ad02d47270ca2eda3cdf3418fbb463fdc15633f55845883e8686674aaf68645ad2430dbad1db2c24e80ba5cb90668b54de420a2fc422fadcd4f0bcb833ab2906524ca7af66085537cc23db0e191d476f81a0b56c4a30c9766910568ffa1cf320a5dcfcaa5a8a17595d5a95c799a6dba394193a826f0f7cdcd2f3221943738ee1db94b8fdd0e66ba166f2dccaf8ec59fdcd72076d6a039e06a4e1c1fdf5efb0ce158106c378572c8e9fa2bd60a611b197eb2598f02d2cf252d1c2d77dbf68e8271f43884030a300d1dad4d03bb0dc21c3db59174514dbbd4423cd7a40c6a165349712923cfd77ef782e9b455614f689631661a68ded405a3700d4349b84478a91726b8afe499c14b45af9196f4f33e563ea4dc5a04d5a0b277b3cda0a07</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不要随便看别人日记哦</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这篇文章被密码保护。</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划题目随解</title>
    <link href="http://summace.cc/dp/"/>
    <id>http://summace.cc/dp/</id>
    <published>2023-09-04T16:00:00.000Z</published>
    <updated>2023-09-21T00:49:27.328Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新。</p><span id="more"></span><h1 id="cf258d-little-elephant-and-broken-sorting">CF258D LittleElephant and Broken Sorting</h1><p><a class="link"   href="https://codeforces.com/contest/258/problem/D" >Link</a><spanclass="math inline">\((^*2600)\)</span></p><blockquote><p>给定排列 <span class="math inline">\(p\)</span>，有 <spanclass="math inline">\(m\)</span> 次操作，每次操作给定 <spanclass="math inline">\(x,y\)</span>，等概率选择是否交换。求 <spanclass="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=i}^{n}P(p_i&gt;p_j)\)</span>。</p><p><span class="math inline">\(n,m\leq 10^3\)</span>。</p></blockquote><p>考虑直接设 <span class="math inline">\(f_{l,r}\)</span> 表示 <spanclass="math inline">\(p_l&gt;p_r\)</span>的概率。初始化很好初始化，我们考虑直接对操作进行转移。</p><p>假如我们要交换 <span class="math inline">\(p_l\)</span> 和 <spanclass="math inline">\(p_r\)</span>，那么此时其本身 <spanclass="math inline">\(f_{l,r}=f_{r,l}=0.5\)</span>。对于 <spanclass="math inline">\(\forall x\neql,r\)</span>，考虑不交换和交换之后的改变。</p><p>可以分以下情况讨论：</p><ol type="1"><li><spanclass="math inline">\(f_{x,l}=\dfrac{f_{x,l}+f_{x,r}}{2}\)</span>；</li><li><spanclass="math inline">\(f_{r,x}=\dfrac{f_{r,x}+f_{l,x}}{2}\)</span>；</li><li><spanclass="math inline">\(f_{l,x}=\dfrac{f_{l,x}+f_{r,x}}{2}\)</span>；</li><li><spanclass="math inline">\(f_{x,r}=\dfrac{f_{x,r}+f_{x,l}}{2}\)</span>。</li></ol><p>容易发现 <span class="math inline">\(1\)</span> 和 <spanclass="math inline">\(4\)</span>、<span class="math inline">\(2\)</span>和 <span class="math inline">\(3\)</span>的转移是相同的，可以一起处理。最后扫一遍即可，<spanclass="math inline">\(O(n^2)\)</span>。</p><details><summary>Code(Tap)</summary><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">read</span>(l, r);</span><br><span class="line">    f[l][r] = f[r][l] = <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == l || x == r) <span class="keyword">continue</span>;</span><br><span class="line">        f[x][l] = f[x][r] = ((f[x][l] + f[x][r]) / <span class="number">2.00</span>);</span><br><span class="line">        f[r][x] = f[l][x] = ((f[r][x] + f[l][x]) / <span class="number">2.00</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h1 id="cf1185g2-playlist-for-polycarp">CF1185G2 Playlist forPolycarp</h1><p><a class="link"  href="https://codeforces.com/contest/1185/problem/G2" >Link</a><spanclass="math inline">\((^*2600)\)</span></p><blockquote><p>给定 <span class="math inline">\(n\)</span> 首歌，每首歌有时间 <spanclass="math inline">\(t_i\)</span> 与流派 <spanclass="math inline">\(g_i\)</span>。需要从中排列若干首歌，使得时间恰好为<span class="math inline">\(T\)</span>，且相邻流派不同。</p><p><span class="math inline">\(1\leq n\leq 50,1\leq T\leq 2500,1\leqt_i\leq 50,1\leq g_i\leq 3\)</span>。</p></blockquote><p>不妨设 <span class="math inline">\(f_{i,j,k,1/2/3}\)</span>表示三种流派分别选了 <span class="math inline">\(i,j,k\)</span>首，最后一首为 <span class="math inline">\(1/2/3\)</span>的方案数。这个显然是很好转移的，时间复杂度 <spanclass="math inline">\(O(n^3)\)</span>。由于我们要求的是排列，因此还要乘一个<span class="math inline">\(i!j!k!\)</span>。</p><p>然后我们在考虑相邻流派不同，时间恰好为 <spanclass="math inline">\(T\)</span>的方程。这个有点类似于背包，但是直接背包时间复杂度是 <spanclass="math inline">\(O(n^3T)\)</span> 的，不能接受。</p><p>这里有一个比较巧妙的方法：将背包拆分成两个背包之后再分别求解。即我们记<span class="math inline">\(g_{i,t}\)</span> 为选择 <spanclass="math inline">\(1\)</span> 的背包，<spanclass="math inline">\(h_{j,k,t}\)</span> 为选择 <spanclass="math inline">\(2,3\)</span> 的背包。这样时间复杂度分别为 <spanclass="math inline">\(O(nT),O(n^2T)\)</span>。最后我们只需要枚举 <spanclass="math inline">\(g\)</span> 的 <spanclass="math inline">\(t\)</span>，<span class="math inline">\(h\)</span>的 <span class="math inline">\(t\)</span> 可以由 <spanclass="math inline">\(T-t\)</span> 得出。</p><p>最后我们将答案乘在一起即可。</p><details><summary>Code(Tap)</summary><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>] = f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n1; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n2; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n3; k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= <span class="number">3</span>; v++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i][j][k][v] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(v != <span class="number">1</span>) f[i + <span class="number">1</span>][j][k][<span class="number">1</span>] += f[i][j][k][v], f[i + <span class="number">1</span>][j][k][<span class="number">1</span>] %= mod;</span><br><span class="line">                <span class="keyword">if</span>(v != <span class="number">2</span>) f[i][j + <span class="number">1</span>][k][<span class="number">2</span>] += f[i][j][k][v], f[i][j + <span class="number">1</span>][k][<span class="number">2</span>] %= mod;</span><br><span class="line">                <span class="keyword">if</span>(v != <span class="number">3</span>) f[i][j][k + <span class="number">1</span>][<span class="number">3</span>] += f[i][j][k][v], f[i][j][k + <span class="number">1</span>][<span class="number">3</span>] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>] = h[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = T - a[<span class="number">1</span>][i]; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            g[j + <span class="number">1</span>][k + a[<span class="number">1</span>][i]] += g[j][k], g[j + <span class="number">1</span>][k + a[<span class="number">1</span>][i]] %= mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = T - a[<span class="number">2</span>][i]; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            h[j + <span class="number">1</span>][<span class="number">0</span>][k + a[<span class="number">2</span>][i]] += h[j][<span class="number">0</span>][k], h[j + <span class="number">1</span>][<span class="number">0</span>][k + a[<span class="number">2</span>][i]] %= mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n3; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = n2; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v = T - a[<span class="number">3</span>][i]; v &gt;= <span class="number">0</span>; v--)</span><br><span class="line">                h[j][k + <span class="number">1</span>][v + a[<span class="number">3</span>][i]] += h[j][k][v], h[j][k + <span class="number">1</span>][v + a[<span class="number">3</span>][i]] %= mod;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n1; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n2; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n3; k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= T; t++)</span><br><span class="line">                <span class="keyword">if</span>(g[i][T - t])</span><br><span class="line">                    ans += ((f[i][j][k][<span class="number">1</span>] + f[i][j][k][<span class="number">2</span>]) % mod + f[i][j][k][<span class="number">3</span>]) % mod * fct[i] % mod * fct[j] % mod * fct[k] % mod * h[j][k][t] % mod * g[i][T - t] % mod, ans %= mod;</span><br></pre></td></tr></table></figure></div></details><h1 id="cf1699e-three-days-grace">CF1699E Three Days Grace</h1><p><a class="link"   href="https://codeforces.com/contest/1699/problem/E" >link</a><spanclass="math inline">\((^*2600)\)</span></p><blockquote><p>给定 <span class="math inline">\(n\)</span> 个元素的可重集 <spanclass="math inline">\(S\)</span>，值域为 <spanclass="math inline">\([1,m]\)</span>，你可以进行若干次操作：选择 <spanclass="math inline">\(A_i\in S\)</span>，将其拆分成 <spanclass="math inline">\(p\cdot q=A_i\)</span>，删除 <spanclass="math inline">\(A_i\)</span> 并加入 <spanclass="math inline">\(p,q\)</span>。需要最小化极差。</p><p><span class="math inline">\(1\leq n\leq 10^6, 1\leq m\leq 5\cdot10^6\)</span>。</p></blockquote><p>想象一个竖直的数轴，考虑将一个点拆分的过程实际相当于将比较高的点变换到比较低的位置。</p><p>这给我们一个启示：答案一定在一个区间 <spanclass="math inline">\([l,r]\)</span>内，进一步我们可以找出类似于双指针的方法：固定 <spanclass="math inline">\(l\)</span>，并从大到小维护 <spanclass="math inline">\(r\)</span>。</p><p>于是我们不妨设 <span class="math inline">\(f_{l,i}\)</span>表示区间下界在 <span class="math inline">\(l\)</span>，当前枚举到点<span class="math inline">\(i\)</span>，此时的最小最大值。</p><p>考虑转移到 <span class="math inline">\(j\)</span>，若 <spanclass="math inline">\(j\)</span> 不能被拆分出来，那么 <spanclass="math inline">\(f_{l,i}=f_{l+1,i}\)</span>；如果 <spanclass="math inline">\(j\)</span>可以被拆分出来，那么我们把这个拆出去，<spanclass="math inline">\(f_{l,i}=\min\{f_{l,\frac{j}{i}}\,f_{l,i}\}\)</span>。由于不一定只拆出来一个<spanclass="math inline">\(i\)</span>，所以这里我们可以用一些多重背包的思想。</p><p>但是这样是不能接受的。考虑怎么优化：首先可以压掉第一维，然后第二维从<span class="math inline">\(i\times i\)</span> 开始每次 <spanclass="math inline">\(+i\)</span>，是调和级数级别的。</p><p>然后我们考虑在 <span class="math inline">\(i\)</span>不变的情况下，随着 <span class="math inline">\(l\)</span> 下降，<spanclass="math inline">\(f\)</span> 是单调递减的。因此我们可以对 <spanclass="math inline">\(f\)</span>数组开桶，用指针向下扫到第一个存在值的位置。</p><p>这样的时间复杂度是 <span class="math inline">\(O(m\log m)\)</span>的。</p><details><summary>Code(Tap)</summary><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(n, m);</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, (m + <span class="number">1</span>) * <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(t, <span class="number">0</span>, (m + <span class="number">1</span>) * <span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> lim = <span class="number">1e9</span> + <span class="number">7</span>, ans = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">    lim = <span class="built_in">min</span>(lim, x);</span><br><span class="line">    a[x] = t[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) f[i] = i;</span><br><span class="line"><span class="type">int</span> pt = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = m; i; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i * i &lt;= m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i * i; j &lt;= m; j += i)</span><br><span class="line">        &#123;</span><br><span class="line">            t[f[j]] -= a[j];</span><br><span class="line">            f[j] = <span class="built_in">min</span>(f[j], f[j / i]);</span><br><span class="line">            t[f[j]] += a[j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!t[pt]) pt--;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= lim) ans = <span class="built_in">min</span>(ans, pt - i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br></pre></td></tr></table></figure></div></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续更新。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>线性代数学习笔记</title>
    <link href="http://summace.cc/Linear-Algebra/"/>
    <id>http://summace.cc/Linear-Algebra/</id>
    <published>2023-08-01T16:00:00.000Z</published>
    <updated>2023-09-15T01:15:42.724Z</updated>
    
    <content type="html"><![CDATA[<p>学数论学自闭了，感觉线性代数还可以。</p><p>供自己复习用。</p><span id="more"></span><h1 id="矩阵">矩阵</h1><p>一个具有 <span class="math inline">\(n\)</span> 行 <spanclass="math inline">\(m\)</span> 列元素的矩形阵列，形如：</p><p><span class="math display">\[A=\begin{bmatrix}    a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,m}\\    a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; a_{2,m}\\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    a_{n,1} &amp; a_{n,2} &amp; \cdots &amp; a_{n,m}\\\end{bmatrix}\]</span></p><ul><li>主对角线：<span class="math inline">\(A_{i,i}\)</span> 的元素。</li><li>单位矩阵：主对角线为 <span class="math inline">\(1\)</span>，其余为<span class="math inline">\(0\)</span> 的矩阵，记为 <spanclass="math inline">\(I\)</span>。</li><li>方阵：行数和列数相等的矩阵。</li><li>同型矩阵：行数和列数分别相等的矩阵。</li></ul><h2 id="矩阵的运算">矩阵的运算</h2><h3 id="矩阵的加减">矩阵的加减</h3><p>只有同型矩阵才可以加减，直接将对应位置加减即可。</p><h3 id="转置矩阵">转置矩阵</h3><p>将矩阵行列互换，记作 <span class="math inline">\(A^{T}\)</span>。</p><h3 id="矩阵乘法">矩阵乘法</h3><p>设 <span class="math inline">\(A\)</span> 是 <spanclass="math inline">\(N \times K\)</span> 的矩阵，<spanclass="math inline">\(B\)</span> 是 <span class="math inline">\(K\timesM\)</span> 的矩阵，则乘积 <span class="math inline">\(C\)</span>为：</p><p><span class="math display">\[C_{i,j}=\sum\limits_{i=1}^KA_{i,k}B_{k,j}\]</span></p><h3 id="方阵的逆">方阵的逆</h3><p>若有方阵 <span class="math inline">\(P\)</span> 使方阵 <spanclass="math inline">\(A\times P=I\)</span>，则称方阵 <spanclass="math inline">\(P\)</span> 为方阵的逆矩阵。</p><p>逆矩阵不一定存在。</p><h1 id="行列式">行列式</h1><h2 id="积和式">积和式</h2><p>方阵 <span class="math inline">\(A\)</span>的积和式为不同行不同列所有排列 <span class="math inline">\(p_i\)</span>的乘积之和。显然，这样的排列有 <span class="math inline">\(n!\)</span>个。</p><h2 id="行列式-1">行列式</h2><p>在积和式的基础上，记 <span class="math inline">\(\pi_i\)</span> 为<span class="math inline">\(p_i\)</span>中下标的逆序对个数，那么对于每个 <spanclass="math inline">\(p_i\)</span> 乘积，累加时赋上符号，若 <spanclass="math inline">\(\pi_i\)</span> 为偶数，则为正，否则为负。</p><p><span class="math display">\[\det(A)=\sum\limits_{i=1}^{n!}(-1)^{\pi_i}\prod\limits_{j=1}^{n}p_{i,j}\]</span></p><p>一些性质：</p><ul><li>转置矩阵的行列式不变。</li><li>交换任意两行（列）行列式取反。</li><li>某一行（列）乘 <span class="math inline">\(k\)</span>，行列式乘<span class="math inline">\(k\)</span>。</li><li>某一行整体加上另一行，行列式不变。</li></ul><h2 id="伴随矩阵">伴随矩阵</h2><h3 id="余子式">余子式</h3><p>矩阵 <span class="math inline">\(A\)</span> 第 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的余子式：</p><p><span class="math display">\[M_{i,j}=\det A&#39;_{i,j}\]</span></p><p>其中 <span class="math inline">\(A&#39;_{i,j}\)</span> 表示删除矩阵<span class="math inline">\(A\)</span> 第 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列后所得矩阵。</p><h3 id="代数余子式">代数余子式</h3><p>矩阵 <span class="math inline">\(A\)</span> 第 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的代数余子式：</p><p><span class="math display">\[C_{i,j}=(-1)^{i+j}M_{i,j}\]</span></p><h3 id="伴随矩阵-1">伴随矩阵</h3><p>矩阵 <span class="math inline">\(A\)</span> 的伴随矩阵 <spanclass="math inline">\(\text{adj} A\)</span> 为 <spanclass="math inline">\(A\)</span> 的余子矩阵的转置矩阵。</p><p><span class="math display">\[\text{adj} A=C^{T}\]</span></p><h3 id="可逆矩阵">可逆矩阵</h3><p>对于可逆矩阵，<span class="math inline">\(A^{-1}=\dfrac{\text{adj}A}{\det A}\)</span>。</p><p>若矩阵不可逆，则 <span class="math inline">\(\det A=0\)</span>。</p><h1 id="线性空间">线性空间</h1><p>若代数系统 <spanclass="math inline">\((V,+,\cdot,\mathbb{P})\)</span> ，其中 <spanclass="math inline">\(V\)</span> 为向量集，<spanclass="math inline">\((V,+)\)</span> 为阿贝尔群，<spanclass="math inline">\(\mathbb{P}\)</span> 为域，<spanclass="math inline">\(\cdot\)</span> 为数乘运算，满足以下条件：</p><ol type="1"><li>数乘：<span class="math inline">\(\mathbb{P}\)</span> 中元素 <spanclass="math inline">\(p\)</span> 与 <spanclass="math inline">\(V\)</span> 中元素 <spanclass="math inline">\(v\)</span> 运算结果 <spanclass="math inline">\(pv\)</span> 在 <spanclass="math inline">\(V\)</span> 中，且有意义，且满足封闭性。</li><li>数乘对向量和标量都满足加法分配律。</li><li>数乘满足结合律。</li><li>存在标量乘法单位元。</li></ol><p>则称其为线性空间。</p><h2 id="线性相关与线性无关">线性相关与线性无关</h2><p>若向量组 <span class="math inline">\(a_i \in V\)</span> 和任意标量组<span class="math inline">\(k_i\in \mathbb{P}\)</span> 满足 <spanclass="math inline">\(\sumk_ia_i=\theta\)</span>，则称这组向量线性无关，否则称线性相关。</p><p>零向量与任意向量线性相关。</p><h2 id="线性基">线性基</h2><p>线性空间 <span class="math inline">\(V\)</span>的一个极大线性无关组称为 <span class="math inline">\(V\)</span>的一组<strong>线性基</strong>，简称基。</p><p><span class="math inline">\(V\)</span> 的维数记为 <spanclass="math inline">\(\dim V\)</span>，为线性基元素个数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学数论学自闭了，感觉线性代数还可以。&lt;/p&gt;
&lt;p&gt;供自己复习用。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="http://summace.cc/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="http://summace.cc/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法与border浅记</title>
    <link href="http://summace.cc/KMP/"/>
    <id>http://summace.cc/KMP/</id>
    <published>2023-07-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:12:53.002Z</updated>
    
    <content type="html"><![CDATA[<p>终于完全明白了困扰多年的 KMP 算法，果然从 border理论理解才是最好的。</p><p>因此写下本文，供自己复习。</p><span id="more"></span><h1 id="border">border</h1><p>首先给出 <span class="math inline">\(\text{border}\)</span>的定义：在字符串 <span class="math inline">\(S\)</span>中，最长的<strong>真</strong>公共前后缀。</p><p>显然，<span class="math inline">\(\text{border}\)</span> 的 <spanclass="math inline">\(\text{border}\)</span> 也是 <spanclass="math inline">\(S\)</span> 的一个 <spanclass="math inline">\(\text{border}\)</span>。</p><p>我们定义 <span class="math inline">\(\text{nxt}[i]\)</span> 为 <spanclass="math inline">\(S[1\dots i]\)</span> 的 <spanclass="math inline">\(\text{border}\)</span>，考虑如何快速求 <spanclass="math inline">\(\text{nxt}\)</span>。</p><p>假设我们现在已知 <span class="math inline">\(\text{nxt}[1\dotsn]\)</span>，想要求出 <spanclass="math inline">\(\text{nxt}[n+1]\)</span>。</p><p>考虑 <span class="math inline">\(S[n+1]\)</span> 和 <spanclass="math inline">\(S[\text{nxt}[n]+1]\)</span>是否匹配。如果匹配，那么显然。 <spanclass="math inline">\(\text{nxt}[n+1]=\text{nxt}[n]+1\)</span>，否则我们继续考虑它是否可以和<span class="math inline">\(\text{nxt}[\text{nxt}[n]]\)</span>匹配。我们一直匹配到成功即可。</p><p>这样可以均摊 <span class="math inline">\(O(n)\)</span> 求出 <spanclass="math inline">\(\text{nxt}\)</span>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&quot; &quot;</span> + S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nxt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = S.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; S[i] != S[j + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(S[i] == S[j + <span class="number">1</span>] &amp;&amp; j + <span class="number">1</span> &lt; i) nxt[i] = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="kmp">KMP</h1><p><span class="math inline">\(\text{KMP}\)</span>是用来快速匹配字符串的算法。</p><p>给定模式串 <span class="math inline">\(S\)</span>，文本串 <spanclass="math inline">\(T\)</span>，求 <spanclass="math inline">\(S\)</span> 在 <spanclass="math inline">\(T\)</span> 中所有匹配。</p><p>记 <span class="math inline">\(S\)</span> 长度为 <spanclass="math inline">\(s\)</span>，<span class="math inline">\(T\)</span>长度为 <span class="math inline">\(t\)</span>。</p><p>我们将 <span class="math inline">\(S\)</span> 和 <spanclass="math inline">\(\#\)</span> 和 <spanclass="math inline">\(T\)</span> 拼在一起，形成了 <spanclass="math inline">\(S\#T\)</span> 的新字符串。我们求出来这个字符串的<span class="math inline">\(\text{nxt}\)</span>。</p><p>之后我们从 <span class="math inline">\(s+1\)</span> 开始（即从 <spanclass="math inline">\(T\)</span> 开始）遍历 <spanclass="math inline">\(\text{nxt}\)</span>。如果 <spanclass="math inline">\(\text{nxt}[i] =s\)</span>，那么这是一个成功的匹配。</p><p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于完全明白了困扰多年的 KMP 算法，果然从 border
理论理解才是最好的。&lt;/p&gt;
&lt;p&gt;因此写下本文，供自己复习。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="字符串" scheme="http://summace.cc/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="KMP" scheme="http://summace.cc/tags/KMP/"/>
    
    <category term="border 理论" scheme="http://summace.cc/tags/border-%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>线段树浅记</title>
    <link href="http://summace.cc/Segment-Tree/"/>
    <id>http://summace.cc/Segment-Tree/</id>
    <published>2023-07-22T16:00:00.000Z</published>
    <updated>2023-09-27T11:23:12.897Z</updated>
    
    <content type="html"><![CDATA[<p>系统复盘了一下线段树，发现网上现有博客鲜有将线段树各种操作一步一步讲明白的，故结合自己理解写此文。</p><p>应该会持续更新。</p><span id="more"></span><h1 id="线段树">线段树</h1><p>先来看一个经典问题：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 x v</code>：给 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>考虑最朴素的暴力：对于 <span class="math inline">\(1\)</span>操作，直接在数组上更改。对于每次 <span class="math inline">\(2\)</span>操作，我们暴力遍历一遍整个数组。这样单次修改复杂度是 <spanclass="math inline">\(O(1)\)</span>，但是查询复杂度是 <spanclass="math inline">\(O(n)\)</span>，最坏时间复杂度 <spanclass="math inline">\(O(nq)\)</span>，比较爆炸。</p><p>线段树作为一种基础的高级数据结构，具有单次修改、查询均为 <spanclass="math inline">\(O(\log n)\)</span>的优秀复杂度。这时候运用线段树，就比较好解决这个问题了。</p><h2 id="结构">结构</h2><p>我们先来说一下线段树的结构。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.luogu.com.cn/upload/image_hosting/gmqvut8k.png"                     alt="线段树"                 ><figcaption aria-hidden="true">线段树</figcaption></figure><p>考虑现在有一段长度为 <span class="math inline">\(5\)</span> 的区间<span class="math inline">\([1,5]\)</span>，我们递归地每次分成两半。</p><p>第一层：<span class="math inline">\([1,5]\)</span>，第二层：<spanclass="math inline">\([1,3],[4,5]\)</span>，以此类推……</p><p>现在 <span class="math inline">\(d_1\)</span> 就记录着区间 <spanclass="math inline">\([1,5]\)</span> 的信息，<spanclass="math inline">\(d_2\)</span> 记录着 <spanclass="math inline">\([1,3]\)</span>的信息，以此类推。这个信息可以是多种多样的，根据本题的题意，我们可以记录“区间和”这个信息。此时，<spanclass="math inline">\(d_1\)</span> 就表示着区间 <spanclass="math inline">\([1,5]\)</span> 的和为 <spanclass="math inline">\(60\)</span>。</p><p>显然，我们现在的 <span class="math inline">\(d\)</span>数组构成了一个二叉树型结构，<span class="math inline">\(d_1\)</span>的儿子是 <span class="math inline">\(d_2\)</span> 和 <spanclass="math inline">\(d_3\)</span>，<spanclass="math inline">\(d_2\)</span> 的儿子是 <spanclass="math inline">\(d_4\)</span> 和 <spanclass="math inline">\(d_5\)</span>。那么根据二叉树的性质，我们很容易可以知道，若父亲节点的编号是<span class="math inline">\(k\)</span>，那么它的左儿子的节点编号应该是<span class="math inline">\(2k\)</span>，右儿子的节点编号应该是 <spanclass="math inline">\(2k+1\)</span>。</p><p>这样，一颗线段树的基本结构就出来了。</p><p>考虑一下我们需要维护哪些信息？首先，区间和 <spanclass="math inline">\(sum\)</span>。其次，我们需要维护当前节点所维护区间的左右端点<span class="math inline">\(l,r\)</span>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br></pre></td></tr></table></figure></div><p>哎？你这个 <span class="math inline">\(tr\)</span> 数组怎么开了 <spanclass="math inline">\(4\)</span> 倍的空间啊？线段树节点数量不是 <spanclass="math inline">\(2n\)</span> 的吗？</p><p>我们理想的线段树形态应该是一棵满二叉树。此时，节点数量就是完美的<span class="math inline">\(2n\)</span>个了。但是有时事与愿违。我们采用的编号方法是左儿子 <spanclass="math inline">\(2k\)</span>，右儿子 <spanclass="math inline">\(2k+1\)</span>，这样当我们原区间不是 <spanclass="math inline">\(2^m\)</span> 的时候就会发生“左偏”（如上图）。</p><p>容易发现：左儿子和右儿子层数最多相差一。因此，我们线段树的节点有可能会延伸到叶子节点下面的一层，所以需要多开<span class="math inline">\(2n\)</span> 个节点，即 <spanclass="math inline">\(4n\)</span>。</p><blockquote><p>注：无特殊说明外，本文 <span class="math inline">\(\log\)</span> 均为<span class="math inline">\(\log_2\)</span>。</p></blockquote><h2 id="信息的上传">信息的上传</h2><p>然而，我们现在的线段树只是一颗线段树，跟原来的序列没有啥关系啊？</p><p>考虑这颗线段树的叶子节点。我们发现叶子节点维护的区间都只有一个数，那么这个就对应着我们原序列的值。也就是说，左右端点均为<span class="math inline">\(i\)</span> 的线段树节点，其区间和就是 <spanclass="math inline">\(a_i\)</span> 的值。</p><p>然后我们需要让整棵树都维护正确的信息，这时候就需要我们把信息由下到上地更新。我们记载的信息是区间和，那么显然，父亲节点的信息就是儿子节点信息之和，也就是说：<spanclass="math inline">\(tr[k].sum=tr[ls(k)].sum+tr[rs(k)].sum\)</span>。</p><blockquote><p>注：下文将用 <span class="math inline">\(tr\)</span> 代替 <spanclass="math inline">\(d\)</span>。</p></blockquote><p>这里的 <span class="math inline">\(ls(k) = 2k, rs(k) =2k+1\)</span>，分别表示了当前节点的左右儿子。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="comment">//常用技巧，使用#define会让你的代码更美丽</span></span><br><span class="line"><span class="comment">//根据基本的位运算常识，k&lt;&lt;1=2k, k&lt;&lt;1|1=2k+1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="建树">建树</h2><p>著名感情学家鸭子曾经说过：我们要有所建树。不建树是一个线段树题目中常见的**错误。</p><p>考虑我们是怎么讲述一颗线段树的结构的？<spanclass="math inline">\(d_1\)</span>记录着整个区间的信息，然后每次将区间分成两半，分别记录着左右两半区间的信息……</p><p>那么参照这个思想，我们就可以建树了。从 <spanclass="math inline">\(d_1\)</span>出发，依次建立左右儿子的初始信息，然后 <spanclass="math inline">\(pushup\)</span>，把下层的节点信息上传到上层。对于叶子节点，此时显然一定有<span class="math inline">\(tr[k].l=tr[k].r\)</span>，<spanclass="math inline">\(tr[k].sum=a[l]\)</span>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].l = l;</span><br><span class="line">    tr[k].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>时间复杂度显然 <span class="math inline">\(O(n)\)</span>。</p><h2 id="单点修改">单点修改</h2><p>好了，现在树也建好了，是时候干点操作相关的事情了。单点修改！</p><p>这个东西有点像二分。由于我们只修改一个点，那么我们只需要每次看看这个点在左右两半区间的那边，然后一直到叶子的时候把它修改了，再更新一下整棵树就可以了。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].l == tr[k].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">update</span>(ls, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由于我们最多跳 <span class="math inline">\(\log(n)\)</span>次，因此单点修改的时间复杂度是 <span class="math inline">\(O(\logn)\)</span> 的。</p><h2 id="区间查询">区间查询</h2><p>那么接下来解决最后一个问题：区间查询。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.luogu.com.cn/upload/image_hosting/ybjuqqrm.png"                     alt="线段树"                 ><figcaption aria-hidden="true">线段树</figcaption></figure><p>再看一眼这张图。如果我们要查询区间 <spanclass="math inline">\([2,5]\)</span>的值，那么比较理想的状态应该是什么？</p><p>应该是，我们每次找到可以被询问区间包含的<strong>极大</strong>区间，最后将所有区间的信息相加。</p><p>太抽象了？让我们具体看看。</p><p>从第一层开始：<span class="math inline">\([1,5]\)</span>的信息显然太大了，我们用不了，那么往下面找。</p><p>现在我们有区间 <span class="math inline">\([1,3]\)</span> 和 <spanclass="math inline">\([4,5]\)</span> 的信息。我们发现 <spanclass="math inline">\([2,5]\)</span> 完全包含 <spanclass="math inline">\([4,5]\)</span>，也就是说 <spanclass="math inline">\([4,5]\)</span>的信息可以被我们利用，那么就算上它的区间和。那啥叫极大呢？我们发现利用<span class="math inline">\([4,5]\)</span> 的信息显然比分别利用 <spanclass="math inline">\([4,4]\)</span> 和 <spanclass="math inline">\([5,5]\)</span>要更优。意思就是：我们能用父亲的信息，就不用儿子的信息。</p><p>继续，我们现在还差 <span class="math inline">\([2,3]\)</span>的信息没解决。由于右边已经完成了，那么我们直接在左边找就可以。第三层是<span class="math inline">\([1,2]\)</span> 和 <spanclass="math inline">\([3,3]\)</span>，其中我们可以用 <spanclass="math inline">\([3,3]\)</span> 的信息，把它加上。</p><p>然后我们继续往下找，发现了 <span class="math inline">\([1,1]\)</span>和 <span class="math inline">\([2,2]\)</span>，其中我们可以利用 <spanclass="math inline">\([2,2]\)</span> 的信息，那就把它加上。</p><p>最后，我们发现区间 <span class="math inline">\([2,5]\)</span>实际上被拆成了 <span class="math inline">\([2,2] \cup [3,3]\cup[4,5]\)</span>，我们所求的答案自然就是这几个节点的信息之和。</p><p>那么考虑一下我们应该怎么写代码：如果当前节点的区间被询问区间完全包含，那么直接加上这个区间的信息。否则，如果查询区间的左端点在左儿子内，就到左儿子内中继续查询；如果查询区间的右端点在右儿子内，就到右儿子内中继续查询。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r) <span class="keyword">return</span> tr[k].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += <span class="built_in">query</span>(ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += <span class="built_in">query</span>(rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>来分析一下时间复杂度：由于线段树只有 <spanclass="math inline">\(\log(n)\)</span> 层，那么我们也只需要询问 <spanclass="math inline">\(O(\log n)\)</span> 次，单次区间查询时间复杂度是<span class="math inline">\(O(\log n)\)</span>。</p><h2 id="区间修改与懒标记">区间修改与懒标记</h2><p>那么现在我们把这个问题进阶一下：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素加上 <spanclass="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>现在，我们由单点修改变成了区间修改。</p><p>问题在哪？我们每次修改，如果一个区间被修改区间包含，那么以它为根的整棵子树都要被修改，时间复杂度到了<span class="math inline">\(O(n)\)</span>，这是我们无法接受的。</p><p>哎？同样是涉及到区间，那为啥区间查询的复杂度很对，但是区间修改就很寄呢？</p><p>我们发现，区间查询的时候，如果一个节点被用到了，那么它的儿子就不会在被查询，因此时间复杂度可以到<span class="math inline">\(O(\logn)\)</span>。那我们能不能类比区间查询，让区间修改也这样呢？</p><p>这个时候就需要懒标记(lazy tag)出场了。</p><p>懒标记，顾名思义，是为了偷懒用的标记。</p><p>怎么偷懒呢？当我们遇到一个被修改区间完全包含的区间的时候，我们就给这个节点打上一个标记，意思是：我这个节点的后代应该被这个标记影响，但是我现在先不往下传。<del>（我知道你很急，但是你先别急）</del>到我什么时候要用到这个节点的后代的时候，我再把标记传下去。</p><p>这样的话，我们就可以保证区间修改的时间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>。</p><p>那么具体怎么实现呢？</p><p>当我们区间修改遇到一个整的区间时，我们选择仅更改当前的节点的值，并给它打上懒标记。以区间和为例，我们更改当前节点的值显然应当是<spanclass="math inline">\(v*(tr[k].r-tr[k].l+1)\)</span>，此时我们把当前节点的<span class="math inline">\(tag\)</span> 加上 <spanclass="math inline">\(v\)</span>，表示我后面的后代应当被加 <spanclass="math inline">\(v\)</span>。</p><p>然后我们想想怎么把标记下放。显然我们只需要把标记分别赋给他的两个儿子，然后把当前节点的标记清零就可以了。考虑一下，那些操作需要把标记下放？</p><p>由于需要用到后代的操作都需要下方，所以显然查询和修改都需要提前下放标记。显然，标记的下放必须在操作之前。</p><p>那么我们就可以开始写代码了。首先先单独写一个下放标记的函数<code>pushdown</code>：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[ls].tag += tr[k].tag;</span><br><span class="line">    tr[rs].tag += tr[k].tag;</span><br><span class="line">    tr[ls].sum += (tr[ls].r - tr[ls].l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    tr[rs].sum += (tr[rs].r - tr[rs].l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后我们在更新一下查询和修改的函数：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum += (tr[k].r - tr[k].l + <span class="number">1</span>) * v;</span><br><span class="line">        tr[k].tag += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[k].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += <span class="built_in">query</span>(ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += <span class="built_in">query</span>(rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="线段树的进阶用法">线段树的进阶用法</h1><p>目前我们已经解决了线段树维护区间和的问题。线段树维护区间极值也很简单，只需要在原来的代码上稍作修改即可。但是，作为十分美丽的数据结构，线段树可以维护的东西远不止这些。接下来让我们看看线段树更为进阶的用法。</p><h2 id="维护区间平方和">维护区间平方和</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素加上 <spanclass="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的平方和，即 <spanclass="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这时候就需要我们思考，线段树要维护某些东西具体需要改什么。</p><p>原本有一段需要修改的区间 <span class="math inline">\(a_l, a_{l+1},..., a_r\)</span>。我们需要维护的东西是 <spanclass="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>。</p><p>考虑我们现在对这段东西整体加上 <spanclass="math inline">\(v\)</span>，那么我们的答案就变成了 <spanclass="math inline">\(\sum\limits_{i=l}^{r}(a_i+v)^2\)</span>。</p><p>运用我们初中就学过的完全平方公式：</p><p><span class="math inline">\(\sum\limits_{i=l}^{r}(a_i+v)^2 =\sum\limits_{i=l}^{r}(a_i^2+2a_iv+v^2) =\sum\limits_{i=l}^{r}a_i^2+2v\sum\limits_{i=l}^{r}a_i+(r-l+1)v^2\)</span></p><p>我们发现前面的 <spanclass="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>就是我们原先的值，而最后的 <spanclass="math inline">\((r-l+1)v^2\)</span> 可以直接算出来，中间的 <spanclass="math inline">\(2v\sum\limits_{i=l}^{r}a_i\)</span>只需要多维护一个区间和就可以了。</p><p>那么，这道题我们就需要维护两个值：区间平方和、区间和。修改的时候按照公式中的修改即可。</p><p>思考：区间方差。</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素加上 <spanclass="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的方差。</p><p>方差：<spanclass="math inline">\(\sigma^2=\dfrac{1}{n}\sum\limits_{i=1}^{n}(x_i-\overlinex)^2\)</span></p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><h2 id="区间乘与区间加">区间乘与区间加</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：给区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素加上 <spanclass="math inline">\(v\)</span>；</p><p><code>2 l r v</code>：给区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素乘上 <spanclass="math inline">\(v\)</span>；</p><p><code>3 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这不好做？我直接开两个 <spanclass="math inline">\(tag\)</span>，分别维护加法和乘法懒标记，结果一合并不就行了！</p><p>等等，你先别急。你乘法和加法分别统计真的对吗？</p><p>例如，我们当前的数是 <spanclass="math inline">\(2\)</span>，对当前的数分别 <spanclass="math inline">\(\times 3,+2,\times 4\)</span>，答案应当是 <spanclass="math inline">\((2\times 3+2)\times4=32\)</span>。但是如果我们分别计算 <spanclass="math inline">\(multitag=3\times4=12,plustag=2\)</span>，答案就会变成 <spanclass="math inline">\(2\times12+2=26\)</span> 或者 <spanclass="math inline">\((2+2)\times 12=48\)</span>。</p><p>这是因为我们加法和乘法之间是有运算顺序的，因此我们不能简单地直接计算。</p><p>那有没有什么办法呢？当然有！我们在小学就学过一个伟大的东西，叫做乘法的分配律！</p><p>假设我们当前的节点有 <span class="math inline">\(multitag\)</span> 和<span class="math inline">\(plustag\)</span> 两个 <spanclass="math inline">\(tag\)</span>，那么当前节点的值应当是 <spanclass="math inline">\((x\timesmultitag+plustag)\)</span>，现在对这个节点进行 <spanclass="math inline">\(\times v\)</span> 的操作就会变成 <spanclass="math inline">\((x\times multitag+plustag)\times v=x\timesmultitag\times v + plustag\times v\)</span>。</p><p>于是，我们正常维护 <spanclass="math inline">\(multitag\)</span>，并且额外更新 <spanclass="math inline">\(plustag\)</span>，这样就可以了。</p><h2 id="区间开根">区间开根</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 l r v</code>：令区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素 <spanclass="math inline">\(x\)</span> 变成 <spanclass="math inline">\(\lfloor\sqrt{x}\rfloor\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5,1\leq a_i\leq10^{18}\)</span>。</p></blockquote><p>有没有发现这次的题目多了一个数据范围？</p><p>既然 <span class="math inline">\(a_i\leq10^{18}\)</span>，我们发现<strong>至多进行 <spanclass="math inline">\(6\)</span> 次 <spanclass="math inline">\(1\)</span> 操作</strong>，当前的数就会变成 <spanclass="math inline">\(1\)</span>。变成 <spanclass="math inline">\(1\)</span> 之后自然之后的操作都是无效的操作。</p><p>那么，我们在更改的时候可以暴力更改当前区间的数，并记录当前区间的最大值。如果最大值小于等于<spanclass="math inline">\(1\)</span>，那么就可以停止这个区间的更改了。</p><p>这样，查询的复杂度是不变的单次 <span class="math inline">\(O(\logn)\)</span>，我们来分析一下修改的时间复杂度。</p><p>不将值域局限在 <span class="math inline">\(10^{18}\)</span>内，我们考虑一个数会被更改多少次：</p><p><spanclass="math inline">\(a^{\left(\frac{1}{2}\right)^x}&lt;2\)</span>。</p><p>这是一个两层不等式，想得到 <span class="math inline">\(x\)</span>我们需要取两次对数，因此我们每个数最多会被更改 <spanclass="math inline">\(O(\log\log a)\)</span> （<spanclass="math inline">\(a\)</span> 为 <spanclass="math inline">\(a_i\)</span>的最大值）次。考虑我们暴力更改就相当于是单点修改，那么每对一个元素修改的复杂度就是<span class="math inline">\(O(\log n)\)</span> 的。我们一共有 <spanclass="math inline">\(n\)</span> 个元素，每个元素修改一次的复杂度是<span class="math inline">\(O(\log n)\)</span>，每个元素最多会被更改<span class="math inline">\(O(\log\log a)\)</span>次，那么，总的时间复杂度就是 <span class="math inline">\(O(n\logn\log\log a)\)</span>。单次的复杂度均摊是 <spanclass="math inline">\(O(\log n\log\log a)\)</span>的。可以通过本题。</p><h2 id="维护前前缀和">维护前前缀和</h2><blockquote><p>前缀和：<spanclass="math inline">\(S_i=\sum\limits_{k=1}^{i}a_k\)</span>；</p><p>前前缀和：<spanclass="math inline">\(SS_i=\sum\limits_{k=1}^{i}S_i\)</span>。</p><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 x v</code>：将 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>；</p><p><code>2 x</code>：查询 <spanclass="math inline">\(SS_x\)</span>。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>我们现在有三个数组：原数组 <spanclass="math inline">\(a\)</span>，前缀和数组 <spanclass="math inline">\(S\)</span>，前前缀和数组 <spanclass="math inline">\(SS\)</span>。</p><p>对于 <span class="math inline">\(1\)</span> 操作，我们要用到的是<span class="math inline">\(a\)</span>。对于 <spanclass="math inline">\(2\)</span> 操作，我们要用到的是 <spanclass="math inline">\(SS\)</span>。那么，我们为什么不选择一个中间商<del>赚个差价</del>方便我们对两边都能维护到呢？</p><p>因此，我们可以维护前缀和数组 <spanclass="math inline">\(S\)</span>，对于操作 <spanclass="math inline">\(2\)</span>，答案即是从 <spanclass="math inline">\(1\)</span> 开始的区间和。对于操作 <spanclass="math inline">\(1\)</span>，我们只需要让从当前位置开始到 <spanclass="math inline">\(n\)</span> 的区间加上 <spanclass="math inline">\(v\)</span> 即可。</p><h2 id="区间加等差数列">区间加等差数列</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 l r d k</code>：令区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素 <spanclass="math inline">\(a_i\)</span> 加上以 <spanclass="math inline">\(d\)</span> 为首项、<spanclass="math inline">\(k\)</span> 为公差的等差数列 <spanclass="math inline">\(\{c\}\)</span> 的 <spanclass="math inline">\(c_i\)</span>。 <code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。 <spanclass="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>区间加的数不是同一个数，怎么办？</p><p>考虑一下等差数列的性质。我们没有必要知道每一个数是什么，我们只需要知道首项和公差，就可以推出数列的任意一项以及数列的和。那我们不妨用线段树维护加的等差数列的首项和公差。</p><h2 id="维护区间最大子段和">维护区间最大子段和</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：</p><p><code>1 x v</code>：将 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>；</p><p><code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 内的最大子段和。</p><p><span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这咋做？</p><p>线段树保证复杂度的关键一步是要保证可以快速、正确地合并。这题单点修改是容易的，关键在于如何让信息快速合并。</p><p>我们思考一下合并区间最大子段和时，可能有哪些情况：</p><ol type="1"><li>全部在左半区间。</li><li>全部在右半区间。</li><li>横跨左右区间。</li></ol><p>我们显然是要维护当前区间的最大子段和的。对于 <spanclass="math inline">\(1\)</span> 情况和 <spanclass="math inline">\(2\)</span> 情况，直接合并就可以了。关键是 <spanclass="math inline">\(3\)</span> 情况该如何合并。</p><p>我们考虑横跨左右区间实际上就是左半区间右端点开始的区间最大子段和，和右半区间左端点开始的区间最大子段和合并。那我们不妨对每个节点多维护两个信息：以右端点开始的区间最大子段和（记作<spanclass="math inline">\(S[k]_r\)</span>），和以左端点开始的区间最大子段和（记作<spanclass="math inline">\(S[k]_l\)</span>）。这样，我们就可以做到快速算出区间最大子段和了。</p><p>不过问题在于，我们新维护的这两个值也需要考虑合并之后该怎么办。只考虑<span class="math inline">\(S[k]_l\)</span>，这个时候有两种情况：</p><ol type="1"><li><span class="math inline">\(S[k]_l\)</span> 是 <spanclass="math inline">\(S[ls(k)]_l\)</span>。</li><li><span class="math inline">\(S[k]_l\)</span>的右端点跨到了右区间，答案变成 <spanclass="math inline">\(sum_k+S[rs]_l\)</span>。</li></ol><p>而且只有这两种情况。（思考一下，为什么？）</p><p>现在所有问题已经解决，我们就可以快速维护了。</p><p>思考：<span class="math inline">\(1\)</span>操作改为区间加怎么做？</p><h1 id="信息的本质">信息的本质</h1><p>我们发现，线段树可以维护许多东西：区间和、区间极值……通过一些手法，我们也可以维护诸如区间最大子段和的东西。</p><p>那么，究竟什么样的信息才可以被维护呢？</p><p>首先，这个信息必须是<strong>可被快速合并的</strong>。其次，这个信息必须<strong>满足结合律</strong>。因为我们在合并的时候其实是并不关心信息之间的顺序的，这就要求其必须满足结合律。那么可以看出，这些信息实际上构成了一个半群。</p><p>以上情况都是在单点修改的时候。那么区间修改呢？为什么刚刚线段树维护区间最大子段和没办法区间修改呢？</p><p>在区间修改的时候，为了保证线段树复杂度的正确性，我们势必要引入标记。那么，这个标记也必须满足一定的性质。</p><p>首先，这个标记必须是<strong>可被快速合并的</strong>。其次，这个标记必须<strong>满足结合律</strong>。第三，这个标记必须<strong>可被快速作用到信息上</strong>。可以看出，标记实际上构成了一个幺半群。</p><p>因此，我们在考虑线段树维护某些东西的时候，一方面要考虑如何维护信息，另一方面要考虑如何维护标记。</p><p>有关更多这部分的内容，可以看<a class="link"  href="https://_rqy.blog.uoj.ac/blog/8105" >_rqy的博客</a>。</p><h1 id="线段树的本质">线段树的本质</h1><p>不同的人对线段树有不同的理解，这里分享一些我的个人看法。</p><p>所谓线段树，实际上是针对原来的序列，递归地建立新结点，维护若干个原来节点的信息，当询问时，我们就可以直接采用某些节点的信息，以达到快速查询的目的。</p><p>照这么说，我们其实还可以写出 <span class="math inline">\(3\)</span>叉线段树、<span class="math inline">\(4\)</span> 叉线段树、<spanclass="math inline">\(\sqrt{n}\)</span> 叉线段树……</p><p><span class="math inline">\(\sqrt{n}\)</span> 叉？分块？</p><p>很相类似。狭义上的数据结构本质上都是对序列进行划分，线段树是划分为<span class="math inline">\(O(\log n)\)</span> 个区间，分块则是分成<span class="math inline">\(O(\sqrt{n})\)</span> 个区间。</p><p>不过线段树和分块仍有一些本质上的区别：线段树对于数据，更倾向形成一种树状结构，而分块更倾向于形成线性结构。</p><h1 id="线段树的常用技巧">线段树的常用技巧</h1><h2 id="动态开点">动态开点</h2><p>有的时候，面对庞大的数据范围，我们没办法开如此大的空间。这个时候，我们就需要动态开点线段树了。</p><p>动态开点线段树，顾名思义，即对于整颗线段树，我们并不将它直接建出来，而是到用到某个节点了在进行新建。</p><p>因此，我们就直接不建树，在 update 和 query的时候，如果当前没有节点，那么我们就新建一个。</p><p>不过，显然此时我们再沿用之前 <span class="math inline">\(2k\)</span>为左儿子编号，<span class="math inline">\(2k+1\)</span>为右儿子编号的做法不再合适。我们需要额外记录当前节点左右儿子的编号。</p><p>考虑到一次操作最多会访问 <span class="math inline">\(O(\logn)\)</span> 个节点，那么总空间复杂度为 <spanclass="math inline">\(O(q\log n)\)</span>。</p><p>考虑到一颗线段树的节点数是 <spanclass="math inline">\(2n-1\)</span>，因此动态开点时只需开 <spanclass="math inline">\(2\)</span> 倍空间即可。</p><p>因此我们只需要对应更改一下 pushdown 和 update 的代码即可。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg_Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum, tag;</span><br><span class="line">    <span class="type">int</span> lson, rson;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    tr[k].tag += v;</span><br><span class="line">    tr[k].sum += v * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f</span>(ls, l, mid, tr[k].tag);</span><br><span class="line">    <span class="built_in">f</span>(rs, mid + <span class="number">1</span>, r, tr[k].tag);</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f</span>(k, l, r, v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid+ <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们初始时需要建立第一个节点。值得注意的是：update 和 f 函数中的<span class="math inline">\(k\)</span>必须加取地址符，这是为了使儿子信息在父亲节点中被更新。</p><h2 id="标记永久化">标记永久化</h2><p>当数据范围较大、或者 pushdown、pushup代价过高时，可以考虑标记永久化。</p><p>我们知道线段树一个重要的部分是懒标记，而 pushdown就是为了下放标记而存在的。而标记永久化则是不进行标记的下放，直接永久记录在该节点上。当我们需要访问某节点时，叠加所有在它到根节点路径的标记即可。</p><p>然而值得注意的是，并不是所有的标记都能永久化。除了要满足标记本身需要满足的条件之外，还需要满足<strong>交换律</strong>。</p><p>标记永久化并没有时空复杂度的提升，但是可以优化时间常数。某些情况下，标记下放可能会比较麻烦，这时使用标记永久化不失为一个好的选择。</p><p>标记永久化可以保证了当前节点子树的更新，但是与之相对的，当前节点到根我们需要额外维护：从根到该节点，每次取当前节点维护区间与修改区间的交集，进行更新。</p><p>下面是动态开点+标记永久化的代码：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].tag += v);</span><br><span class="line">    tr[k].sum += v * (<span class="built_in">min</span>(R, r) - <span class="built_in">max</span>(L, l) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[k].sum +(r - l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    <span class="type">int</span> res = (<span class="built_in">min</span>(R, r) - <span class="built_in">max</span>(L, l) + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res += <span class="built_in">query</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res += <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r , L, R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="线段树二分">线段树二分</h2><p>线段树本身看起来就是个很二分的结构。那么我们不妨直接利用这个结构特性来进行二分。</p><p>类比于我们在线段树基本操作中的单点修改，我们发现这个其实就是一个不断二分的过程。</p><p>这样的时间复杂度可以维持在 <span class="math inline">\(O(\logn)\)</span>。</p><h1 id="进阶线段树">进阶线段树</h1><h2 id="值域线段树">值域线段树</h2><p>还是先来看一个问题：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次询问。</p><p>每次询问给定 <span class="math inline">\(k\)</span>，求序列第 <spanclass="math inline">\(k\)</span> 小。</p><p><span class="math inline">\(1\leq n,q\leq 10^5,1\leq a_i\leq10^9\)</span>。</p></blockquote><p>想要解决这个问题，我们需要用到“值域线段树”。</p><p>值域线段树，也被称作“权值线段树”，但是值域线段树这个名字更加严谨一点。</p><p>佛说：诞生了数组之后，就诞生了桶。同样，诞生了线段树之后，就诞生了值域线段树。</p><p>具体来说，值域线段树也是一种线段树，但是它维护的范围从 <spanclass="math inline">\(n\)</span> 变成了整个值域（因此需要<ahref="#动态开点">动态开点</a>），而维护的东西则是一段区间内数的出现次数。形象化地说，就是在桶上建立了一颗线段树。</p><p>那么想想如何查询第 <span class="math inline">\(k\)</span>小。通过刚才线段树二分的思想，我们每次将当前节点左右儿子的值与 <spanclass="math inline">\(k\)</span>比较，然后二分地寻找应该存在的地方。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.luogu.com.cn/upload/image_hosting/zzzzpqlt.png"                     alt="值域线段树"                 ><figcaption aria-hidden="true">值域线段树</figcaption></figure><p>如图，对于序列 <spanclass="math inline">\(\{1,2,3,4,2,3,4,3,4,4\}\)</span>，我们可以建立如上值域线段树。例如我们现在要查询<spanclass="math inline">\(k=5\)</span>，红色的节点和边就是我们查询的路径。值得注意的是，我们的<span class="math inline">\(k\)</span> 应该是在当前节点区间内的 <spanclass="math inline">\(k\)</span>，这意味着如果我们递归到了右子树，需要减去左子树的值。</p><p>类似地，值域线段树也支持单点修改，以及查询某个数出现个数等等。</p><p>注意到，普通值域线段树只支持全局查询。若需要区间查询，则需要对值域线段树进行可持久化，即<ahref="#主席树">主席树</a>。</p><h2 id="扫描线">扫描线</h2><p>具体来说，扫描线是一种思想，而不是一种数据结构。</p><p>扫描线比较经典的问题就是求矩形面积并了。</p><blockquote><p>给定若干四边平行于坐标轴的矩形。</p><p>求它们的面积并（重合部分只算一次）。</p><p><span class="math inline">\(n\leq 10^5,|x_i|,|y_i|\leq10^9\)</span>。</p></blockquote><h3 id="线段树维护矩形面积并">线段树维护矩形面积并</h3><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/08/31/qVf7EtHWwBbjXo2.gif"                     alt="扫描线"                 ><figcaption aria-hidden="true">扫描线</figcaption></figure><p>如上图所示，我们将蓝绿两个矩形通过虚线分割成了三块。显然，答案应该是三段的线段长度<span class="math inline">\(len\)</span> 分别乘上这段竖着的长度之和<span class="math inline">\(sum\)</span>。</p><p>前者我们已经知道了，我们只需要快速维护后者即可。可以用线段树维护。</p><p>具体来说，我们通过一根红色的“扫描线”从下向上扫。记矩形的下边界为<span class="math inline">\(+1\)</span>，上边界为 <spanclass="math inline">\(-1\)</span>，同时维护 <spanclass="math inline">\(sum\)</span> 即可。</p><p>由于范围很大，因此需要离散化。如果你不想离散化，还可以使用动态开点+标记永久化，代码会更短。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].tag) tr[k].sum = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> tr[k].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].tag += v, <span class="built_in">pushup</span>(k, l, r));</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="本质">本质</h3><p>我们来思考一下扫描线的本质：考虑一下我们刚才引入的这条“扫描线”在干什么？在枚举。而我们为了达到同时枚举<span class="math inline">\(x,y\)</span> 的目的，在扫描 <spanclass="math inline">\(y\)</span> 的同时，快速更新 <spanclass="math inline">\(x\)</span> 的贡献。这就是扫描线思想。</p><p>也就是说，对于 <span class="math inline">\((x,y)\)</span>的枚举，我们可以枚举其中一维，并同时通过数据结构快速维护另一维，以求出答案。</p><h2 id="李超线段树">李超线段树</h2><blockquote><p>要求在平面直角坐标系下维护两个操作：</p><ol type="1"><li><p>在平面上加入一条线段。记第 <span class="math inline">\(i\)</span>条被插入的线段的标号为 <span class="math inline">\(i\)</span>；</p></li><li><p>给定一个数 <span class="math inline">\(k\)</span>，询问与直线<span class="math inline">\(x = k\)</span>相交的线段中，交点纵坐标最大的线段的最小编号。</p></li></ol><p>强制在线。<span class="math inline">\(n\leq 10^5\)</span>。</p></blockquote><p>这个问题普通线段树无法解决，这个时候，李超线段树就派上用场了。李超树由浙江学军中学的李超发明，用于维护这样一类普通线段树无法维护的问题。</p><p>李超线段树维护 <span class="math inline">\(x=mid\)</span>时最大的线段信息。记我们现在的最优线段为 <spanclass="math inline">\(l\)</span>，新加入的线段（完全覆盖此区间）为 <spanclass="math inline">\(l&#39;\)</span>。那么，我们将 <spanclass="math inline">\(l\)</span> 与 <spanclass="math inline">\(l&#39;\)</span> 比较，若 <spanclass="math inline">\(l&#39;\)</span> 在 <spanclass="math inline">\(mid\)</span> 处更优，则交换 <spanclass="math inline">\(l\)</span> 与 <spanclass="math inline">\(l&#39;\)</span>。</p><p>接下来，对于 <span class="math inline">\(l&#39;\)</span> 在 <spanclass="math inline">\(mid\)</span> 处不比 <spanclass="math inline">\(l\)</span> 优的情况，有下列几种：</p><ol type="1"><li>在左端点 <span class="math inline">\(l&#39;\)</span> 优于 <spanclass="math inline">\(l\)</span>，则一定在左区间中产生交点，递归左子树。</li><li>在右端点 <span class="math inline">\(l&#39;\)</span> 优于 <spanclass="math inline">\(l\)</span>，则一定在右区间中产生交点，递归右子树。</li><li>在左右端点均不优，则不需要修改。</li></ol><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/01/guCdZAKXMOS3ahG.png"                     alt="李超线段树"                 ><figcaption aria-hidden="true">李超线段树</figcaption></figure><p>如上图，蓝线是我们的原来最优线段 <spanclass="math inline">\(l\)</span>，红线、绿线、紫线依次表示三种情况。</p><p>以红线为例：在 <span class="math inline">\(L\)</span> 时，<spanclass="math inline">\(l&#39;_L&gt;l_L\)</span>，说明 <spanclass="math inline">\(l\)</span> 和 <spanclass="math inline">\(l&#39;\)</span> 一定在 <spanclass="math inline">\([L,mid]\)</span> 有交点，那么我们就递归 <spanclass="math inline">\([L,mid]\)</span> 的区间。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x - y &gt; eps) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y - x &gt; eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> dis)</span></span>&#123;<span class="keyword">return</span> a[k].b + a[k].k * dis;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;v = tr[k], mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> xmid = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, mid), <span class="built_in">calc</span>(v, mid));</span><br><span class="line">    <span class="keyword">if</span>(xmid == <span class="number">1</span> || (!xmid &amp;&amp; u &lt; v)) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="type">int</span> xl = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, l), <span class="built_in">calc</span>(v, l)), xr = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, r), <span class="built_in">calc</span>(v, r));</span><br><span class="line">    <span class="keyword">if</span>(xl == <span class="number">1</span> || (!xl &amp;&amp; u &lt; v)) <span class="built_in">modify</span>(ls, l, mid, u);</span><br><span class="line">    <span class="keyword">if</span>(xr == <span class="number">1</span> || (!xr &amp;&amp; u &lt; v)) <span class="built_in">modify</span>(rs, mid + <span class="number">1</span>, r, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)<span class="built_in">modify</span>(k, l, r, u);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R, u);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查询 <span class="math inline">\(x\)</span> 时，从根节点走到 <spanclass="math inline">\([x,x]\)</span> 的所有最优线段在 <spanclass="math inline">\(x\)</span>处的极值即为答案，类似于标记永久化。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pdi <span class="title">pmax</span><span class="params">(pdi x, pdi y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.fi, y.fi) == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.fi, y.fi) == <span class="number">-1</span>) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.se &lt; y.se ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pdi <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; x || x &gt; r) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> res = <span class="built_in">calc</span>(tr[k], x);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> &#123;res, tr[k]&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pmax</span>(&#123;res, tr[k]&#125;, <span class="built_in">pmax</span>(<span class="built_in">query</span>(ls, l, mid, x), <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, x)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="zkw-线段树">zkw 线段树</h2><p>zkw线段树，即非递归式线段树，由张昆玮发明的一种更加快速、方便、易写的线段树。</p><h3 id="结构-1">结构</h3><p>我们将线段树开成<strong>满二叉树</strong>。容易发现这样一些性质：</p><ol type="1"><li>记当前节点编号为 <spanclass="math inline">\(k\)</span>，则左儿子编号为 <spanclass="math inline">\(k&lt;&lt;1\)</span>，右儿子编号为 <spanclass="math inline">\(k&lt;&lt;1|1\)</span>。反之，父亲节点编号为 <spanclass="math inline">\(k&gt;&gt;1\)</span>。</li><li>前 <span class="math inline">\(n\)</span> 层节点数为 <spanclass="math inline">\(2^n-1\)</span>，第 <spanclass="math inline">\(n\)</span> 层节点数为 <spanclass="math inline">\(2^{n-1}\)</span>。</li><li>叶子是一段连续的编号，且与原序列可一一对应。</li></ol><p>一反之前线段树自上向下递归的方式，zkw线段树一般采用从叶子向根节点的非递归方式。</p><h3 id="建树-1">建树</h3><p>根据刚才的性质，我们只需要把原序列填到这段叶子序列上即可。第一个叶子节点的编号可以<span class="math inline">\(O(\log n)\)</span> 地求出。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(N = <span class="number">1</span>; N &lt;= n + <span class="number">1</span>; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tr[N + i] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) tr[i] = tr[i &lt;&lt; <span class="number">1</span>] + tr[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中，<span class="math inline">\(N\)</span> 为非叶子结点的个数。</p><h3 id="单点修改区间查询">单点修改、区间查询</h3><p>很简单，我们只需要找到对应的叶子节点，一路走到根节点修改即可。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(k += N; k; k &gt;&gt;= <span class="number">1</span>) tr[k] += v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>实际代码写起来只有一行，非常简短。</p><p>接下来思考区间查询。从叶子节点向上，我们怎么实现区间查询呢？</p><p>这里有一个非常巧妙的思想：从我们当前要查询的叶子区间的左右两个节点分别记一个<span class="math inline">\(l,r\)</span>值，然后不断向父亲节点跳，直到其父亲节点为同一个点为止。</p><p>在跳的过程中，若 <span class="math inline">\(l\)</span>为左儿子，则计算右儿子的贡献；若 <span class="math inline">\(r\)</span>为右儿子，则记录左儿子的贡献。</p><p>简单证明一下这么做的正确性：</p><p>会被计算贡献的只有 <span class="math inline">\((l,r)\)</span>的部分。在向上跳的过程中，<span class="math inline">\((l,r)\)</span>间显然不会出现不被计算的情况。<span class="math inline">\(l\)</span>若为左儿子，则其兄弟节点一定在 <spanclass="math inline">\((l,r)\)</span>中，否则其右侧的点一定会被上一层计算到。而线段树需要计算的节点显然只会在最两边，因此这样计算是正确的。</p><p>那么我们可以写出如下代码：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = N + l - <span class="number">1</span>, r = N + r + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(~l &amp; <span class="number">1</span>) ans += tr[l ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(r &amp; <span class="number">1</span>) ans += tr[r ^ <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中用到的位运算：</p><ol type="1"><li><code>l ^ r ^ 1</code>：若 <span class="math inline">\(l,r\)</span>互为兄弟，则一定为 <span class="math inline">\(2k\)</span> 与 <spanclass="math inline">\(2k+1\)</span>，其异或值 <spanclass="math inline">\(1\)</span>。</li><li><code>l &gt;&gt;= 1</code>：跳父节点。<code>r &gt;&gt;= 1</code>同理。</li><li><code>~l &amp; 1</code>：若 <span class="math inline">\(l\)</span>为左儿子，则末尾为 <span class="math inline">\(0\)</span>，否则为 <spanclass="math inline">\(1\)</span>，将末尾取反后再按位与 <spanclass="math inline">\(1\)</span>即可判断是否为左儿子。<code>r &amp; 1</code> 同理。</li></ol><h3 id="区间修改区间查询">区间修改、区间查询</h3><p>区间修改，就势必要打标记。如果我们不能下放标记，那该怎么办呢？</p><p><a href="#标记永久化">标记永久化</a>！</p><p>因此区间修改、区间查询的代码可以这么写：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> numl = <span class="number">0</span>, numr = <span class="number">0</span>, num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = N + l - <span class="number">1</span>, r = N + r + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, num &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[l] += v * numl, tr[r] += v * numr;</span><br><span class="line">        <span class="keyword">if</span>(~l &amp; <span class="number">1</span>) tag[l ^ <span class="number">1</span>] += v, tr[l ^ <span class="number">1</span>] += v * num, numl += num;</span><br><span class="line">        <span class="keyword">if</span>(r &amp; <span class="number">1</span>) tag[r ^ <span class="number">1</span>] += v, tr[r ^ <span class="number">1</span>] += v * num, numr += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; l; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) tr[l] += v * numl, tr[r] += v * numr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> numl = <span class="number">0</span>, numr = <span class="number">0</span>, num = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = N + l - <span class="number">1</span>, r = N + r + <span class="number">1</span>; l ^ r ^ <span class="number">1</span>; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>, num &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[l]) ans += tag[l] * numl;</span><br><span class="line">        <span class="keyword">if</span>(tag[r]) ans += tag[r] * numr;</span><br><span class="line">        <span class="keyword">if</span>(~l &amp; <span class="number">1</span>) ans += tr[l ^ <span class="number">1</span>], numl += num;</span><br><span class="line">        <span class="keyword">if</span>(r &amp; <span class="number">1</span>) ans += tr[r ^ <span class="number">1</span>], numr += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; l; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) ans += tag[l] * numl, ans += tag[r] * numr;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="吉司机线段树">吉司机线段树</h2><p>不会。</p><h1 id="多线段树操作">多线段树操作</h1><h2 id="线段树合并">线段树合并</h2><p>线段树合并，顾名思义，将两颗线段树合并为一颗新的线段树。</p><p>线段树合并其实极为暴力。一般来说，对于两颗动态开点的值域线段树，我们可以从<span class="math inline">\(1\)</span>开始递归合并。若当前节点一颗为空，另一颗不为空，则直接返回不为空的节点。若递归到叶子节点，直接合并。最后更新即可。</p><p>时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p><p>例如，对于将两颗值域线段树按加法合并，可以这么写：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(k) tr[k].lson</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(k) tr[k].rson</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b) <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[a].val += t[b].val;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ls</span>(a) = <span class="built_in">merge</span>(<span class="built_in">ls</span>(a), <span class="built_in">ls</span>(b), l, mid);</span><br><span class="line">    <span class="built_in">rs</span>(a) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(a), <span class="built_in">rs</span>(b), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当然，你也可以选择新开一颗线段树合并进去。优点是不会破坏原来线段树的结构，缺点是需要较大的空间。</p><h2 id="线段树分裂">线段树分裂</h2><p>线段树分裂是线段树合并的逆操作。</p><p>类似于 FHQ-Treap。先挖个坑。</p><h1 id="主席树">主席树</h1><h2 id="简介">简介</h2><p>主席树，全称可持久化值域线段树，因其发明者黄嘉泰名字首字母与某位历史上的主席相同，因此称为主席树。</p><p>主席树一般用于解决<strong>静态</strong>区间第 <spanclass="math inline">\(k\)</span> 小问题。</p><h2 id="结构-2">结构</h2><p>如果是全局第 <span class="math inline">\(k\)</span>小问题，那么我们显然可以用<a href="#值域线段树">值域线段树</a>完成。</p><p>值域线段树维护的是区间内数字出现次数。这个是一个可减信息。那么运用前缀和的思想，我们分别建立出维护区间<span class="math inline">\([1,i]\)</span> 的值域线段树 <spanclass="math inline">\(T_i\)</span>，最后将查询到的信息相减不就好了？</p><p>等等。一颗线段树的空间复杂度就是 <span class="math inline">\(O(n\logn)\)</span> 的了，建 <span class="math inline">\(n\)</span>颗岂不是炸飞了？</p><p>我们考虑能否在建立 <span class="math inline">\(T_i\)</span>的时候充分利用 <span class="math inline">\(T_{i-1}\)</span> 的信息。由于<span class="math inline">\(T_{i-1}\rightarrow T_i\)</span>实际上相当于单点修改，因此我们只会影响到 <spanclass="math inline">\(O(\log n)\)</span> 个节点，只需要把这 <spanclass="math inline">\(O(\log n)\)</span> 个节点多开出来就可以了。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/01/3XampzrlZA4jKqN.jpg"                     alt="主席树"                 ><figcaption aria-hidden="true">主席树</figcaption></figure><p>过于抽象？来看张图。</p><p>在这张图中，黑色节点与蓝色节点共同构成了 <spanclass="math inline">\(T_{i-1}\)</span>，黑色节点与红色节点共同构成了<spanclass="math inline">\(T_i\)</span>。一条红色箭头代表了该蓝色节点被影响后，重建出来的红色节点。如果我们忽视所有的虚线，那么得到的就是新线段树。</p><p>如果你的空间想象能力足够强大，那么你可以这么理解：线段树通常被画为二维平面的图像。而不同的版本意味着我们再引入一条垂直于平面的坐标轴“版本轴”，或者“时间轴”。对于影响到的节点，我们直接在新的版本平面内建立出来，而对于还可以利用的节点，我们连接向上一个版本平面的节点。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/01/1WbXFMpIDqfTS47.png"                     alt="立体主席树1"                 ><figcaption aria-hidden="true">立体主席树1</figcaption></figure><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/01/8TLzMn56NGHDpa9.png"                     alt="立体主席树2"                 ><figcaption aria-hidden="true">立体主席树2</figcaption></figure><h2 id="操作">操作</h2><p>查询的时候，我们在两颗线段树上分别查询就可以了，这个没有太大的问题。同样，单点修改也没有太大的问题。</p><p>那么，我们可以写出如下代码；</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lson, rson;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt[MAXN &lt;&lt; <span class="number">5</span>], cnt; <span class="comment">//rt 表示每个版本的根</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(k), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(k), mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nk = ++cnt;</span><br><span class="line">    tr[nk] = tr[k], tr[nk].val++; <span class="comment">//建立新的节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> nk;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= mid) <span class="built_in">ls</span>(nk) = <span class="built_in">update</span>(<span class="built_in">ls</span>(nk), l, mid, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">rs</span>(nk) = <span class="built_in">update</span>(<span class="built_in">rs</span>(nk), mid + <span class="number">1</span>, r, v);</span><br><span class="line">    <span class="keyword">return</span> nk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x,y 分别表示两个版本的根节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = tr[<span class="built_in">ls</span>(y)].val - tr[<span class="built_in">ls</span>(x)].val;</span><br><span class="line">    <span class="keyword">if</span>(num &gt;= v) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(x), <span class="built_in">ls</span>(y), l, mid, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(x), <span class="built_in">rs</span>(y), mid + <span class="number">1</span>, r, v - num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="区间修改">区间修改</h2><p>对于一颗普通的可持久化线段树，如果我们要区间修改，貌似还有些麻烦。</p><p>保证线段树复杂度正确性的一个重要部分是懒惰标记 <spanclass="math inline">\(tag\)</span>。但是当一个节点被多个版本的父亲公用，就出现了问题：如果我们直接将标记打到儿子节点，那么多个版本就会受到影响，正确性是错的。</p><p>面对这种问题，一般有两种方法：</p><p>第一种：在 pushdown的时候，如果要下放的节点不在当前版本，那就在当前版本新建节点。由于每次至多新建两个节点，因此时间复杂度仍然是<span class="math inline">\(O(\log n)\)</span>；</p><p>第二种：运用标记永久化的思想，不进行标记下放。</p><p>一般来说，第二种更加方便、好写，但也有部分无法处理的情况。如果使用第一种方法，则update 和 query 时都要 pushdown 新建节点。</p><p>至此，线段树基本内容已经处理完毕。</p><h1 id="题目随解">题目随解</h1><h2 id="k-maximum-subsequence-sum">k-Maximum Subsequence Sum</h2><p><a class="link"   href="https://codeforces.com/contest/280/problem/D" >CF280Dk-Maximum Subsequence Sum</a></p><blockquote><p>在给定序列 <span class="math inline">\(\{a_n\}\)</span> 中选取不超过<span class="math inline">\(k\)</span> 段不相交的区间 <spanclass="math inline">\([l_i, r_i](l_i\leq r_i)\)</span>，使 <spanclass="math inline">\(\sum\limits_{i=1}^{k}\sum\limits_{j=l_i}^{r_i}a_{j}\)</span>最大。</p><p>需要支持单点覆盖。</p><p><span class="math inline">\(1\leq n,q\leq 10^5,k\leq20\)</span>。</p></blockquote><p>当 <span class="math inline">\(k=1\)</span>时，题目变为区间最大子段和。这个问题我们在<ahref="#维护区间最大子段和">上面</a>已经学过。</p><p>那么 <span class="math inline">\(k&gt;1\)</span>的时候呢？考虑一个贪心：每次选取当前最大子段和，并将其 <spanclass="math inline">\(\times -1\)</span>，重复 <spanclass="math inline">\(k\)</span> 次，然后取 <spanclass="math inline">\(1\sim k\)</span> 中的最大值。</p><p>这个贪心的正确性可以用费用流证明：<spanclass="math inline">\(S\rightarrow i,i\rightarrow T\)</span>连一条流量为 <span class="math inline">\(1\)</span>，费用为 <spanclass="math inline">\(0\)</span> 的边，<spanclass="math inline">\(i\rightarrow i+1\)</span> 连一条流量为 <spanclass="math inline">\(1\)</span>，费用为 <spanclass="math inline">\(a_i\)</span> 的边。那么一条 <spanclass="math inline">\(S\rightarrow i\rightarrow j \rightarrow T\)</span>的流表示选择了 <spanclass="math inline">\([i,j-1]\)</span>。之后引入反流，每次将前一项 <spanclass="math inline">\(\times -1\)</span>，新区间 <spanclass="math inline">\([l,r]\)</span> 与旧区间 <spanclass="math inline">\([x,y]\)</span> 若有交集，则说明 <spanclass="math inline">\([x,y]\)</span> 有一部分被反悔。显然，<spanclass="math inline">\([l,r]\)</span> 与 <spanclass="math inline">\([x,y]\)</span> 不可能存在包含关系。因此 <spanclass="math inline">\(k\)</span> 轮增广之后，我们就得到了答案。</p><p>考虑要维护什么：区间最大子段和的必须品区间和 <spanclass="math inline">\(sum\)</span>，左端点开始的最大子段和 <spanclass="math inline">\(lft\)</span>，右端点开始的最大子段和 <spanclass="math inline">\(rgt\)</span>，区间最大子段和最 <spanclass="math inline">\(ans\)</span>。由于要取反，我们还要维护一个左端点开始的最小子段和，右端点开始的最小子段和，区间最小子段和。可以分别用两个结构体封装，方便以后的操作。由于我们要记录反转哪里，所以还需要分别维护最大最小的子段和左端点<span class="math inline">\(ansl\)</span>、右端点 <spanclass="math inline">\(ansr\)</span>，左端点开始的子段和右端点 <spanclass="math inline">\(lftr\)</span>，右端点开始的子段和左端点 <spanclass="math inline">\(rgtl\)</span>，以及一个翻转标记 <spanclass="math inline">\(tag\)</span>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sub</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ans, lft, rgt;</span><br><span class="line">    <span class="type">int</span> ansl, ansr, lftr, rgtl;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span></span>&#123;ans = lft = rgt = x; <span class="keyword">if</span>(i != <span class="number">-1</span>) ansl = ansr = lftr = rgtl = i;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mul_1</span><span class="params">()</span></span>&#123;ans *= <span class="number">-1</span>, lft *= <span class="number">-1</span>, rgt *= <span class="number">-1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    sub big, sml;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">    <span class="comment">//以上为区间和</span></span><br><span class="line">    <span class="keyword">if</span>(tr[ls].big.ans &gt; tr[rs].big.ans) tr[k].big.ans = tr[ls].big.ans, tr[k].big.ansl = tr[ls].big.ansl, tr[k].big.ansr = tr[ls].big.ansr;</span><br><span class="line">    <span class="keyword">else</span> tr[k].big.ans = tr[rs].big.ans, tr[k].big.ansl = tr[rs].big.ansl, tr[k].big.ansr = tr[rs].big.ansr;</span><br><span class="line">    <span class="keyword">if</span>(tr[ls].big.rgt + tr[rs].big.lft &gt; tr[k].big.ans) tr[k].big.ans = tr[ls].big.rgt + tr[rs].big.lft, tr[k].big.ansl = tr[ls].big.rgtl, tr[k].big.ansr = tr[rs].big.lftr;</span><br><span class="line">    <span class="comment">//以上为区间最大子段和</span></span><br><span class="line">    <span class="keyword">if</span>(tr[ls].sum + tr[rs].big.lft &gt; tr[ls].big.lft) tr[k].big.lft = tr[ls].sum + tr[rs].big.lft, tr[k].big.lftr = tr[rs].big.lftr;</span><br><span class="line">    <span class="keyword">else</span> tr[k].big.lft = tr[ls].big.lft, tr[k].big.lftr = tr[ls].big.lftr;</span><br><span class="line">    <span class="comment">//以上为左端点开始的最大子段和</span></span><br><span class="line">    <span class="keyword">if</span>(tr[rs].sum + tr[ls].big.rgt &gt; tr[rs].big.rgt) tr[k].big.rgt = tr[rs].sum + tr[ls].big.rgt, tr[k].big.rgtl = tr[ls].big.rgtl;</span><br><span class="line">    <span class="keyword">else</span> tr[k].big.rgt = tr[rs].big.rgt, tr[k].big.rgtl = tr[rs].big.rgtl;</span><br><span class="line">    <span class="comment">//以上为右端点开始的最大子段和</span></span><br><span class="line">    <span class="keyword">if</span>(tr[ls].sml.ans &lt; tr[rs].sml.ans) tr[k].sml.ans = tr[ls].sml.ans, tr[k].sml.ansl = tr[ls].sml.ansl, tr[k].sml.ansr = tr[ls].sml.ansr;</span><br><span class="line">    <span class="keyword">else</span> tr[k].sml.ans = tr[rs].sml.ans, tr[k].sml.ansl = tr[rs].sml.ansl, tr[k].sml.ansr = tr[rs].sml.ansr;</span><br><span class="line">    <span class="keyword">if</span>(tr[ls].sml.rgt + tr[rs].sml.lft &lt; tr[k].sml.ans) tr[k].sml.ans = tr[ls].sml.rgt + tr[rs].sml.lft, tr[k].sml.ansl = tr[ls].sml.rgtl, tr[k].sml.ansr = tr[rs].sml.lftr;</span><br><span class="line">    <span class="keyword">if</span>(tr[ls].sum + tr[rs].sml.lft &lt; tr[ls].sml.lft) tr[k].sml.lft = tr[ls].sum + tr[rs].sml.lft, tr[k].sml.lftr = tr[rs].sml.lftr;</span><br><span class="line">    <span class="keyword">else</span> tr[k].sml.lft = tr[ls].sml.lft, tr[k].sml.lftr = tr[ls].sml.lftr;</span><br><span class="line">    <span class="keyword">if</span>(tr[rs].sum + tr[ls].sml.rgt &lt; tr[rs].sml.rgt) tr[k].sml.rgt = tr[rs].sum + tr[ls].sml.rgt, tr[k].sml.rgtl = tr[ls].sml.rgtl;</span><br><span class="line">    <span class="keyword">else</span> tr[k].sml.rgt = tr[rs].sml.rgt, tr[k].sml.rgtl = tr[rs].sml.rgtl;</span><br><span class="line">    <span class="comment">//以上为最小子段和的维护</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(tr[k].big, tr[k].sml);</span><br><span class="line">    tr[k].sum *= <span class="number">-1</span>, tr[k].big.<span class="built_in">mul_1</span>(), tr[k].sml.<span class="built_in">mul_1</span>(), tr[k].tag ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[k].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">f</span>(ls), <span class="built_in">f</span>(rs);</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum = a[l];</span><br><span class="line">        tr[k].big.<span class="built_in">init</span>(a[l], l), tr[k].sml.<span class="built_in">init</span>(a[l], l);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].big.<span class="built_in">init</span>(v, <span class="number">-1</span>), tr[k].sml.<span class="built_in">init</span>(v, <span class="number">-1</span>), tr[k].sum = v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">update</span>(ls, l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f</span>(k);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">change</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">change</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[k];</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Node ll, rr, res;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid &amp;&amp; mid &lt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        ll = <span class="built_in">query</span>(ls, l, mid, L, R), rr = <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">        res.sum = ll.sum + rr.sum;</span><br><span class="line">        <span class="keyword">if</span>(ll.big.ans &gt; rr.big.ans) res.big.ans = ll.big.ans, res.big.ansl = ll.big.ansl, res.big.ansr = ll.big.ansr;</span><br><span class="line">        <span class="keyword">else</span> res.big.ans = rr.big.ans, res.big.ansl = rr.big.ansl, res.big.ansr = rr.big.ansr;</span><br><span class="line">        <span class="keyword">if</span>(ll.big.rgt + rr.big.lft &gt; res.big.ans) res.big.ans = ll.big.rgt + rr.big.lft, res.big.ansl = ll.big.rgtl, res.big.ansr = rr.big.lftr;</span><br><span class="line">        <span class="keyword">if</span>(ll.sum + rr.big.lft &gt; ll.big.lft) res.big.lft = ll.sum + rr.big.lft, res.big.lftr = rr.big.lftr;</span><br><span class="line">        <span class="keyword">else</span> res.big.lft = ll.big.lft, res.big.lftr = ll.big.lftr;    </span><br><span class="line">        <span class="keyword">if</span>(rr.sum + ll.big.rgt &gt; rr.big.rgt) res.big.rgt = rr.sum + ll.big.rgt, res.big.rgtl = ll.big.rgtl;</span><br><span class="line">        <span class="keyword">else</span> res.big.rgt = rr.big.rgt, res.big.rgtl = rr.big.rgtl;</span><br><span class="line">        <span class="keyword">if</span>(ll.sml.ans &lt; rr.sml.ans) res.sml.ans = ll.sml.ans, res.sml.ansl = ll.sml.ansl, res.sml.ansr = ll.sml.ansr;</span><br><span class="line">        <span class="keyword">else</span> res.sml.ans = rr.sml.ans, res.sml.ansl = rr.sml.ansl, res.sml.ansr = rr.sml.ansr;</span><br><span class="line">        <span class="keyword">if</span>(ll.sml.rgt + rr.sml.lft &lt; res.sml.ans) res.sml.ans = ll.sml.rgt + rr.sml.lft, res.sml.ansl = ll.sml.rgtl, res.sml.ansr = rr.sml.lftr;</span><br><span class="line">        <span class="keyword">if</span>(ll.sum + rr.sml.lft &lt; ll.sml.lft) res.sml.lft = ll.sum + rr.sml.lft, res.sml.lftr = rr.sml.lftr;</span><br><span class="line">        <span class="keyword">else</span> res.sml.lft = ll.sml.lft, res.sml.lftr = ll.sml.lftr;</span><br><span class="line">        <span class="keyword">if</span>(rr.sum + ll.sml.rgt &lt; rr.sml.rgt) res.sml.rgt = rr.sum + ll.sml.rgt, res.sml.rgtl = ll.sml.rgtl;</span><br><span class="line">        <span class="keyword">else</span> res.sml.rgt = rr.sml.rgt, res.sml.rgtl = rr.sml.rgtl;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了方便合并，当需要合并的时候我们直接合并，合并方式与 pushup 类似</span></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><p>思考：区间覆盖该怎么办？</p><h2 id="等差子序列">等差子序列</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P2757" >【国家集训队】等差子序列</a></p><blockquote><p>给一个 <span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(N\)</span> 的排列 <spanclass="math inline">\(\{A_i\}\)</span>，询问是否存在</p><p><span class="math display">\[1 \lep_1&lt;p_2&lt;p_3&lt;p_4&lt;p_5&lt;…&lt;p_{Len} \le N (Len \ge3)\]</span></p><p>使得 <spanclass="math inline">\(Ap_1,Ap_2,Ap_3,\cdots,Ap_{Len}\)</span>是一个等差序列。</p><p><span class="math inline">\(1 \leq N \leq 5\times10^5\)</span>，<span class="math inline">\(5s\)</span>。</p></blockquote><p>只需要求出一个长度为 <span class="math inline">\(3\)</span>的等差子序列即可，即找到 <spanclass="math inline">\(i&lt;j&lt;k\)</span>，使得 <spanclass="math inline">\(A_i,A_j,A_k\)</span> 为等差序列。</p><p>一个很显然的套路是枚举中间值，判断是否存在 <spanclass="math inline">\(A_i=A_j-x(i&lt;j)\)</span> 和 <spanclass="math inline">\(A_k=A_j+x(k&gt;j)\)</span> 即可。</p><p>而因为 <span class="math inline">\(\{A_n\}\)</span>是排列，因此这两个数一定存在（合法情况下），且一定位于 <spanclass="math inline">\(A_j\)</span>的左侧或右侧。那我们不妨建立类似于值域线段树的东西，若 <spanclass="math inline">\(A_i\)</span> 在 <spanclass="math inline">\(A_j\)</span> 左侧，则第 <spanclass="math inline">\(A_i\)</span> 叶子节点为 <spanclass="math inline">\(0\)</span>，否则为 <spanclass="math inline">\(1\)</span>。</p><p>显然，对于 <spanclass="math inline">\(A_j\)</span>，想要不存在等差子序列，必须满足 <spanclass="math inline">\(A_{j-x}=A_{j+x}\)</span>。那么对于区间 <spanclass="math inline">\([j-1,1],[j+1,n]\)</span>，两者必须完全相同。（这里的<span class="math inline">\([j-1,1]\)</span> 表示序列 <spanclass="math inline">\(A_{j-1},A_{j-2}\cdots A_1\)</span>）</p><p>怎么维护是否相同呢？字符串哈希！</p><p>线段树维护 <span class="math inline">\([l,r]\)</span>的哈希值即可！对于不同的 <spanclass="math inline">\(j\)</span>，由于只会影响到至多两个点，因此单点修改即可。</p><p><del>（但是这题我写的树状数组，就不放代码了。）</del></p><h2 id="双面棋盘">双面棋盘</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P4121" >【WC2005】双面棋盘</a></p><blockquote><p>给定 <span class="math inline">\(n\times n\)</span> 的 <spanclass="math inline">\(01\)</span> 四连通矩阵（即，上下左右）。</p><p>每次取反一个数，求 <span class="math inline">\(0\)</span>、<spanclass="math inline">\(1\)</span> 连通块分别的数量。</p><p><span class="math inline">\(1\leq n\leq 200,1\leq q\leq10^4\)</span>。</p></blockquote><p>不加修改操作怎么做？并查集即可。</p><p>加上修改操作呢？只需要线段树维护并查集就可以了！</p><p>因此线段树套并查集，线段树节点维护 <spanclass="math inline">\([l,r]\)</span> 行的并查集，合并的时候合并 <spanclass="math inline">\([l,mid]\)</span> 与 <spanclass="math inline">\([mid + 1,r]\)</span>，只需要暴力合并 <spanclass="math inline">\(mid,mid+1\)</span> 即可。</p><p>单次合并用路径压缩+按秩合并并查集，时间复杂度 <spanclass="math inline">\(O(\alpha(n))\)</span>，每次合并操作 <spanclass="math inline">\(O(n\alpha(n))\)</span>，总复杂度 <spanclass="math inline">\(O(qn\alpha(n)\log n)\)</span>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> mp[MAXN][MAXN]; <span class="comment">//0 wt 1 bk</span></span><br><span class="line"><span class="type">int</span> fa[MAXN * MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wt, bk;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> lson[MAXN], rson[MAXN];</span><br><span class="line">&#125;t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x * n + y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].lson[i] = t[ls].lson[i];</span><br><span class="line">        t[k].rson[i] = t[rs].rson[i];</span><br><span class="line">        fa[t[ls].lson[i]] = t[ls].lson[i];</span><br><span class="line">        fa[t[rs].lson[i]] = t[rs].lson[i];</span><br><span class="line">        fa[t[ls].rson[i]] = t[ls].rson[i];</span><br><span class="line">        fa[t[rs].rson[i]] = t[rs].rson[i];</span><br><span class="line">    &#125;</span><br><span class="line">    t[k].bk = t[ls].bk + t[rs].bk;</span><br><span class="line">    t[k].wt = t[ls].wt + t[rs].wt;</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[mid][i] == mp[mid + <span class="number">1</span>][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> L = <span class="built_in">get</span>(t[ls].rson[i]);</span><br><span class="line">            <span class="type">int</span> R = <span class="built_in">get</span>(t[rs].lson[i]);</span><br><span class="line">            <span class="keyword">if</span>(L != R)</span><br><span class="line">            &#123;</span><br><span class="line">                fa[L] = R;</span><br><span class="line">                mp[mid][i] == <span class="number">0</span> ? t[k].wt-- : t[k].bk--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].lson[i] = <span class="built_in">get</span>(t[k].lson[i]);</span><br><span class="line">        t[k].rson[i] = <span class="built_in">get</span>(t[k].rson[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].l = l;</span><br><span class="line">    t[k].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lson[i] = <span class="built_in">id</span>(l, i);</span><br><span class="line">            t[k].rson[i] = <span class="built_in">id</span>(l, i);</span><br><span class="line">            fa[<span class="built_in">id</span>(l, i)] = <span class="built_in">id</span>(l, i);</span><br><span class="line">            mp[l][i] == <span class="number">0</span> ? t[k].wt++ : t[k].bk++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[l][i] == mp[l][i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                t[k].lson[i] = fa[<span class="built_in">id</span>(l, i - <span class="number">1</span>)];</span><br><span class="line">                t[k].rson[i] = fa[<span class="built_in">id</span>(l, i - <span class="number">1</span>)];</span><br><span class="line">                fa[<span class="built_in">id</span>(l, i)] = fa[<span class="built_in">id</span>(l, i - <span class="number">1</span>)];</span><br><span class="line">                mp[l][i] == <span class="number">0</span> ? t[k].wt-- : t[k].bk--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].l == t[k].r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].wt = <span class="number">0</span>;</span><br><span class="line">        t[k].bk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lson[i] = <span class="built_in">id</span>(p, i);</span><br><span class="line">            t[k].rson[i] = <span class="built_in">id</span>(p, i);</span><br><span class="line">            fa[<span class="built_in">id</span>(p, i)] = <span class="built_in">id</span>(p, i);</span><br><span class="line">            mp[p][i] == <span class="number">0</span> ? t[k].wt++ : t[k].bk++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[p][i] == mp[p][i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                t[k].lson[i] = fa[<span class="built_in">id</span>(p, i - <span class="number">1</span>)];</span><br><span class="line">                t[k].rson[i] = fa[<span class="built_in">id</span>(p, i - <span class="number">1</span>)];</span><br><span class="line">                fa[<span class="built_in">id</span>(p, i)] = fa[<span class="built_in">id</span>(p, i - <span class="number">1</span>)];</span><br><span class="line">                mp[p][i] == <span class="number">0</span> ? t[k].wt-- : t[k].bk--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[ls].r &gt;= p) <span class="built_in">update</span>(ls, p);</span><br><span class="line">    <span class="keyword">if</span>(t[rs].l &lt;= p) <span class="built_in">update</span>(rs, p);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><h2 id="决战圆锥曲线">决战圆锥曲线</h2><p><a class="link"   href="https://uoj.ac/problem/119" >【UR #8】决战圆锥曲线</a></p><blockquote><p>给定伪随机序列 <spanclass="math inline">\(\{a_n\}\)</span>，有三种操作：</p><ol type="1"><li><p>给定 <span class="math inline">\(x,v\)</span>，<spanclass="math inline">\(a_x\leftarrow v\)</span>；</p></li><li><p>给定 <span class="math inline">\(l,r\)</span>，<spanclass="math inline">\(\forall a_i\in[l,r],a_i\leftarrow10^5-a_i\)</span>；</p></li><li><p>给定 <span class="math inline">\(l,r,x,y,z\)</span>，求 <spanclass="math inline">\(\max\limits_{i=l}^{r}\{xi+ya_i+zia_i\}\)</span>。</p></li></ol><p><span class="math inline">\(1\leq n\leq 10^5,1\leq q\leq10^6\)</span>，<span class="math inline">\(2s\)</span>。</p></blockquote><p>操作 <span class="math inline">\(1,2\)</span>显然都是好做的，直接搞就可以了。</p><p>而对于操作 <spanclass="math inline">\(3\)</span>，我们可以这么做：因为若 <spanclass="math inline">\(j&lt;i\land a_j&lt;a_i\)</span>，则 <spanclass="math inline">\(j\)</span> 必然不可能被选中。因此选择当前区间中<span class="math inline">\(a_i\)</span> 的最大值，之后查询所有 <spanclass="math inline">\(a_j(j&gt;i)\)</span> 即可。</p><p>分析一下时间复杂度：我们一次查询操作相当于再找上升子段。在随机数据的情况下，最长上升子段的长度期望近似于<span class="math inline">\(O(\log n)\)</span>，<a class="link"  href="https://mathoverflow.net/questions/16817/longest-consecutive-subsequence-of-a-random-permutation" >严格证明可以看这里</a>。那么一次线段树的查询操作就是<span class="math inline">\(O(\log^2 n)\)</span>，总时间复杂度 <spanclass="math inline">\(O(q\log^2n)\)</span></p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minn, maxx;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].maxx = <span class="built_in">max</span>(tr[ls].maxx, tr[rs].maxx);</span><br><span class="line">    tr[k].minn = <span class="built_in">min</span>(tr[ls].minn, tr[rs].minn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].tag ^= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">swap</span>(tr[k].maxx, tr[k].minn);</span><br><span class="line">    tr[k].minn = mod4 - <span class="number">1</span> - tr[k].minn;</span><br><span class="line">    tr[k].maxx = mod4 - <span class="number">1</span> - tr[k].maxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[k].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">f</span>(ls), <span class="built_in">f</span>(rs);</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].maxx = tr[k].minn = a[l]);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].maxx = tr[k].minn = v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">change</span>(ls, l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(rs, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f</span>(k);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((res = x * r + y * tr[k].maxx + z * r * tr[k].maxx) &lt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="type">void</span>)(ans = res);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, L, R, x, y, z);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">query</span>(ls, l, mid, L, R, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><h2 id="rikka-with-phi">Rikka with Phi</h2><p><a class="link"   href="http://acm.hdu.edu.cn/showproblem.php?pid=5634" >HDU5634Rikka with Phi</a></p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，诸如：</p><ol type="1"><li><p>给定 <span class="math inline">\(l,r\)</span>，<spanclass="math inline">\(\forall a_i\in [l,r],a_i\leftarrow\varphi(a_i)\)</span>；</p></li><li><p>给定 <span class="math inline">\(l,r,x\)</span>，<spanclass="math inline">\(\forall a_i\in[l,r],a_i\leftarrowx\)</span>；</p></li><li><p>查询区间和。</p></li></ol><p><span class="math inline">\(1\leq n,q\leq 3\cdot 10^5,1\leq a_i\leq10^7\)</span>。</p></blockquote><p>没有区间覆盖怎么做？</p><p>与区间开根类似。一个数 <span class="math inline">\(n\)</span> 最多被<span class="math inline">\(\varphi\)</span> 过 <spanclass="math inline">\(\log n\)</span> 次之后就会变成 <spanclass="math inline">\(1\)</span>。那么我们暴力更改一个点的时间复杂度是<span class="math inline">\(O(\log^2n)\)</span> 的，总时间复杂度均摊为<span class="math inline">\(O(n\log^2 n)\)</span>。</p><p>那加上区间覆盖操作呢？区间覆盖有一个很重要的性质：经过操作之后，序列会被分成若干块。那么我们不妨维护一下当前区间是否相同，如果相同，求<span class="math inline">\(\varphi\)</span>后还是相同。时间复杂度仍然是均摊的 <spanclass="math inline">\(O(n\log^2n)\)</span>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tree[MAXN &lt;&lt; <span class="number">2</span>], andd[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k] = tree[<span class="built_in">lc</span>(k)] + tree[<span class="built_in">rc</span>(k)];</span><br><span class="line">    <span class="keyword">if</span>(andd[<span class="built_in">lc</span>(k)] == andd[<span class="built_in">rc</span>(k)]) andd[k] = andd[<span class="built_in">lc</span>(k)];</span><br><span class="line">    <span class="keyword">else</span> andd[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(andd[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        andd[<span class="built_in">lc</span>(k)] = andd[<span class="built_in">rc</span>(k)] = andd[k];</span><br><span class="line">        tree[<span class="built_in">lc</span>(k)] = andd[<span class="built_in">lc</span>(k)] * (mid - l + <span class="number">1</span>);</span><br><span class="line">        tree[<span class="built_in">rc</span>(k)] = andd[<span class="built_in">rc</span>(k)] * (r - mid);</span><br><span class="line">        andd[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k] = andd[k] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">lc</span>(k), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt; R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(andd[k] &amp;&amp; l == L &amp;&amp; r == R)</span><br><span class="line">    &#123;</span><br><span class="line">        andd[k] = phi[andd[k]];</span><br><span class="line">        tree[k] = andd[k] * (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(k), l, mid, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">lc</span>(k), l, mid, L, mid);</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update2</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt; R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == L &amp;&amp; r == R)</span><br><span class="line">    &#123;</span><br><span class="line">        andd[k] = v;</span><br><span class="line">        tree[k] = andd[k] * (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="built_in">update2</span>(<span class="built_in">lc</span>(k), l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="built_in">update2</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update2</span>(<span class="built_in">lc</span>(k), l, mid, L, mid, v);</span><br><span class="line">        <span class="built_in">update2</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tree[k];</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(k, l, r);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">lc</span>(k), l ,mid, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">lc</span>(k), l ,mid, L, mid) + <span class="built_in">query</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><p><del>一年前写的代码，好丑。</del></p><h2 id="wall">Wall</h2><p><a class="link"  href="https://www.luogu.com.cn/problem/P4560" >【IOI2014】Wall</a></p><blockquote><p>给定初始全部为 <span class="math inline">\(0\)</span> 的序列 <spanclass="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(k\)</span> 次操作：</p><ol type="1"><li><p>给定 <span class="math inline">\(l,r,h\)</span>，<spanclass="math inline">\(\forall a_i\in [l,r],a_i\leftarrow\min(a_i,h)\)</span>；</p></li><li><p>给定 <span class="math inline">\(l,r,h\)</span>，<spanclass="math inline">\(\forall a_i\in [l,r],a_i\leftarrow\max(a_i,h)\)</span>；</p></li></ol><p><span class="math inline">\(1\leq n\leq 2\cdot 10^6,1\leq k\leq5\cdot 10^5\)</span>。</p></blockquote><p>这题作为一道 IOI 题，感觉有点过于水了。</p><p>我们发现这两个操作实际上相当于划定了某个区间的上界和下界，<spanclass="math inline">\(1\)</span> 操作是对上界的操作，相当于把 <spanclass="math inline">\(h\)</span> 上面的数字都映射到 <spanclass="math inline">\(h\)</span> 上，<spanclass="math inline">\(2\)</span> 操作是对下界的操作。</p><p>既然这样，那么我们不妨维护一个当前区间上下界。合并很好合并，考虑一下如何修改。</p><p>先讨论上界的变动：</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/09/Ck2y8B5967bFaKO.png"                     alt="更改"                 ><figcaption aria-hidden="true">更改</figcaption></figure><p>如图，两条实线是我们目前的上下界，而我们更改的 <spanclass="math inline">\(h\)</span>有三种可能：高于上界（红色虚线）、在上下界间（绿色虚线）、低于下界（粉色虚线<del>（这到底是粉色还是紫色啊）</del> ）。</p><p>第一种情况：高于上界。由于我们现在所有的数都在蓝线之间了，将上界拉高不会产生什么实质性的影响，因此上界不变。</p><p>第二种情况：在上下界间。此时在上蓝线与绿线中间的数字要被映射到绿线上，因此上界被压倒绿色虚线，更改上界。</p><p>第三种情况：低于下界。此时新更新的上界已经比原来的下界还要低了，现在所有的点都要被映射到粉线上，上下界都需要更改到粉线。</p><p>下界的变动也类似，按照上例讨论即可。最后的答案即是下界的值。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxx, minn;</span><br><span class="line">    <span class="type">int</span> mxtg = <span class="number">-1</span>, mntg = <span class="number">-1</span>;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].maxx = <span class="built_in">max</span>(tr[ls].maxx, tr[rs].maxx);</span><br><span class="line">    tr[k].minn = <span class="built_in">min</span>(tr[ls].minn, tr[rs].minn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].minn = <span class="built_in">max</span>(tr[k].minn, v);</span><br><span class="line">    tr[k].maxx = <span class="built_in">max</span>(tr[k].maxx, tr[k].minn); </span><br><span class="line">    tr[k].mxtg = tr[k].maxx;</span><br><span class="line">    tr[k].mntg = tr[k].minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].maxx = <span class="built_in">min</span>(tr[k].maxx, v);</span><br><span class="line">    tr[k].minn = <span class="built_in">min</span>(tr[k].maxx, tr[k].minn); </span><br><span class="line">    tr[k].mxtg = tr[k].maxx;</span><br><span class="line">    tr[k].mntg = tr[k].minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].mntg != <span class="number">-1</span>) <span class="built_in">f1</span>(ls, tr[k].mntg), <span class="built_in">f1</span>(rs, tr[k].mntg), tr[k].mntg = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].mxtg != <span class="number">-1</span>) <span class="built_in">f2</span>(ls, tr[k].mxtg), <span class="built_in">f2</span>(rs, tr[k].mxtg), tr[k].mxtg = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f1</span>(k, v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">add</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">add</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rmv</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">f2</span>(k, v);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">rmv</span>(ls, l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">rmv</span>(rs, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> tr[k].minn;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(ls, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><p>PS：一开始 query 的 <code>if-else</code> 没写<code>return</code>，导致开了 <span class="math inline">\(O2\)</span>就会 RE。死因：有返回值函数不返回是 UB，警钟敲烂。</p><p>PS2：我宣布这个代码的区间修改函数是线段树区间修改函数最美丽的形态！！1</p><h2 id="树状数组">树状数组</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P3688" >【ZJOI2017】树状数组</a></p><blockquote><p>题面很难简述，看原题吧。</p></blockquote><p>首先，题目给的树状数组并不是错误写法，而是一种经典的树状数组应用：将query 和 add 的 lowbit同时写反，原本对前缀的操作就会变成对后缀操作。</p><p>但是 query 函数中，他对于一段区间的操作仍然是 <spanclass="math inline">\(\text{Find}(r)-\text{Find}(l-1)\)</span>，这就导致了我们查询的结果并不是<span class="math inline">\([l,r]\)</span>，而是向左偏移了一位，变成了<span class="math inline">\([l-1,r-1]\)</span>。</p><p>加 <span class="math inline">\(1\)</span> 再取模 <spanclass="math inline">\(2\)</span>的操作相当于布尔型取反，的这意味着我们可以只关心 <spanclass="math inline">\(A_{l-1}\)</span> 和 <spanclass="math inline">\(A_r\)</span> 是否相同即可。</p><p>这里有一个理所当然的误区：我们可能很容易想到维护 <spanclass="math inline">\(B_i\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个数为 <spanclass="math inline">\(1\)</span> 的概率，那么对于一段长度为 <spanclass="math inline">\(len\)</span> 的区间，每个数变成 <spanclass="math inline">\(1\)</span> 的概率就会是 <spanclass="math inline">\(\dfrac{1}{len}\)</span>。但是这时有一个反例：如果对于区间<span class="math inline">\([1,2]\)</span> 执行一次操作，<spanclass="math inline">\(B_1=B_2=\dfrac{1}{2}\)</span>，此时如果暴力计算，<spanclass="math inline">\(A_1,A_2\)</span> 相等的概率就变成了 <spanclass="math inline">\(\dfrac{1}{4}\)</span>，然而实际上这个结果应该是<span class="math inline">\(0\)</span>。</p><p>这实际上断绝了我们直接考虑每个数的概率的可行性。</p><p>那么我们不妨维护每个点对 <span class="math inline">\((l,r)\)</span>表示 <span class="math inline">\(A_l,A_r\)</span>相等的概率。此时我们的操作区间可以分成三种：</p><ol type="1"><li>只涵盖了一个点的区间：此时会产生 <spanclass="math inline">\(\dfrac{1}{len}\)</span> 的影响。</li><li>涵盖了两个点的区间：此时会产生 <spanclass="math inline">\(\dfrac{2}{len}\)</span> 的影响。</li><li>一个点都没涵盖的区间：不管。</li></ol><p>此时有一个非常巧妙的做法：我们不妨将 <spanclass="math inline">\((l,r)\)</span>的点对看作一个二维网格，那么我们对于一次区间操作 <spanclass="math inline">\((L,R)\)</span>，考虑他对每个点对的影响。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2023/09/19/TVFfdGP8zyk57K6.png"                     alt="二维网格"                 ><figcaption aria-hidden="true">二维网格</figcaption></figure><p>举个例子：如上图，如果我们对原序列 <spanclass="math inline">\([3,5]\)</span>进行操作，那么第一种情况的点对对应的就是红色区域，第二种情况的点对对应的就是黄色区域，第三种情况对应的白色区域。</p><p>现在就显然可以用二维线段树（或者叫线段树套线段树）维护了。中间黄色三角形不太好维护，可以直接填满矩形。</p><p>不过还有一个问题：你发现这个树状数组的 <spanclass="math inline">\(\text{Find}\)</span>比一般的要长一点；因为他加了一个特判。当 <spanclass="math inline">\(l=1\)</span> 的时候，<spanclass="math inline">\(x\)</span> 会变成 <spanclass="math inline">\(0\)</span>，此时会直接返回 <spanclass="math inline">\(0\)</span>，相当于问你区间 <spanclass="math inline">\([r,n]\)</span> 是否为 <spanclass="math inline">\(0\)</span> 了，特别处理一下即可。</p><p>时空复杂度均为 <span class="math inline">\(O(n\log^2n)\)</span>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rt[MAXN &lt;&lt; <span class="number">2</span>], lson[MAXN * <span class="number">375</span>], rson[MAXN * <span class="number">375</span>], res[MAXN * <span class="number">375</span>];</span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(ll x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; y; x = x * x % mod, y &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>&#123;<span class="keyword">return</span> (<span class="number">1ll</span> * p * q % mod + <span class="number">1ll</span> * ((<span class="number">1</span> + mod - p) % mod) * ((<span class="number">1</span> + mod - q) % mod) % mod) % mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) k = ++cnt, res[k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> (<span class="type">void</span>)(res[k] = <span class="built_in">calc</span>(res[k], v));</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(lson[k], l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(rson[k], mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span> L2, <span class="type">int</span> R2, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L1 &lt;= l &amp;&amp; r &lt;= R1) <span class="keyword">return</span> <span class="built_in">update</span>(rt[k], <span class="number">1</span>, n, L2, R2, v);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L1 &lt;= mid) <span class="built_in">Update</span>(ls, l, mid, L1, R1, L2, R2, v);</span><br><span class="line">    <span class="keyword">if</span>(R1 &gt; mid) <span class="built_in">Update</span>(rs, mid + <span class="number">1</span>, r, L1, R1, L2, R2, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> res[k];</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="keyword">return</span> <span class="built_in">calc</span>(res[k], <span class="built_in">query</span>(lson[k], l, mid, x));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">calc</span>(res[k], <span class="built_in">query</span>(rson[k], mid + <span class="number">1</span>, r, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x1, <span class="type">int</span> x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> <span class="built_in">query</span>(rt[k], <span class="number">1</span>, n, x2);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x1 &lt;= mid) <span class="keyword">return</span> <span class="built_in">calc</span>(<span class="built_in">query</span>(rt[k], <span class="number">1</span>, n, x2), <span class="built_in">Query</span>(ls, l, mid, x1, x2));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">calc</span>(<span class="built_in">query</span>(rt[k], <span class="number">1</span>, n, x2), <span class="built_in">Query</span>(rs, mid + <span class="number">1</span>, r, x1, x2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, l, r;</span><br><span class="line">        <span class="built_in">read</span>(op, l, r);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">qpow</span>(r - l + <span class="number">1</span>, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(l &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">1</span>, l - <span class="number">1</span>, l, r, (<span class="number">1</span> + mod - x) % mod);</span><br><span class="line">                <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, l - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">if</span>(r &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, r + <span class="number">1</span>, n, (<span class="number">1</span> + mod - x) % mod);</span><br><span class="line">                <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">0</span>, <span class="number">0</span>, r + <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, l, r, (<span class="number">1</span> + <span class="number">2ll</span> * mod - <span class="number">2ll</span> * x) % mod);</span><br><span class="line">            <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">0</span>, <span class="number">0</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">0</span>, n, l - <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><h2 id="楼房重建">楼房重建</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P4198" >洛谷P4198楼房重建</a></p><blockquote><p>在一个二维平面上有 <span class="math inline">\(N\)</span> 栋楼房。小A 在平面上 <span class="math inline">\((0,0)\)</span> 点的位置，第 <spanclass="math inline">\(i\)</span> 栋楼房可以用一条连接 <spanclass="math inline">\((i,0)\)</span> 和 <spanclass="math inline">\((i,H_i)\)</span> 的线段表示，其中 <spanclass="math inline">\(H_i\)</span> 为第 <spanclass="math inline">\(i\)</span>栋楼房的高度。如果这栋楼房上任何一个高度大于 <spanclass="math inline">\(0\)</span> 的点与 <spanclass="math inline">\((0,0)\)</span>的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。</p><p>施工队的建造总共进行了 <span class="math inline">\(M\)</span>天。初始时，所有楼房都还没有开始建造，它们的高度均为 <spanclass="math inline">\(0\)</span>。在第 <spanclass="math inline">\(i\)</span> 天，建筑队将会将横坐标为 <spanclass="math inline">\(X_i\)</span> 的房屋的高度变为 <spanclass="math inline">\(Y_i\)</span>。请你帮小 A数数每天在建筑队完工之后，他能看到多少栋楼房?</p><p><span class="math inline">\(1 \le X_i \le N\)</span>，<spanclass="math inline">\(1 \le Y_i \le 10^9\)</span>，<spanclass="math inline">\(1\le N,M \le 10^5\)</span>。</p></blockquote><p>根据我们小学二年级学过的几何知识，我们可以把这个题目转化一下：题目等同于维护<span class="math inline">\((i,H_i)\)</span> 到 <spanclass="math inline">\((0,0)\)</span> 连线的斜率 <spanclass="math inline">\(k_i\)</span>，并求出从 <spanclass="math inline">\(1\)</span>开始、贪心的上升子序列（即如果当前点大于最大值，则一定选取它）。</p><p>考虑用线段树去维护它。考虑怎么把两端信息合并。</p><p>首先，左区间和右区间合并的时候，左区间一定全选，而右区间会选择大于左区间<span class="math inline">\(max\)</span> 的部分。这个东西怎么求？</p><p>线段树二分！</p><p>我们只需要在合并的时候同时二分右区间即可。时间复杂度 <spanclass="math inline">\(O(n\log^2 n)\)</span>。</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Code </summary>              <div class='content'>              <div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].maxx &lt;= x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (tr[k].maxx &gt; x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[ls].maxx &lt;= x) <span class="keyword">return</span> <span class="built_in">get</span>(rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(ls, l, mid, x) + tr[k].len - tr[ls].len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[k].len = tr[ls].len + <span class="built_in">get</span>(rs, mid + <span class="number">1</span>, r, tr[ls].maxx);</span><br><span class="line">    tr[k].maxx = <span class="built_in">max</span>(tr[ls].maxx, tr[rs].maxx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == x &amp;&amp; r == x) <span class="keyword">return</span> (<span class="type">void</span>)(tr[k].maxx = <span class="number">1.00</span> * v / x, tr[k].len = <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">update</span>(ls, l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><h2 id="火事待做">火事（待做）</h2><p><a class="link"   href="https://www.luogu.com.cn/problem/P6881" >【JOI2020Final】火事</a></p><blockquote><p>给定一个长为 <span class="math inline">\(N\)</span> 的序列 <spanclass="math inline">\(S_i\)</span>，刚开始为时刻 <spanclass="math inline">\(0\)</span>。定义 <spanclass="math inline">\(t\)</span> 时刻第 <spanclass="math inline">\(i\)</span> 个数为 <spanclass="math inline">\(S_i(t)\)</span>，且满足：</p><p><span class="math display">\[\left\{\begin{array}{ll}S_0(t)=0\\S_i(0)=S_i\\S_i(t)=\max\{S_{i-1}(t-1),S_i(t-1)\}\end{array}\right.\]</span></p><p><span class="math inline">\(Q\)</span> 次询问，每次给定 <spanclass="math inline">\(L,R,T\)</span>，求：</p><p><span class="math display">\[\sum\limits_{k=L}^{R}S_k(T)\]</span></p><p><span class="math inline">\(1\leq N,Q\leq 2\cdot 10^5\)</span>。</p></blockquote><h1 id="参考与鸣谢">参考与鸣谢</h1><h2 id="参考">参考</h2><ol type="1"><li>《妈妈再也不用担心我的线段树了》——孙耀峰；</li><li><a class="link"   href="https://oi-wiki.org/" >OI Wiki</a>；</li><li><a class="link"  href="https://www.luogu.com.cn/blog/dowhiletrue/solution-p4097" >do_while_true的李超树讲解</a>；</li><li>RainAir 在 SDSC2023 上的课件。</li></ol><h2 id="鸣谢">鸣谢</h2><ol type="1"><li><a class="link"   href="https://www.cnblogs.com/-Complex-/" >EXODUS</a>对本文的勘误与启示；</li><li><a class="link"   href="https://www.cnblogs.com/do-while-true" >do_while_true</a>针对李超线段树的指导。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;系统复盘了一下线段树，发现网上现有博客鲜有将线段树各种操作一步一步讲明白的，故结合自己理解写此文。&lt;/p&gt;
&lt;p&gt;应该会持续更新。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="线段树" scheme="http://summace.cc/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>SDOI2023 游记</title>
    <link href="http://summace.cc/SDOI2023/"/>
    <id>http://summace.cc/SDOI2023/</id>
    <published>2023-04-30T16:00:00.000Z</published>
    <updated>2023-09-15T01:16:32.659Z</updated>
    
    <content type="html"><![CDATA[<p>体验省选。</p><span id="more"></span><h1 id="day--1">Day -1</h1><p>本来没想到可以来省选，毕竟 NOIP考的太拉了。甚至是正式选手，RMB-700。</p><p>周五中午从学校开润，下午到了平邑。</p><p>然后遇到了百年难得一遇的街区停电。</p><p>晚上去试机，Win7炸场，键盘拉跨，但是和美婷、庞队在一个考场，好耶。</p><h1 id="day1">Day1</h1><p><span class="math inline">\(8:00\)</span>就进考场了，先敲了线段树和快读，不知道能不能用上。</p><p><span class="math inline">\(8:30\)</span> 开考，先瞄一眼题目。T1看起来可做，T2 图论一眼弃，T3 应该能做。</p><p>于是开始写 T1。发现这不是萌萌题吗，省选怎么会出这么简单的题。<spanclass="math inline">\(9:17\)</span> 过了 <spanclass="math inline">\(3\)</span> 个样例，润润润。</p><p>然后就直接开始看T3。想了想，感觉暴力能写，于是开始写暴力，差不多写了两百多行，突然发现暴力思路是寄的。寄寄寄。</p><p>因为本来也没有希望进队，写出来一题感觉十分满足，于是就检查了下T1，一直到 <span class="math inline">\(13:00\)</span> 收卷。</p><p>然后学校统一安排了午饭。这真的是我在学校里吃过的有史以来最丰盛的一次。就是队伍非常long long，排了很久。</p><p>下午摆摆摆。</p><h1 id="day2">Day2</h1><p><span class="math inline">\(8:30\)</span> 开考，先瞄一眼题目。T1过河卒，感觉暴力可做。T2T3 看起来很难，先做 T1。</p><p>T1 的 <span class="math inline">\(20pts\)</span>是好拿的，很顺利拿下来了。</p><p>第二个 <span class="math inline">\(10pts\)</span> 就是红色和黑色1v1，手玩了半天没怎么会，先润。</p><p>然后发现第四个 <span class="math inline">\(20pts\)</span>是能拿的，于是敲了个大暴力。</p><p>T2 把最基本暴力分拿了。T3 想当然认为直接 <spanclass="math inline">\(1 0\)</span> 就行了，然后喜提 <spanclass="math inline">\(0pts\)</span>。</p><p>吃饭，润，美婷身份证丢了，于是陪着美婷润了两遍食堂-考场，很热。</p><p>然后就润回来了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;体验省选。&lt;/p&gt;</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>NOIP2022 爆零记</title>
    <link href="http://summace.cc/NOIP2022/"/>
    <id>http://summace.cc/NOIP2022/</id>
    <published>2022-11-30T16:00:00.000Z</published>
    <updated>2023-09-15T01:16:10.913Z</updated>
    
    <content type="html"><![CDATA[<p>一次愉快的 NOIP，而又是与他们最后的诀别。</p><span id="more"></span><h1 id="day--8">Day -8</h1><p>由于 CSP-S 和高一的同学们脱轨了，因此乖乖回去学whk。本来以为没啥希望了，结果晚上 🍬一通电话通知居然能去了。非常惊讶。但是一段时间没学 OI了，感觉更菜了。就当是体验一下。</p><h1 id="day--7">Day -7</h1><p>要在下午 <span class="math inline">\(17:00\)</span> 之前到平邑，因此<span class="math inline">\(14:30\)</span>就要走。学校要求交艺术节作品，趁上午写了写结果写挂了，气急败坏。RP--。</p><p>然后下午睡了一路之后来到平邑，住在很豪华的全季酒店，感觉从来没住过如此豪华。酒店临着河（好像叫浚河，祊河支流），还算是河景房，环境非常优美。</p><p>睡得很安稳。</p><h1 id="day--6">Day -6</h1><p>上午 vp 了一下 CF，没切出 F，RP--。</p><p>题目里面有道题叫做 The Humanoid，是 ZTMY 歌名，RP++。</p><p>酒店居然有咖啡机。喝了一杯，好苦。</p><h1 id="day--5">Day -5</h1><p>写了几道线段树，感觉对线段树理解更深了一点。</p><p>写了几篇题解，但是发现自己换硬盘重装系统忘了把 Blog文件夹拷过来，只能等 m.2-&gt;usb 买来了在部署了，先写着。</p><p>鸭子可爱捏。</p><p>晚上和 <span class="citation" data-cites="chiptune">@chiptune</span>一起 vp 了一场 abc，没切出来 F，自闭了，RP--。</p><h1 id="day--4">Day -4</h1><p>下雨了。</p><p>测了下分院帽，Slytherin。</p><p>下午 vp 了一场 div4，本来想涨涨信心，结果没 AK，自闭了，RP--。</p><p>鸭子给了一首<a class="link"  href="https://music.163.com/#/song?id=557581315" >好听的歌</a>，单循了，RP++。</p><p>感觉自己菜炸了，模板都不会了。</p><p>调整作息，<span class="math inline">\(22:00\)</span>就睡了，我真规律。</p><h1 id="day--3">Day -3</h1><p>上午敲了敲板子，愣神。</p><p>感觉自己没救了。</p><p>鸭子又给了一首<a class="link"  href="https://music.163.com/#/song?id=1347630432" >好听的歌</a>，单循了，但是没有VIP，气得我满地乱爬。于是从 B 站下载音频上传到云盘，我真聪明。</p><p>写了个攒 RP 的程序，开始跑了。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld, %lld, RP++\n&quot;</span>, i, <span class="built_in">clock</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>梦神锐评：“你是真无聊。”</p><p>晚上头巨疼。不知道为什么。疼死我了。于是早早睡了。</p><p>有点后怕，别上考场再头疼。</p><h1 id="day--2">Day -2</h1><p>🍬 给了一场 GMOJ 的比赛，难炸了，只拿了 B 题 20pts 暴力分。</p><p>查询小w精神状态，结果为：就你还想打 NOIP？</p><p>出考场了，5考场。</p><p>测了一下 mbti，ENFJ-A。</p><p>下午被精度给整自闭了。但是美婷姐姐理我了，很开心，RP++。</p><p>写游记了。</p><h1 id="day--1">Day -1</h1><p>考前最后一天。上午意识到这一点有些紧张。</p><p>然后就肆无忌惮地摆了一天。看了看KMP、逆元，感觉还可以。</p><p>一直到晚上🍬开了个会，希望明天不要自闭吧。</p><p>鸭子请了一杯奶茶，芋泥+珍珠，很好喝。</p><p>领了前瞻的 300 原石，抽了一下，没想到 16抽就出了卢老爷，根据运气守恒定律，感觉明天会寄。</p><p>早点睡觉吧。还是有点紧张。</p><h1 id="day-1">Day 1</h1><p>早上六点起床，早饭没吃凉的，吃的不多，有点担心会不会饿。但是实际上并没有。</p><p>然后就坐（站）着大巴去 pyyz。终于见到 ss,lz1,lzy,zzk,lmt了，很开心。</p><p>带着手机去结果根本没查码。</p><p>上考场先把快读和对拍敲了，结果两个都没用到。</p><p>考试还有个小风波，一开始给的密码不对，后来又给了，导致拖后了十分钟，不过在后面补上了。没想到是双重密码，pdf的密码是一开始给的。</p><p>解压包的密码是 <code>biu#2019miss</code>，是不是在暗示错过了 2019年？（2019刚好疫情开始捏。）</p><p>pdf 的密码是 <code>solo@2022</code>，是不是暗示 2022年单身啊呜呜。</p><p>先看一遍题。T1 感觉可做，T2 是啥啊，名字倒是挺好听的。T3一眼图论，一眼要跑 Tarjan，一眼我不会。T4 一眼大数据结构，一眼不会。</p><p>然后感觉先看看 T1。然后就想到可以对于每列 <spanclass="math inline">\(j\)</span> 的每行 <spanclass="math inline">\(i\)</span>预处理一下最长可以向上延伸多少，然后就可以想到对于每行 <spanclass="math inline">\(i\)</span>维护最多可以向右延伸多少，然后就可以想到统计。但是是 <spanclass="math inline">\(O(n^4)(假设n,m同阶)\)</span> 的。</p><p>然后稍微一考虑就能想到前缀和优化一下到 <spanclass="math inline">\(O(n^2)\)</span>，然后就过了 <spanclass="math inline">\(114\ 514\)</span> 的大样例。好像也没法对拍，大概是<span class="math inline">\(10:00\)</span>，润了。</p><p>然后看了看 T2，感觉是很牛逼的构造，不会。之后 T4暴力跑线段树维护最大值 <span class="math inline">\(O(Qn^2\log n)8pts\)</span> 跑路了。</p><p>之后一直在 T4 和 T2 纠结，感觉都拿不到分。已经有点慌了。</p><p>然后感觉 T2 <span class="math inline">\(k=2n-2\)</span>的部分分好像可做，想了很长时间感觉可以每个分配两种颜色，最后一个栈做闲余栈，写了写过了样例，自己造了几组也过了。</p><p>然后感觉很没有头猪。又一直在想 T2 <spanclass="math inline">\(k=2n-1,n=2\)</span> 的部分分，写了一个 <spanclass="math inline">\(8\)</span> 个 <code>if</code>的大分类讨论，一直调不过去。眼看还有 <spanclass="math inline">\(10min\)</span>，先把东西都整理到 E盘，然后最后两分钟突然调出来了，过了样例，赶紧复制到文件里。感觉差不多了。</p><p>估分 <span class="math inline">\(100+30+0+8=138pts\)</span>，但是T1、T2 都很不稳。</p><p>水杯还落到教室里了，意识到的时候已经走了好几公里了，遂作罢。</p><p>lmt 说能 <span class="math inline">\(255pts\)</span>，结果 T2假了，<span class="math inline">\(200pts\)</span> 左右。</p><p>感觉是打的最烂的一次比赛。</p><p>T2 果然是 zrf 投的题啊……果然恶心。</p><p>luogu 测了一下 T1，过了，感觉安心一点了。</p><p>luogu 和 infoj 测了所有的，一分没挂。感觉是打的最好的一次比赛。</p><h1 id="days-later">Days Later</h1><p>T1 挂了，省二。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一次愉快的 NOIP，而又是与他们最后的诀别。&lt;/p&gt;</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LuoguP1253 扶苏的问题</title>
    <link href="http://summace.cc/LGP1253/"/>
    <id>http://summace.cc/LGP1253/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:13:32.166Z</updated>
    
    <content type="html"><![CDATA[<p>线段树。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>实际上相当于维护一颗线段树，支持区间覆盖、区间加和区间查询最大值。</p><p>维护最大值很好办，区间覆盖和区间加我们怎么维护呢？</p><p>首先，区间覆盖和区间加一定都分别需要记一个懒标记。我们把区间覆盖的懒标记记为<span class="math inline">\(ctag\)</span>，区间加的懒标记记为 <spanclass="math inline">\(atag\)</span>，那么我们如何把标记 <spanclass="math inline">\(\text{pushdown}\)</span> 呢？</p><p>首先，初始化要选择一个尽量不影响之后操作的值。<spanclass="math inline">\(atag\)</span> 显然选择 <spanclass="math inline">\(0\)</span> 即可。由于要更改的数字有正有负，<spanclass="math inline">\(ctag\)</span> 可以选取 <spanclass="math inline">\(-\infty\)</span>，在程序中我选用了 <spanclass="math inline">\(1e18+7\)</span> 作为 <spanclass="math inline">\(\text{INF}\)</span>。</p><p>考虑到如果我们当前节点有一个 <spanclass="math inline">\(atag\)</span> 标记，之后又打上了一个 <spanclass="math inline">\(ctag\)</span>标记，那么<strong>要覆盖的值会直接把要加的值覆盖</strong>，也就是说<span class="math inline">\(ctag\)</span> 会直接清除 <spanclass="math inline">\(atag\)</span>。而如果先打上 <spanclass="math inline">\(ctag\)</span>，再打上 <spanclass="math inline">\(atag\)</span>，则需要<strong>先把 <spanclass="math inline">\(ctag\)</span> 下放，再下放 <spanclass="math inline">\(atag\)</span></strong>。那么我们的 <spanclass="math inline">\(\text{pushdown}\)</span> 可以这么写：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span> <span class="comment">//把下放的操作封装一下可以使代码更简洁</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx += v;</span><br><span class="line">    t[k].atag += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = v;</span><br><span class="line">    t[k].ctag = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpushdown</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">//ctag 的下放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].ctag == -INF) <span class="keyword">return</span>; <span class="comment">//如果没有标记，返回</span></span><br><span class="line">    t[ls].atag = t[rs].atag = <span class="number">0</span>; <span class="comment">//抹除 atag</span></span><br><span class="line">    <span class="built_in">cf</span>(ls, t[k].ctag), <span class="built_in">cf</span>(rs, t[k].ctag); <span class="comment">//ctag 下放</span></span><br><span class="line">    t[k].ctag = -INF; <span class="comment">//当前节点 ctag 清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apushdown</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">//atag 的下放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].atag == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//如果没有标记，返回</span></span><br><span class="line">    <span class="built_in">cpushdown</span>(k); <span class="comment">//先把 ctag 下放</span></span><br><span class="line">    <span class="built_in">af</span>(ls, t[k].atag), <span class="built_in">af</span>(rs, t[k].atag); <span class="comment">//atag 下放</span></span><br><span class="line">    t[k].atag = <span class="number">0</span>; <span class="comment">//当前节点 atag 清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">apushdown</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次 pushdown 操作包括 ctag 的下放和 atag 的下放，都要进行</span></span><br></pre></td></tr></table></figure></div><p>那么操作呢？区间加操作和之前一样即可，区间覆盖操作需要清除当前节点的<span class="math inline">\(atag\)</span>。</p><p>其他部分即为普通线段树模板。</p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxx;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> atag, ctag;</span><br><span class="line">&#125;t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = <span class="built_in">max</span>(t[ls].maxx, t[rs].maxx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx += v;</span><br><span class="line">    t[k].atag += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = v;</span><br><span class="line">    t[k].ctag = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].ctag == -INF) <span class="keyword">return</span>;</span><br><span class="line">    t[ls].atag = t[rs].atag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cf</span>(ls, t[k].ctag), <span class="built_in">cf</span>(rs, t[k].ctag);</span><br><span class="line">    t[k].ctag = -INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].atag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">af</span>(ls, t[k].atag), <span class="built_in">af</span>(rs, t[k].atag);</span><br><span class="line">    t[k].atag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">apushdown</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].l = l;</span><br><span class="line">    t[k].r = r;</span><br><span class="line">    t[k].atag = <span class="number">0</span>;</span><br><span class="line">    t[k].ctag = -INF;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].maxx = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">af</span>(k, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].atag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cf</span>(k, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">cover</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">cover</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r) <span class="keyword">return</span> t[k].maxx;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(ls, l, r));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(rs, l, r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">cover</span>(<span class="number">1</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;线段树。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="http://summace.cc/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>NOI2013 快餐店</title>
    <link href="http://summace.cc/LGP1399/"/>
    <id>http://summace.cc/LGP1399/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:13:54.705Z</updated>
    
    <content type="html"><![CDATA[<p>图片炸了，难过。本地也没有存。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>一道很经典的基环树上dp题。<del>调了一年</del>。</p><p>首先，如果没有环的话，这就是一道简单的求树上重心的题目。众所周知，树的重心一定在直径的中点上。</p><p>但是现在在一个基环树上做，应该怎么求呢？我们先画一个图：</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://c2.im5i.com/2022/09/23/HW8Pz.png"                      alt="基环树"                 ><figcaption aria-hidden="true">基环树</figcaption></figure><p>为了方便，我们先设边权全部为 <spanclass="math inline">\(1\)</span>。</p><p>首先，我们可以想到断一条环上的边，然后求断边后的树的直径。</p><blockquote><p>略证：考虑到直径一定不会经过一整个环，所以依次断边后求直径一定不会漏掉真正的直径。</p></blockquote><p>这样的复杂度是 <span class="math inline">\(O(n^2)\)</span>的，我们考虑一下如何优化。</p><p>在刚刚的过程中，我们从环上的第一条边一直到最后一条边依次断开，而我们每次断开都要重新计算一次直径，这中间显然是有重合的部分的，于是我们可以考虑用类似于dp 的东西优化。</p><p>考虑有两种情况:</p><ol type="1"><li>直径没有经过环；</li><li>直径经过了环。</li></ol><p>第一个情况很好搞，第二种情况略有麻烦，也是我们刚刚复杂度的瓶颈所在。</p><p>先上结论：</p><ul><li>记 <span class="math inline">\(pre_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之前某以环上节点为根节点的子树的直径加上该点距离环上 <spanclass="math inline">\(1\)</span> 号点的距离的最大值；</li><li>记 <span class="math inline">\(suf_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之后某以环上节点为根节点的子树的直径加上该点距离环上 <spanclass="math inline">\(m\)</span> 号点的距离的最大值；</li><li>记 <span class="math inline">\(pres_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之前环上某两节点的子树直径加上两点之间的距离的最大值；</li><li>记 <span class="math inline">\(sufs_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之后环上某两节点的子树直径加上两点之间的距离的最大值；</li><li>记 <span class="math inline">\(w_{(i,j)}\)</span> 表示 <spanclass="math inline">\(i,j\)</span> 两点的距离。</li></ul><p>那么第 <span class="math inline">\(i\)</span> 号点的答案即为 <spanclass="math inline">\(\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\)</span>。</p><p>最终答案即为 <spanclass="math inline">\(\min\limits_{i=1}^{m-1}\{\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\}\)</span></p><p>是不是到现在已经有些晕了？没关系，我们从图上举例说明一下。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://c2.im5i.com/2022/09/23/HX5t8.png"                      alt="删边"                 ><figcaption aria-hidden="true">删边</figcaption></figure><p>例如，我们现在有一只删了一条环边 <spanclass="math inline">\((4,5)\)</span> 的基环树。</p><p>我们仔细复盘一下刚刚的几句话。</p><p>先看 <span class="math inline">\(pre_i\)</span> 和 <spanclass="math inline">\(suf_i\)</span>。由于两个很像，所以重点解释 <spanclass="math inline">\(pre_i\)</span>。</p><blockquote><p>记 <span class="math inline">\(pre_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 点之前 <spanclass="math inline">\(//\)</span> 某以环上节点为根节点的子树的直径 <spanclass="math inline">\(//\)</span> 加上该点距离环上 <spanclass="math inline">\(1\)</span> 号点的距离 <spanclass="math inline">\(//\)</span> 的最大值。</p></blockquote><p>形式化的来说，我们要找的就是：</p><p><spanclass="math inline">\(pre_i=\max\limits_{j=1}^{i}\{dep_j+w_{(1,j)}\}\)</span></p><p>来看张图。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://c2.im5i.com/2022/09/23/H21O4.png"                      alt="pre和suf"                 ><figcaption aria-hidden="true">pre和suf</figcaption></figure><p><em>可能有多种方案，图中仅展示一种。</em></p><p>图中绿色的部分即为 <spanclass="math inline">\(pre_4\)</span>，橙色的部分即为 <spanclass="math inline">\(suf_5\)</span>。</p><p>可以看出来 <span class="math inline">\(pre_i\)</span> 和 <spanclass="math inline">\(suf_i\)</span> 其实就是一棵子树的直径 <spanclass="math inline">\(+\)</span> 它前面（后面）的链的长度。</p><p>接下来再看看 <span class="math inline">\(pres_i\)</span> 和 <spanclass="math inline">\(sufs_i\)</span>，同样重点解释 <spanclass="math inline">\(pres_i\)</span>。</p><blockquote><p>记 <span class="math inline">\(pres_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 点之前 <spanclass="math inline">\(//\)</span> 环上某两节点的子树直径 <spanclass="math inline">\(//\)</span> 加上两点之间的距离的最大值。</p></blockquote><p>形式化的来说，我们要找的就是：</p><p><spanclass="math inline">\(pres_i=\max\limits_{j=1}^{i}\{dep_i+dep_j+w_{(i,j)}\}\)</span></p><p>再来看张图。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://c2.im5i.com/2022/09/23/H2fal.png"                      alt="pres和sufs"                 ><figcaption aria-hidden="true">pres和sufs</figcaption></figure><p><em>可能有多种方案，图中仅展示一种。</em></p><p>图中蓝色的部分即为 <spanclass="math inline">\(pres_4\)</span>，黄色的部分即为 <spanclass="math inline">\(sufs_5\)</span>。</p><p>好，弄清楚这 <span class="math inline">\(4\)</span>个，我们来看看结果的式子：</p><blockquote><p>那么第 <span class="math inline">\(i\)</span> 号点的答案即为 <spanclass="math inline">\(\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\)</span>。</p></blockquote><p>我们考虑到删掉边 <span class="math inline">\((i,i+1)\)</span>的时候，直径有三种可能：</p><ol type="1"><li>直径在 <span class="math inline">\([1,i]\)</span> 之间；</li><li>直径在 <span class="math inline">\([i+1,m]\)</span> 之间；</li><li>直径跨过了边 <span class="math inline">\((1,m)\)</span>。</li></ol><p>对于第一种情况，我们惊喜地发现，<spanclass="math inline">\(pres_i\)</span> 即为我们所求。</p><p>对于第二种情况，我们再次惊喜地发现，<spanclass="math inline">\(sufs_{i+1}\)</span> 即为我们所求。</p><p>对于第三种情况，我们发现，由于 <spanclass="math inline">\(pre_i\)</span> 一直延伸到 <spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(suf_{i+1}\)</span> 一直延伸到 <spanclass="math inline">\(m\)</span>，所以我们再加上 <spanclass="math inline">\(w_{(1,m)}\)</span> 即可，也就是 <spanclass="math inline">\(pre_i+suf_{i+1}+w_{(1,m)}\)</span>。</p><p>最后我们遍历一遍，统计最小值即可。</p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt, w;</span><br><span class="line">&#125;e[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], ent;</span><br><span class="line"><span class="type">int</span> fa[MAXN], tnt, dfn[MAXN], dis[MAXN];</span><br><span class="line"><span class="type">bool</span> iscyc[MAXN];</span><br><span class="line"><span class="type">int</span> cyc[MAXN], cnt, cycdis[MAXN];</span><br><span class="line">ll dep[MAXN];</span><br><span class="line">ll pre[MAXN], suf[MAXN], presub[MAXN], sufsub[MAXN];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++ent].to = v;</span><br><span class="line">    e[ent].w = w;</span><br><span class="line">    e[ent].nxt = head[u];</span><br><span class="line">    head[u] = ent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++tnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[v] = u;</span><br><span class="line">            dis[v] = e[i].w;</span><br><span class="line">            <span class="built_in">dfs1</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &gt; dfn[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(; v != u; v = fa[v])</span><br><span class="line">            &#123;</span><br><span class="line">                iscyc[v] = <span class="literal">true</span>;</span><br><span class="line">                cyc[++cnt] = v;</span><br><span class="line">                cycdis[cnt] = dis[v];</span><br><span class="line">            &#125;</span><br><span class="line">            iscyc[u] = <span class="literal">true</span>;</span><br><span class="line">            cyc[++cnt] = u;</span><br><span class="line">            cycdis[cnt] = e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!iscyc[v] &amp;&amp; v != father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">            ans = <span class="built_in">max</span>((ll)dep[u] + dep[v] + e[i].w, ans);</span><br><span class="line">            dep[u] = <span class="built_in">max</span>(dep[u], dep[v] + e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add_edge</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add_edge</span>(b, a, c);</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="built_in">dfs2</span>(cyc[i], <span class="number">0</span>);</span><br><span class="line">    ll sum = <span class="number">0</span>, maxdep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += cycdis[i - <span class="number">1</span>];</span><br><span class="line">        pre[i] = <span class="built_in">max</span>(pre[i - <span class="number">1</span>], dep[cyc[i]] + sum);</span><br><span class="line">        presub[i] = <span class="built_in">max</span>(presub[i - <span class="number">1</span>], sum + maxdep + dep[cyc[i]]);</span><br><span class="line">        maxdep = <span class="built_in">max</span>(maxdep, dep[cyc[i]] - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    sum = maxdep = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp = cycdis[cnt];</span><br><span class="line">    cycdis[cnt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += cycdis[i];</span><br><span class="line">        suf[i] = <span class="built_in">max</span>(suf[i + <span class="number">1</span>], dep[cyc[i]] + sum);</span><br><span class="line">        sufsub[i] = <span class="built_in">max</span>(sufsub[i + <span class="number">1</span>], sum + maxdep + dep[cyc[i]]);</span><br><span class="line">        maxdep = <span class="built_in">max</span>(maxdep, dep[cyc[i]] - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = presub[cnt];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">        res = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(presub[i], sufsub[i + <span class="number">1</span>]), pre[i] + suf[i + <span class="number">1</span>] + tmp), res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>, (<span class="type">double</span>)<span class="built_in">max</span>(ans, res) / <span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;图片炸了，难过。本地也没有存。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LuoguP1133 教主的花园</title>
    <link href="http://summace.cc/LGP1133/"/>
    <id>http://summace.cc/LGP1133/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:13:14.057Z</updated>
    
    <content type="html"><![CDATA[<p>经典线性dp。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>典型的线性dp，首先考虑二维：</p><p>记 <span class="math inline">\(f_{i,j}\)</span> 表示当前为第 <spanclass="math inline">\(i\)</span> 位，放第 <spanclass="math inline">\(j\)</span> 种树的最大值。</p><p>然后我们发现我们没办法很好地表示树之间的高低关系，于是我们再加一维：</p><p>记 <span class="math inline">\(f_{i,j,0/1}\)</span> 表示当前为第<span class="math inline">\(i\)</span> 位，放第 <spanclass="math inline">\(j\)</span> 种树，当前树比上一位树 <spanclass="math inline">\(0(高)/1(低)\)</span> 的最大值。</p><p>我们可以很顺利地推出转移方程：</p><p><span class="math display">\[f_{i,j,0} = \max\limits_{k&lt;j}\{f_{i-1,k,1}\}\\f_{i,j,0} = \max\limits_{k&gt;j}\{f_{i-1,k,0}\}\]</span></p><p>如果这题只是一条线，那么这题到此为止就已经完成了。但是这道题是在环上，所以我们还要考虑如何处理头和尾。在记一维<span class="math inline">\(s\)</span> 表示第一位是那种树。即变成：</p><p>记 <span class="math inline">\(f_{i,j,s,0/1}\)</span> 表示当前为第<span class="math inline">\(i\)</span> 位，放第 <spanclass="math inline">\(j\)</span> 种树，第一位放 <spanclass="math inline">\(s\)</span> 种树，当前树比上一位树 <spanclass="math inline">\(0(高)/1(低)\)</span> 的最大值。</p><p><span class="math display">\[\text{if}\ \ 2\leq i&lt;n\begin{cases}    f_{i,j,s,0} = \max\limits_{k&lt;j}\{f_{i-1,k,s,1}\}\\    f_{i,j,s,1} = \max\limits_{k&gt;j}\{f_{i-1,k,s,0}\}\\\end{cases}\\\text{if}\ \ i=n\begin{cases}    f_{n,j,s,0} = \max\limits_{k&lt;j}\{f_{n-1,k,s,1}\}&amp; \text{if}\j&gt;s\\    f_{n,j,s,0} = \max\limits_{k&gt;j}\{f_{n-1,k,s,0}\}&amp; \text{if}\j&lt;s\\\end{cases}\]</span></p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN][<span class="number">4</span>], f[MAXN][<span class="number">4</span>][<span class="number">4</span>][<span class="number">2</span>]; <span class="comment">//f(i,j,s,0/1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i][<span class="number">1</span>], &amp;a[i][<span class="number">2</span>], &amp;a[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">f[<span class="number">1</span>][j][j][<span class="number">0</span>] = f[<span class="number">1</span>][j][j][<span class="number">1</span>] = a[<span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt;= <span class="number">3</span>; s++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= <span class="number">3</span>; k++) f[i][j][s][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j][s][<span class="number">1</span>], f[i - <span class="number">1</span>][k][s][<span class="number">0</span>] + a[i][j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--) f[i][j][s][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j][s][<span class="number">0</span>], f[i - <span class="number">1</span>][k][s][<span class="number">1</span>] + a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt;= <span class="number">3</span>; s++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s &lt; j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--) f[n][j][s][<span class="number">0</span>] = <span class="built_in">max</span>(f[n][j][s][<span class="number">0</span>], f[n - <span class="number">1</span>][k][s][<span class="number">1</span>] + a[n][j]);</span><br><span class="line">            <span class="keyword">if</span>(s &gt; j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= <span class="number">3</span>; k++) f[n][j][s][<span class="number">1</span>] = <span class="built_in">max</span>(f[n][j][s][<span class="number">1</span>], f[n - <span class="number">1</span>][k][s][<span class="number">0</span>] + a[n][j]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(f[n][j][s][<span class="number">0</span>], f[n][j][s][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典线性dp。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>HAOI2012 高速公路</title>
    <link href="http://summace.cc/LGP2221/"/>
    <id>http://summace.cc/LGP2221/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:14:16.861Z</updated>
    
    <content type="html"><![CDATA[<p>一道非常好的线段树题。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>优先想到线段树，考虑怎么维护。</p><p>记第 <span class="math inline">\(i\)</span> 到第 <spanclass="math inline">\(i+1\)</span> 条边为第 <spanclass="math inline">\(i\)</span> 条边，将问题转化成维护 <spanclass="math inline">\(n-1\)</span> 个数。</p><p>那么，我们维护一个前缀和 <spanclass="math inline">\(sum\)</span>，根据题意：</p><p><span class="math display">\[Ans=\frac{\sum\limits_{i=l}^{r}\sum\limits_{j=l}^{r}sum_j-sum_i}{\binom{r-l+1}{2}}(i\neqj)\]</span></p><p>下面的东西很好算，重点是上面的东西怎么维护。</p><p>我们把上面的东西记作 <spanclass="math inline">\(ans\)</span>，考虑枚举每条边被计算的次数，可以理解成枚举每个点左右两条路。</p><p>所以：</p><p><span class="math display">\[\begin{split}ans &amp;=\sum\limits_{i=l}^{r}a_i\times (r-i+1)(i-l+1)\\    &amp;=\sum\limits_{i=l}^{r}a_i\times (ir-lr+r-i^2+il-i+i-l+1)\\    &amp;=\sum\limits_{i=l}^{r}a_i\times (-i^2+(l+r)i-lr+r-l+1)\\    &amp;=-\sum\limits_{i=l}^{r}a_i\timesi^2+(l+r)\sum\limits_{i=l}^{r}a_i\timesi+(r-l-lr+1)\sum\limits_{i=l}^{r}a_i\end{split}\]</span></p><p>现在需要维护 <spanclass="math inline">\(sum_1=\sum_{i=l}^{r}a_i\times i^2\)</span>，<spanclass="math inline">\(sum_2=\sum_{i=l}^{r}a_i\times i\)</span>，<spanclass="math inline">\(sum_3=\sum_{i=l}^{r}a_i\)</span>。</p><p>即变成：</p><p><spanclass="math display">\[ans=-sum1+(l+r)sum2+(r-l-lr+1)sum3\]</span></p><p>考虑 <code>pushup</code> 的时候，直接相加就可以了。</p><p>考虑在区间 <span class="math inline">\([L,R]\)</span> 加上一个 <spanclass="math inline">\(x\)</span> 的时候怎么做：</p><p><span class="math display">\[\begin{split}sum_3&#39;&amp;= \sum\limits_{i=L}^{R}(a_i+x)\\&amp;= (R-L+1)x+\sum\limits_{i=L}^{R}a_i\\&amp;= (R-L+1)x+sum_3\\\Delta sum_3 &amp;= (R-L+1)x\end{split}\]</span></p><p>直接维护。</p><p><span class="math display">\[\begin{split}sum_2&#39;&amp;= \sum\limits_{i=L}^{R}i(a_i+x)\\&amp;= \sum\limits_{i=L}^{R}i\times a_i+\sum\limits_{i=L}^{R}ix\\&amp;= \sum\limits_{i=L}^{R}i\times a_i+x\sum\limits_{i=L}^{R}i\\&amp;= x\sum\limits_{i=L}^{R}i+sum_2\\\Delta sum_2 &amp;= x\sum\limits_{i=L}^{R}i\end{split}\]</span></p><p>维护区间和。</p><p><span class="math display">\[\begin{split}sum_1&#39;&amp;= \sum\limits_{i=L}^{R}i^2(a_i+x)\\&amp;= \sum\limits_{i=L}^{R}i^2\times a_i+\sum\limits_{i=L}^{R}i^2x\\&amp;= \sum\limits_{i=L}^{R}i^2\times a_i+x\sum\limits_{i=L}^{R}i^2\\&amp;= x\sum\limits_{i=L}^{R}i^2+sum_1\\\Delta sum_1 &amp;= x\sum\limits_{i=L}^{R}i^2\end{split}\]</span></p><p>维护区间平方和。</p><p>最后求期望约分即可。</p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans1, ans2, ans3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum1, sum2, sum3, sum4, sum5;</span><br><span class="line">            <span class="type">int</span> lazy;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">        &#125;tree[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].lazy += v;</span><br><span class="line">tree[k].sum1 += (tree[k].r - tree[k].l + <span class="number">1</span>) * v;</span><br><span class="line">            tree[k].sum2 += v * tree[k].sum5;</span><br><span class="line">            tree[k].sum3 += v * tree[k].sum4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].sum1 = tree[<span class="built_in">lc</span>(k)].sum1 + tree[<span class="built_in">rc</span>(k)].sum1;</span><br><span class="line">            tree[k].sum2 = tree[<span class="built_in">lc</span>(k)].sum2 + tree[<span class="built_in">rc</span>(k)].sum2;</span><br><span class="line">            tree[k].sum3 = tree[<span class="built_in">lc</span>(k)].sum3 + tree[<span class="built_in">rc</span>(k)].sum3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">lc</span>(k), tree[k].lazy);</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">rc</span>(k), tree[k].lazy);</span><br><span class="line">tree[k].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].lazy = <span class="number">0</span>;</span><br><span class="line">            tree[k].l = l;</span><br><span class="line">            tree[k].r = r;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[k].sum4 = l * l;</span><br><span class="line">                tree[k].sum5 = l;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">lc</span>(k), l, mid);</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r);</span><br><span class="line">tree[k].sum4 = tree[<span class="built_in">lc</span>(k)].sum4 + tree[<span class="built_in">rc</span>(k)].sum4;</span><br><span class="line">            tree[k].sum5 = tree[<span class="built_in">lc</span>(k)].sum5 + tree[<span class="built_in">rc</span>(k)].sum5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= tree[k].l &amp;&amp; tree[k].r &lt;= R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">f</span>(k, v);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(k);</span><br><span class="line"><span class="type">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(k), L, R, v);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(k), L, R, v);</span><br><span class="line"><span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= tree[k].l &amp;&amp; tree[k].r &lt;= R)</span><br><span class="line">            &#123;</span><br><span class="line">                ans1 += tree[k].sum1;</span><br><span class="line">                ans2 += tree[k].sum2;</span><br><span class="line">                ans3 += tree[k].sum3;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="built_in">pushdown</span>(k);</span><br><span class="line"><span class="type">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) <span class="built_in">query</span>(<span class="built_in">lc</span>(k), L, R);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) <span class="built_in">query</span>(<span class="built_in">rc</span>(k), L, R);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> l, r, v;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        r--;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;v);</span><br><span class="line">            t.<span class="built_in">update</span>(<span class="number">1</span>, l, r, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans1 = ans2 = ans3 = <span class="number">0</span>;</span><br><span class="line">            t.<span class="built_in">query</span>(<span class="number">1</span>, l, r);</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            a = (r - l + <span class="number">1</span> - r * l) * ans1 + (r + l) * ans2 - ans3;</span><br><span class="line">            b = (r - l + <span class="number">2</span>) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            c = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; l &lt;&lt; r &lt;&lt; b;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, a / c, b / c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道非常好的线段树题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="http://summace.cc/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>SDOI2006 保安站岗</title>
    <link href="http://summace.cc/LGP2458/"/>
    <id>http://summace.cc/LGP2458/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:14:41.830Z</updated>
    
    <content type="html"><![CDATA[<p>一道很经典的树形dp题目。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>很明显的树形dp，先把方程设出来：</p><p><span class="math inline">\(f_{x,0/1/2}\)</span> 表示当前节点为 <spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(0(自己覆盖)/1(儿子覆盖)/2(父亲覆盖)\)</span>，且其子节点都已全部覆盖的最小权值。</p><p>很套路的树形dp方程，分别考虑如何转移：</p><p>记 <span class="math inline">\(son(i)\)</span> 表示 <spanclass="math inline">\(i\)</span> 的所有子节点，<spanclass="math inline">\(k_i\)</span> 表示控制 <spanclass="math inline">\(i\)</span> 点所需的代价。</p><h2 id="f_x0自己覆盖">1. <spanclass="math inline">\(f_{x,0}\)</span>（自己覆盖）</h2><p><span class="math inline">\(f_{x,0} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1},f_{y,2}\}+k_x\)</span></p><p>解释：由于当前节点自己覆盖自己，所以不需考虑其他的节点，在所有子节点中找到最小值转移即可。</p><h2 id="f_x1儿子覆盖">2. <spanclass="math inline">\(f_{x,1}\)</span>（儿子覆盖）</h2><p><span class="math inline">\(f_{x,1} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\}\)</span></p><p>解释：当当前节点被儿子覆盖时，说明当前节点不可能覆盖儿子节点，也就无法从<span class="math inline">\(f_{y,2}\)</span> 转移。</p><p>但是有一种这样的情况：当儿子节点全部选择 <spanclass="math inline">\(f_{y,1}\)</span>时，即儿子节点全部被它的儿子节点覆盖，在这种情况下 <spanclass="math inline">\(x\)</span> 节点无法被儿子节点覆盖。</p><p>所以我们在转移的时候记一个 <span class="math inline">\(q\)</span>表示是否全部选择的 <spanclass="math inline">\(f_{y,1}\)</span>，如果是，则强制选择一个节点让其选择<spanclass="math inline">\(f_{y,0}\)</span>。我们要向最小化代价，显然要让强制选择的节点<span class="math inline">\(f_{y,0}\)</span> 与 <spanclass="math inline">\(f_{y,1}\)</span>的差值最小。所以现在转移方程如下：</p><p><span class="math inline">\(f_{x,1} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\},\text{if all choose }f_{y,1},\text{then}+\min\limits_{y\inson(x)}\{f_{y,0}-f_{y,1}\}\)</span></p><h2 id="f_x2父亲覆盖">3. <spanclass="math inline">\(f_{x,2}\)</span>（父亲覆盖）</h2><p><span class="math inline">\(f_{x,2} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\}\)</span></p><p>解释：这个就比较简单了，当当前节点被父亲覆盖，直接从可能的方式转移即可。</p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125;e[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], k[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = k[x];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, minn = INF;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">        f[x][<span class="number">0</span>] += <span class="built_in">min</span>(f[y][<span class="number">0</span>], <span class="built_in">min</span>(f[y][<span class="number">1</span>], f[y][<span class="number">2</span>]));</span><br><span class="line">        f[x][<span class="number">2</span>] += <span class="built_in">min</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> tmp = <span class="built_in">min</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">        f[x][<span class="number">1</span>] += tmp;</span><br><span class="line">        <span class="keyword">if</span>(tmp == f[y][<span class="number">0</span>]) flag = <span class="literal">false</span>;</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, f[y][<span class="number">0</span>] - f[y][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) f[x][<span class="number">1</span>] += minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">        k[x] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add_edge</span>(x, y);</span><br><span class="line">            <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道很经典的树形dp题目。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://summace.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>USACO08FEB Hotel G</title>
    <link href="http://summace.cc/LGP2894/"/>
    <id>http://summace.cc/LGP2894/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:14:57.295Z</updated>
    
    <content type="html"><![CDATA[<p>经典线段树问题。</p><span id="more"></span><h1 id="prob.">Prob.</h1><p><span class="math inline">\(n\)</span> 个房间，两种操作：</p><ol type="1"><li><code>1 x</code>：在 <span class="math inline">\([1,n]\)</span>中寻找一段长度为 <span class="math inline">\(x\)</span>的空房区间。若存在，入住这些房间，并输出最小的左端点。若不存在，输出<span class="math inline">\(0\)</span>；</li><li><code>2 l r</code>：<span class="math inline">\([l,l+r-1]\)</span>退房。</li></ol><h1 id="sol.">Sol.</h1><p>这道题也算是线段树常规操作了。我们要维护连续的空房区间，想想要维护哪些值？</p><p>与分治的思想类似，一段空房区间可以全部在左半部分、全部在右半部分、或者左半部分和右半部分都有一部分。那么我们可以维护三个值：从<strong>左端点开始的</strong>最长空房区间长度、从<strong>右端点开始的</strong>最长空房区间长度、以及<strong>整个区间的</strong>最长空房区间长度。我们把它们分别记为<span class="math inline">\(lmax,rmax,maxx\)</span>。</p><p>那我们想想线段树的各个模块该如何写。</p><h2 id="textpushup"><spanclass="math inline">\(\text{pushup}\)</span></h2><p>由于我们要维护三个值，那么上传的时候也要上传三个值。</p><p>分情况讨论：</p><h3 id="lmax-如何上传"><span class="math inline">\(lmax\)</span>如何上传？</h3><p>显然，当前节点的 <span class="math inline">\(lmax\)</span>直接选取左区间的 <span class="math inline">\(lmax\)</span>就可以了。但是这里有一种特殊情况：<strong>当左区间的 <spanclass="math inline">\(lmax\)</span> 等于整段左区间的长度时，<spanclass="math inline">\(lmax\)</span>可以继续延伸至右区间的左端。</strong>此时 <spanclass="math inline">\(lmax\)</span> 应该为左区间的 <spanclass="math inline">\(lmax\)</span> 加上有区间的 <spanclass="math inline">\(lmax\)</span>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t[ls].lmax == (t[ls].r - t[ls].l + <span class="number">1</span>)) t[k].lmax = t[ls].lmax + t[rs].lmax;</span><br><span class="line"><span class="keyword">else</span> t[k].lmax = t[ls].lmax;    </span><br></pre></td></tr></table></figure></div><h3 id="rmax-如何上传"><span class="math inline">\(rmax\)</span>如何上传？</h3><p>与 <span class="math inline">\(lmax\)</span> 类似，当右区间的 <spanclass="math inline">\(rmax\)</span> 等于整段右区间的长度时，<spanclass="math inline">\(rmax\)</span>可以继续延伸至左区间的右端。否则，选取右区间的 <spanclass="math inline">\(rmax\)</span>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t[rs].rmax == (t[rs].r - t[rs].l + <span class="number">1</span>)) t[k].rmax = t[rs].rmax + t[ls].rmax;</span><br><span class="line"><span class="keyword">else</span> t[k].rmax = t[rs].rmax;</span><br></pre></td></tr></table></figure></div><h3 id="maxx-如何上传"><span class="math inline">\(maxx\)</span>如何上传？</h3><p>显然，<span class="math inline">\(maxx\)</span>直接从左端点开始的长度、右端点开始的长度、以及左右都有的长度中选取最大值即可。左右都有的长度就是左区间的<span class="math inline">\(rmax\)</span> 加上右区间的 <spanclass="math inline">\(lmax\)</span>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t[k].maxx = <span class="built_in">max</span>(<span class="built_in">max</span>(t[ls].maxx, t[rs].maxx), t[ls].rmax + t[rs].lmax);</span><br></pre></td></tr></table></figure></div><p>那么，我们的 <span class="math inline">\(\text{pushup}\)</span>就可以这么写了：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[ls].lmax == (t[ls].r - t[ls].l + <span class="number">1</span>)) t[k].lmax = t[ls].lmax + t[rs].lmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].lmax = t[ls].lmax;</span><br><span class="line">    <span class="keyword">if</span>(t[rs].rmax == (t[rs].r - t[rs].l + <span class="number">1</span>)) t[k].rmax = t[rs].rmax + t[ls].rmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].rmax = t[rs].rmax;</span><br><span class="line">    t[k].maxx = <span class="built_in">max</span>(<span class="built_in">max</span>(t[ls].maxx, t[rs].maxx), t[ls].rmax + t[rs].lmax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="textpushdown"><spanclass="math inline">\(\text{pushdown}\)</span></h2><p>当然，区间修改就一定要打懒标记。虽然这道题目的修改不是常规的数值修改，我们仍然要打<span class="math inline">\(tag\)</span>。</p><p>注意到修改操作有两种：开房和退房。那么我们的 <spanclass="math inline">\(tag\)</span> 可以分别用 <spanclass="math inline">\(0/1/2\)</span> 表示 无标记/开房/退房。</p><p>那么当 <span class="math inline">\(tag=1\)</span>时，整段区间都不可用，<spanclass="math inline">\(lmax=rmax=maxx=0\)</span>。</p><p>当 <span class="math inline">\(tag=2\)</span>时，整段区间都可用，<spanclass="math inline">\(lmax=rmax=maxx=len\)</span>，<spanclass="math inline">\(len\)</span> 为区间长度。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].tag == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//无标记返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">1</span>) <span class="comment">//开房标记，整段区间不可用</span></span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">1</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = <span class="number">0</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">2</span>) <span class="comment">//退房标记，整段区间都可用</span></span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">2</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = t[ls].r - t[ls].l + <span class="number">1</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = t[rs].r - t[rs].l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t[k].tag = <span class="number">0</span>; <span class="comment">//别忘了清零标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="textbuild"><spanclass="math inline">\(\text{build}\)</span></h2><p>这个和常规操作没什么不同，只是由于初始全部都是空房，把所有 <spanclass="math inline">\(lmax,rmax,maxx\)</span>赋为当前区间长度就可以了。</p><h2 id="textupdate"><spanclass="math inline">\(\text{update}\)</span></h2><p>修改操作有两个：开房和退房。但是大体上没什么不同，可以只用一个函数解决。</p><p>当是开房操作时，整段区间不可用，<spanclass="math inline">\(lmax=rmax=maxx=0\)</span>，打上 <spanclass="math inline">\(1\)</span> 标记。</p><p>当是退房操作时，整段区间都可用，<spanclass="math inline">\(lmax=rmax=maxx=len\)</span>，打上 <spanclass="math inline">\(2\)</span> 标记。</p><p>函数添加一个参数 <span class="math inline">\(type\)</span>，<spanclass="math inline">\(1/2\)</span> 分别表示 开房/退房 操作。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = <span class="number">0</span>;</span><br><span class="line">            t[k].tag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = t[k].r - t[k].l + <span class="number">1</span>;</span><br><span class="line">            t[k].tag = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = t[k].l + t[k].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, type);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, type);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="textquery"><spanclass="math inline">\(\text{query}\)</span></h2><p>查询时，要从三部分查询：全部在左区间找、在中间找、全部在右区间找。</p><p>这里有一个优先级的问题：由于我们要输出最小的编号，那么应该是左区间→中间→右区间的顺序。</p><p>所以，如果左儿子的 <spanclass="math inline">\(maxx&gt;=len(len为要查询的长度)\)</span>，那么就从左儿子里找。否则，如果左儿子的<span class="math inline">\(rmax\)</span> 加上右儿子的 <spanclass="math inline">\(lmax\)</span> 大于等于 <spanclass="math inline">\(len\)</span>（也就是跨左右儿子的空房区间），那么直接输出这段的左端点。否则，去右儿子里找。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].l == t[k].r) <span class="keyword">return</span> t[k].l;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(t[ls].maxx &gt;= len) <span class="keyword">return</span> <span class="built_in">query</span>(ls, len); <span class="comment">//去左儿子里找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[ls].rmax + t[rs].lmax &gt;= len) <span class="keyword">return</span> t[ls].r - t[ls].rmax + <span class="number">1</span>; <span class="comment">//去中间找，答案就是左儿子 rmax 的左端点，可以用左儿子的右端点 - rmax长度 + 1 表示</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs, len); <span class="comment">//去右儿子里找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, tag;</span><br><span class="line">    <span class="type">int</span> lmax, rmax, maxx;</span><br><span class="line">&#125;t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[ls].lmax == (t[ls].r - t[ls].l + <span class="number">1</span>)) t[k].lmax = t[ls].lmax + t[rs].lmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].lmax = t[ls].lmax;</span><br><span class="line">    <span class="keyword">if</span>(t[rs].rmax == (t[rs].r - t[rs].l + <span class="number">1</span>)) t[k].rmax = t[rs].rmax + t[ls].rmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].rmax = t[rs].rmax;</span><br><span class="line">    t[k].maxx = <span class="built_in">max</span>(<span class="built_in">max</span>(t[ls].maxx, t[rs].maxx), t[ls].rmax + t[rs].lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].tag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">1</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = <span class="number">0</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">2</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = t[ls].r - t[ls].l + <span class="number">1</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = t[rs].r - t[rs].l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].tag = <span class="number">0</span>;</span><br><span class="line">    t[k].l = l, t[k].r = r;</span><br><span class="line">    t[k].maxx = t[k].lmax = t[k].rmax = (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = <span class="number">0</span>;</span><br><span class="line">            t[k].tag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = t[k].r - t[k].l + <span class="number">1</span>;</span><br><span class="line">            t[k].tag = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = t[k].l + t[k].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, type);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, type);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].l == t[k].r) <span class="keyword">return</span> t[k].l;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(t[ls].maxx &gt;= len) <span class="keyword">return</span> <span class="built_in">query</span>(ls, len);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[ls].rmax + t[rs].lmax &gt;= len) <span class="keyword">return</span> t[ls].r - t[ls].rmax + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">1</span>].maxx &lt; len) <span class="comment">//如果整段区间都没有大于等于 len 的空房区间，那么输出 0</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> ans = <span class="built_in">query</span>(<span class="number">1</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, ans, ans + len - <span class="number">1</span>, <span class="number">1</span>); <span class="comment">//别忘了开上房</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, l, l + r - <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//退房</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="ext.">Ext.</h2><p>讲个笑话，这道题我调了三次的原因；</p><ol type="1"><li>没建树 <del>（lmt：我们要有所建树！）</del>；</li><li><code>Shift</code> 没按上 <del>（导致 93行加号打成了等号）</del>；</li><li>从 <span class="math inline">\(l\)</span> 开 <spanclass="math inline">\(r\)</span> 个房，不是从 <spanclass="math inline">\(l\)</span> 开到 <spanclass="math inline">\(r\)</span> <del>（所以在 Prob. 里面特意说了是 [l,r-l+1]）</del>。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典线段树问题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="http://summace.cc/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CTSC2012 电阻网络</title>
    <link href="http://summace.cc/LGP4020/"/>
    <id>http://summace.cc/LGP4020/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:15:18.541Z</updated>
    
    <content type="html"><![CDATA[<p>在各学科交叉应用的潮流下，一道具有超前预见性的好题。</p><span id="more"></span><h1 id="solution">Solution</h1><h2 id="前置知识">前置知识</h2><h3 id="欧姆定律">欧姆定律</h3><p>在同一电路中，通过某段导体的电流跟这段导体两端的电压成正比，跟这段导体的电阻成反比。</p><p><span class="math display">\[I=\frac{U}{R}\]</span></p><p>其中 <span class="math inline">\(I\)</span> 为电流，<spanclass="math inline">\(U\)</span> 为电压，<spanclass="math inline">\(R\)</span> 为电阻。</p><h3 id="基尔霍夫第一定律">基尔霍夫第一定律</h3><p>会合于任意节点的电流和等于零。</p><p><span class="math display">\[\sum I=0\]</span></p><h2 id="solution-1">Solution</h2><p>本题中全部为相同电阻，所以答案与电阻大小无关，记电阻大小为 <spanclass="math inline">\(R\)</span>，钦定一个叶子节点为根。</p><p>考虑第 <span class="math inline">\(i\)</span> 个节点，记 <spanclass="math inline">\(i\)</span> 的父亲为 <spanclass="math inline">\(fa\)</span>，儿子集合为 <spanclass="math inline">\(son\)</span>，<spanclass="math inline">\(fa\rightarrow i\)</span> 的电流为 <spanclass="math inline">\(I_i\)</span>。</p><p>则从 <span class="math inline">\(fa\)</span> 到 <spanclass="math inline">\(i\)</span>的过程中，电势差的产生可以看作两部分，一部分是电阻导致的电势的下降，一部分是电源导致的电势的上升，这两部分之和等于电势差。即：</p><p><spanclass="math display">\[\varphi_i=\varphi_{fa}-I_iR+E_i\]</span></p><p>移项得：</p><p><spanclass="math display">\[I_i=\frac{\varphi_{fa}-\varphi_i+E_i}{R}\]</span></p><p>这是 <span class="math inline">\(i\)</span>祖先方向的电流，同理，对于儿子方向的任意 <spanclass="math inline">\(x\in son\)</span>，我们有：</p><p><spanclass="math display">\[\varphi_x=\varphi_{i}-I_xR+E_x\]</span></p><p>得：</p><p><spanclass="math display">\[I_x=\frac{\varphi_{i}-\varphi_x+E_x}{R}\]</span></p><p>求和得：</p><p><span class="math display">\[\sum\limits_{x\inson}I_x=\sum\limits_{x\inson}\frac{\varphi_{i}-\varphi_x+E_x}{R}\]</span></p><p>根据基尔霍夫第一定律：</p><p><span class="math display">\[I_i=\sum\limits_{x\inson}I_x\]</span></p><p>即：</p><p><spanclass="math display">\[\frac{\varphi_{fa}-\varphi_i+E_i}{R}=\sum\limits_{x\inson}\frac{\varphi_{i}-\varphi_x+E_x}{R}\]</span></p><p>继续化简：</p><p><spanclass="math display">\[\varphi_{fa}-\varphi_i+E_i=\sum\limits_{x\inson}(\varphi_{i}-\varphi_x+E_x)\]</span></p><p><spanclass="math display">\[\varphi_{fa}-\varphi_i+E_i=|son|\varphi_i-\sum\limits_{x\inson}(\varphi_x-E_x)\]</span></p><p><spanclass="math display">\[(|son|+1)\varphi_i=\varphi_{fa}+E_i+\sum\limits_{x\inson}(\varphi_x-E_x)\]</span></p><p>注意到 <span class="math inline">\(|son|\)</span>是儿子集合，相当于当前节点向儿子方向的度数；<spanclass="math inline">\(1\)</span> 相当于当前节点向父亲方向的度数，所以<span class="math inline">\(|son|+1\)</span> 实际上相当于节点 <spanclass="math inline">\(i\)</span> 的度数，记为 <spanclass="math inline">\(\deg_i\)</span>。</p><p><spanclass="math display">\[\deg_i\varphi_i=\varphi_{fa}+E_i+\sum\limits_{x\inson}(\varphi_x-E_x)\]</span></p><p>设 <spanclass="math inline">\(\varphi_i=K_i\varphi_{fa}+B_i\)</span>，其中 <spanclass="math inline">\(K_i,B_i\)</span> 都是只与 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(son\)</span> 有关的常量。</p><p>把 <span class="math inline">\(\varphi_x\)</span>用刚刚的形式表示出来：</p><p><spanclass="math display">\[\varphi_x=K_x\varphi_{i}+B_x\]</span></p><p>代入原式：</p><p><spanclass="math display">\[\varphi_i=\frac{\varphi_{fa}+E_i+\sum\limits_{x\inson}(K_x\varphi_{i}+B_x-E_x)}{\deg_i}\]</span></p><p>把这个式子表示成刚刚的形式：</p><p><spanclass="math display">\[\deg_i\varphi_i=\varphi_{fa}+E_i+\sum\limits_{x\inson}(K_x\varphi_{i}+B_x-E_x)\]</span></p><p><spanclass="math display">\[\deg_i\varphi_i=\varphi_{fa}+E_i+\varphi_i\sum\limits_{x\inson}K_x+\sum\limits_{x\in son}(B_x-E_x)\]</span></p><p><span class="math display">\[\varphi_i(\deg_i-\sum\limits_{x\inson}K_x)=\varphi_{fa}+E_i+\sum\limits_{x\in son}(B_x-E_x)\]</span></p><p><spanclass="math display">\[\varphi_i=\frac{1}{\deg_i-\sum\limits_{x\inson}K_x}\varphi_{fa}+\frac{\sum\limits_{x\inson}(B_x-E_x)+E_i}{\deg_i-\sum\limits_{x\in son}K_x}\]</span></p><p>我们发现此时已经表示成 <spanclass="math inline">\(\varphi_i=K_i\varphi_{fa}+B_i\)</span>的形式了。那么：</p><p><span class="math display">\[K_i=\frac{1}{\deg_i-\sum\limits_{x\inson}K_x}\]</span></p><p><span class="math display">\[B_i=\frac{\sum\limits_{x\inson}(B_x-E_x)+E_i}{\deg_i-\sum\limits_{x\inson}K_x}=K_i(\sum\limits_{x\in son}(B_x-E_x)+E_i)\]</span></p><p>因为我们要求 <span class="math inline">\(i\)</span>到地面，所以特判一下叶子。叶子度数为 <spanclass="math inline">\(2\)</span>，一条边连向地面，地面电势为 <spanclass="math inline">\(0\)</span>。</p><h1 id="code">Code</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="type">int</span> rt, n, m;</span><br><span class="line"><span class="type">int</span> deg[MAXN], fa[MAXN];</span><br><span class="line"><span class="type">double</span> k[MAXN], b[MAXN], sumb[MAXN], ph[MAXN], sumph[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt] = (Edge)&#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    edge[++cnt] = (Edge)&#123;u, head[v]&#125;;</span><br><span class="line">    head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    <span class="type">double</span> sumk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v != f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">init</span>(v, u);</span><br><span class="line">            sumk += k[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k[u] = <span class="number">1.0</span> / (deg[u] - sumk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sumb[fa[u]] -= b[u];</span><br><span class="line">        b[u] = (sumb[u] + sumph[u] - ph[u]) * k[u];</span><br><span class="line">        sumb[fa[u]] += b[u];</span><br><span class="line">        <span class="built_in">add</span>(fa[u], e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[v] == u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">        e = -e;</span><br><span class="line">    &#125;</span><br><span class="line">    ph[u] -= e;</span><br><span class="line">    sumph[v] -= e;</span><br><span class="line">    <span class="built_in">add</span>(u, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> k[u] * <span class="built_in">query</span>(fa[u]) + b[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v);</span><br><span class="line">        deg[u]++, deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_edge</span>(i, <span class="number">0</span>);</span><br><span class="line">            deg[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">1</span>) deg[i] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, <span class="built_in">query</span>(u));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u, v, e;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;e);</span><br><span class="line">            <span class="built_in">modify</span>(u, v, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在各学科交叉应用的潮流下，一道具有超前预见性的好题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="物理" scheme="http://summace.cc/tags/%E7%89%A9%E7%90%86/"/>
    
    <category term="数学" scheme="http://summace.cc/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="递推" scheme="http://summace.cc/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>初赛知识点整理第2版</title>
    <link href="http://summace.cc/Pre2/"/>
    <id>http://summace.cc/Pre2/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2023-09-15T01:16:23.839Z</updated>
    
    <content type="html"><![CDATA[<p>NOIP 初赛知识点整理 第2版。</p><p>温馨提示：不保证对，但也不保证错。</p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=1819306496&amp;auto=1&amp;height=66"></iframe><h1 id="一noi-史">一、NOI 史</h1><ol type="1"><li>NOI 于 <span class="math inline">\(1984\)</span> 年首次举行。</li><li>NOIP 于 <span class="math inline">\(1995\)</span> 年首次举行。</li><li>NOIP 于 <span class="math inline">\(2019\)</span> 年暂停。</li><li>CSP 于 <span class="math inline">\(2019\)</span> 年首次举行。</li><li>NOIP 于 <span class="math inline">\(2020\)</span> 年恢复。</li></ol><h1 id="二计算机发展史">二、计算机发展史</h1><ul><li><span class="math inline">\(1944\)</span>年，<strong>美籍匈牙利</strong>数学家<strong>冯·诺依曼</strong>提出计算机基本结构和工作方式的设想，为计算机的诞生和发展提供了理论基础。</li><li><span class="math inline">\(1946\)</span> 年，世界上第一台电子计算机<strong>ENIAC</strong> 在美国宾夕法尼亚大学诞生。</li></ul><table><thead><tr class="header"><th style="text-align: center;">代别</th><th style="text-align: center;">年代</th><th style="text-align: center;">电子元件</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">第一代</td><td style="text-align: center;"><spanclass="math inline">\(1946-1958\)</span></td><td style="text-align: center;">电子管</td></tr><tr class="even"><td style="text-align: center;">第二代</td><td style="text-align: center;"><spanclass="math inline">\(1959-1964\)</span></td><td style="text-align: center;">晶体管</td></tr><tr class="odd"><td style="text-align: center;">第三代</td><td style="text-align: center;"><spanclass="math inline">\(1965-1970\)</span></td><td style="text-align: center;">集成电路</td></tr><tr class="even"><td style="text-align: center;">第四代</td><td style="text-align: center;"><spanclass="math inline">\(1970-\text{今}\)</span></td><td style="text-align: center;">大规模、超大规模集成电路</td></tr></tbody></table><h1 id="三计算机著名人物及奖项">三、计算机著名人物及奖项</h1><h2 id="艾伦麦席森图灵alan-mathison-turing英国人">艾伦·麦席森·图灵(AlanMathison Turing，英国人)</h2><p>被称为计算机科学之父，人工智能之父。图灵对于人工智能的发展有诸多贡献，例如图灵曾写过一篇名为《计算机器和智能》的论文，提问“机器会思考吗？”（CanMachinesThink?），作为一种用于判定机器是否具有智能的测试方法，即图灵测试。至今，每年都有试验的比赛。此外，图灵提出的著名的图灵机模型为现代计算机的逻辑工作方式奠定了基础。</p><h2 id="约翰冯诺依曼john-von-neumann美籍匈牙利人">约翰·冯·诺依曼(Johnvon Neumann，美籍匈牙利人)</h2><p>被后人称为“现代计算机之父”、“博弈论之父”。1945年6月，冯·诺伊曼与戈德斯坦、勃克斯等人，联名发表了一篇长达101页纸的报告，即计算机史上著名的“101页报告”，是现代计算机科学发展里程碑式的文献。明确规定用二进制替代十进制运算，并将计算机分成5大组件，这一卓越的思想为电子计算机的逻辑结构设计奠定了基础，已成为计算机设计的基本原则。1951年，EDVAC计算机宣告完成。</p><h2 id="图灵奖acm-a.m-turing-award">图灵奖(ACM A.M Turing Award)</h2><p>美国计算机协会（ACM）于1966年设立的奖项，专门奖励对计算机事业作出重要贡献的个人。其名称取自世界计算机科学的先驱、英国科学家、曼彻斯特大学教授艾伦·图灵（A.M.Turing），这个奖设立目的之一是纪念这位现代计算机科学的奠基者。获奖者必须是在计算机领域具有持久而重大的先进性的技术贡献。大多数获奖者是计算机科学家。图灵奖是计算机界最负盛名的奖项，有“计算机界诺贝尔奖”之称。</p><h1 id="四linux-基本操作">四、Linux 基本操作</h1><h2 id="目录切换命令-cd">目录切换命令 <code>cd</code></h2><ul><li><code>cd xxx/</code> 切换到该目录下 <code>xxx</code> 目录</li><li><code>cd …/</code> 切换到上一层目录</li><li><code>cd /</code> 切换到系统根目录</li><li><code>cd ~</code> 切换到用户主目录</li></ul><h2 id="目录操作命令">目录操作命令</h2><ul><li><code>mkdir xxx</code> 新建名为 <code>xxx</code> 的文件夹（可能需要<code>sudo</code>）</li><li><code>ls xxx</code> 显示 <code>xxx</code> 下所有文件和目录</li><li><code>ls -a</code> 显示所有文件和目录（包括隐藏文件）</li><li><code>ls -l</code> 显示所有文件和目录（包括详细信息）</li><li><code>find xxx -name 'yyy'</code> 寻找 <code>xxx</code> 目录下名为<code>yyy</code> 相关的文件</li><li><code>mv xxx yyy</code> 重命名（目录文件均可）</li><li><code>cp -r xxx yyy</code> 把 <code>xxx</code> 拷贝到<code>yyy</code> 位置</li><li><code>rm [-rf] xxx</code> 删除 <code>xxx</code></li></ul><h2 id="文件操作命令">文件操作命令</h2><ul><li><code>touch xxx</code> 新建 <code>xxx</code> 文件</li><li><code>cat xxx</code> 显示 <code>xxx</code> 文件</li><li><code>vim xxx</code> 修改 <code>xxx</code> 文件</li></ul><h1 id="五计算机基础架构">五、计算机基础架构</h1><p>现代计算机基本为冯·诺依曼架构，即硬件部分分为五部分：运算器、控制器、存储器、输入设备、输出设备。</p><h2 id="运算器">运算器</h2><p>计算机硬件中的运算器主要功能是对数据和信息进行运算和加工。运算器包括以下几个部分：通用寄存器、状态寄存器、累加器和关键的算术逻辑单元。运算器可以进行算术计算（加减乘除）和逻辑运算（与或非）。</p><h2 id="控制器">控制器</h2><p>控制器和运算器共同组成了中央处理器<spanclass="math inline">\((CPU)\)</span>。控制器可以看作计算机的大脑和指挥中心，它通过整合分析相关的数据和信息，可以让计算机的各个组成部分有序地完成指令。</p><h2 id="存储器">存储器</h2><p>顾名思义，存储器就是计算机的记忆系统，是计算机系统中的记事本。而和记事本不同的是，存储器不仅可以保存信息，还能接受计算机系统内不同的信息并对保存的信息进行读取。存储器由主存和辅存组成，主存就是通常所说的内存，分为<span class="math inline">\(RAM\)</span> 和 <spanclass="math inline">\(ROM\)</span>两个部分。辅存即外存，但是计算机在处理外存的信息时，必须首先经过内外存之间的信息交换才能够进行。</p><h1 id="六计算机硬件系统">六、计算机硬件系统</h1><h2 id="cpu中央处理器"><spanclass="math inline">\(CPU\)</span>(中央处理器)</h2><p>由运算器、控制器和一些寄存器组成；作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。<span class="math inline">\(CPU\)</span>的主要性能指标是主频和字长。</p><h3 id="主频">主频</h3><p>主频是指计算机 <span class="math inline">\(CPU\)</span>的时钟频率，它在很大程度上决定了计算机的运算速度。一般时钟频率越高，运算速度就越快。主频的单位一般是<span class="math inline">\(MHz\)</span>（兆赫）或 <spanclass="math inline">\(GHz\)</span>（吉赫）。</p><h3 id="字长">字长</h3><p>字长是指一台计算机所能处理的二进制代码的位数。计算机的字长直接影响到它的精度、功能和速度。字长愈长，能表示的数值范围就越大，计算出的结果的有效位数也就越多；字长愈长，能表示的信息就越多，机器的功能就更强。常用的有<span class="math inline">\(32\)</span> 位、<spanclass="math inline">\(64\)</span> 位字长。</p><h2 id="存储器-1">存储器</h2><p>存储器的主要功能是用来保存各类程序的数据信息。存储器可分为主存储器和辅助存储器两类。</p><h3 id="主存储器">主存储器</h3><p>主存储器（也称为内存储器），属于主机的一部分。用于存放系统当前正在执行的数据和程序，属于临时存储器。</p><p>它和 <span class="math inline">\(CPU\)</span>一起构成了计算机的主机部分，它存储的信息可以被 <spanclass="math inline">\(CPU\)</span>直接访问。内存由半导体存储器组成，存取速度较快，但一般容量较小。</p><p>内存储器通常可以分为随机存储器 <spanclass="math inline">\(RAM\)</span>、只读存储器 <spanclass="math inline">\(ROM\)</span> 和高速缓冲存储器 <spanclass="math inline">\(Cache\)</span> 三种。</p><ul><li><span class="math inline">\(RAM(Random\ Access\ Memory)\)</span>是一种读写存储器，其内容可以随时根据需要读出，也可以随时重新写入新的信息。当电源电压去掉时，RAM中保存的信息都将全部丢失。</li><li><span class="math inline">\(ROM(Read-Only\ Memory)\)</span>是一种内容只能读出而不能写入和修改的存储器，其存储的信息是在制作该存储器时就被写入的。在计算机运行过程中，<spanclass="math inline">\(ROM\)</span>中的信息只能被读出，而不能写入新的内容。计算机断电后，<spanclass="math inline">\(ROM\)</span>中的信息不会丢失。它主要用于检查计算机系统的配置情况并提供最基本的输入/输出<spanclass="math inline">\((I/O)\)</span>控制程序。</li><li><span class="math inline">\(Cache\)</span>是高速缓冲存储器。由于计算机的 <span class="math inline">\(CPU\)</span>速度的不断提高，RAM的速度很难满足高速 <spanclass="math inline">\(CPU\)</span>的要求，所以在读/写系统内存都要加入等待的时间，这对高速 <spanclass="math inline">\(CPU\)</span> 来说是一种极大的浪费。<spanclass="math inline">\(Cache\)</span> 是指在 <spanclass="math inline">\(CPU\)</span>与内存之间设置的一级或两级高速小容量存储器，固化在主板上。在计算机工作时，系统先将数据由外存读入<span class="math inline">\(RAM\)</span> 中，再由 <spanclass="math inline">\(RAM\)</span> 读入 <spanclass="math inline">\(Cache\)</span> 中，然后 <spanclass="math inline">\(CPU\)</span> 直接从 <spanclass="math inline">\(Cache\)</span> 中取数据进行操作。</li></ul><h3 id="辅助存储器">辅助存储器</h3><p>辅助存储器（也称外存储器），它属于外部设备。用于存放暂不用的数据和程序，属于永久存储器。</p><p>它的容量一般都比较大，而且大部分可以移动，便于在不同计算机之间进行信息交流。在微型计算机中，常用的外存有软盘、硬盘、闪存和光盘。</p><ul><li><strong>软盘存储器</strong>由软盘、软盘驱动器和软盘适配器三部分组成。软盘是活动的存储介质，软盘驱动器是读写装置，软盘适配器是软盘驱动器与主机连接的接口。软盘驱动器安装在主机箱内，软盘驱动器插槽暴露在主机箱的前面板上，可方便地插入或取出软盘。 </li><li><strong>硬盘存储器</strong>是由电机和硬盘组成的，一般置于主机箱内。硬盘是涂有磁性材料的磁盘组件，用于存放数据。硬盘的机械转轴上串有若干个盘片，每个盘片的上下两面各有一个读/写磁头，与软盘磁头不同，硬盘的磁头不与磁盘表面接触，它们在离盘片面百万分之一英寸的气垫上。硬盘是一个非常精密的机械装置，磁道间只有百万分之几英寸的间隙，磁头传动装置必须把磁头快速而准确地移到指定的磁道上。 </li><li><strong>闪存</strong>又名优盘，是在存储速度与容量上介于软盘与硬盘之间的一种外部存储器。  </li><li><strong>光盘</strong>的存储介质不同于磁盘，它属于另一类存储器。由于光盘的容量大、存取速度较快、不易受干扰等特点，其应用越来越广泛。光盘根据其制造材料和记录信息方式的不同一般分为三类：只读光盘、一次写入型光盘和可擦写光盘。</li></ul><h1 id="七计算机语言">七、计算机语言</h1><p>计算机语言可以分为三类：机器语言、汇编语言、高级语言。</p><h2 id="机器语言">机器语言</h2><p>计算机最早的语言处理程序是机器语言，它是计算机能直接识别的语言，而且速度快。机器语言是用二进制代码来编写计算机程序，因此又称二进制语言。</p><h2 id="汇编语言">汇编语言</h2><p>由于机器语言的记忆困难，汇编语言开始用一些符号代替机器指令。但是用汇编语言编写的源程序不能被计算机直接识别，必须使用特定程序将用汇编语言写的源程序翻译和连接成能被计算机直接识别的二进制代码。</p><h2 id="高级语言">高级语言</h2><h3 id="翻译方式">翻译方式</h3><p>计算机并不能直接地接受和执行用高级语言编写的源程序，源程序在输入计算机时，通过程序翻译成机器语言形式的目标程序，通常有两种方式，即编译方式和解释方式。</p><ul><li>编译方式：编译方式的翻译工作由编译程序来完成，它先将整个源程序都转换成二进制代码，生成目标程序，把目标程序和可执行程序连接。</li><li>解释方式：源程序进入计算机时，解释程序边扫描边解释，对源程序的语句解释一条，执行一条，不产生目标程序。</li></ul><h3 id="面向对象与面向过程">面向对象与面向过程</h3><ul><li><p>面向过程 (ProcedureOriented)：把事情拆分成几个步骤（相当于拆分成一个个的方法和数据），然后按照一定的顺序执行。</p></li><li><p>面向对象 (ObjectOriented)：面向对象会把事物抽象成对象的概念，先抽象出对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法。</p></li></ul><h3 id="常见语言">常见语言</h3><table><thead><tr class="header"><th style="text-align: center;">语言</th><th style="text-align: center;">面向对象/面向过程</th><th style="text-align: center;">翻译方式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">面向过程</td><td style="text-align: center;">编译方式</td></tr><tr class="even"><td style="text-align: center;">C++</td><td style="text-align: center;">面向对象</td><td style="text-align: center;">编译方式</td></tr><tr class="odd"><td style="text-align: center;">Java</td><td style="text-align: center;">面向对象</td><td style="text-align: center;">不属于（更接近于解释方式）</td></tr><tr class="even"><td style="text-align: center;">Python</td><td style="text-align: center;">面向对象</td><td style="text-align: center;">解释方式</td></tr><tr class="odd"><td style="text-align: center;">Pascal</td><td style="text-align: center;">面向对象</td><td style="text-align: center;">编译方式</td></tr><tr class="even"><td style="text-align: center;">Fortran</td><td style="text-align: center;">面向过程</td><td style="text-align: center;">编译方式</td></tr></tbody></table><h1 id="八网络及网络协议">八、网络及网络协议</h1><p>所谓计算机网络，就是利用通信线路和设备，把分布在不同地理位置上的多台计算机连接起来。计算机网络是现代通信技术与计算机技术相结合的产物。</p><figure><img                       lazyload                     src="/images/loading.svg"                     data-src="https://z3.ax1x.com/2021/09/07/hT3wND.jpg"                      alt="协议"                 ><figcaption aria-hidden="true">协议</figcaption></figure><h2 id="网络协议">网络协议</h2><p>网络中计算机与计算机之间的通信依靠协议进行。协议是计算机收、发数据的规则。</p><ol type="1"><li><p>HTTP协议：基于TCP协议，超文本传输协议，对应于应用层，用于如何封装数据。也就是在底层是基于socket，http只不过是在收发数据的时候定义了很多规则，http头信息之类。</p></li><li><p>TCP/IP协议：关注的是客户端与服务器之间的数据传输是否成功（三次握手，传输失败会重发）。传输层协议，主要解决数据如何在网络中传输.</p></li><li><p>TCP/UDP协议:传输控制协议，对应于传输层，主要解决数据在网络中的传输。</p></li><li><p>IP 协议：对应于网络层，同样解决数据在网络中的传输。</p></li><li><p>TCP 协议：对应于传输层，是基于网络层的IP协议。</p></li><li><p>socket：属于传输层协议，是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p></li></ol><h3id="电子邮件协议全部隶属于tcpip协议">电子邮件协议(全部隶属于TCP/IP协议)</h3><ol type="1"><li>SMTP 协议：简单邮件传输协议(TCP25端口)；</li><li>POP3 协议：POP邮局协议第三版本(TCP110端口)；</li><li>IMAP 协议：互联网信息访问协议(TCP143端口)；</li></ol><h2 id="网络简述">网络简述</h2><ol type="1"><li>LAN：局域网</li><li>WAN：广域网</li><li>MAN：城域网</li><li>WLAN：无线局域网</li><li>WWAN：无线广域网</li><li>WMAN：无线城域网</li></ol><h1 id="九进制转换">九、进制转换</h1><h2 id="概述">概述</h2><p>常见进制有十进制、八进制、二进制、十六进制。</p><p><span class="math inline">\(N\)</span>进制逢<spanclass="math inline">\(N\)</span>进一，十六进制 <spanclass="math inline">\(10-15\)</span> 分别用 <spanclass="math inline">\(A-F\)</span> 表示。</p><p><span class="math inline">\(N\)</span>进制的数一般用 <spanclass="math inline">\((\overline{qwq})_{N}\)</span> 表示。</p><h2 id="十进制转x进制">十进制转<spanclass="math inline">\(X\)</span>进制</h2><p>短除法。</p><h2 id="x进制转十进制"><spanclass="math inline">\(X\)</span>进制转十进制</h2><p><span class="math inline">\((N)_{X}\)</span> 转为 <spanclass="math inline">\((M)_{10}\)</span>。</p><p>记 <span class="math inline">\(N_i\)</span> 表示 <spanclass="math inline">\((N)_{X}\)</span> 从低位向高位第 <spanclass="math inline">\(i\)</span> 位的数，<spanclass="math inline">\(SW_N\)</span> 为 <spanclass="math inline">\((N)_{X}\)</span> 的数位数。</p><p><span class="math inline">\(M = \sum\limits_{i=1}^{SW_N} N_i\timesX^{i-1}\)</span></p><h1 id="十信息编码">十、信息编码</h1><h2 id="二进制编码">二进制编码</h2><ul><li>原码（原码表示法）：十进制数直接转换来的二进制数。值得注意的是，原码的最高位是符号位：整数为<span class="math inline">\(0\)</span>，负数为 <spanclass="math inline">\(1\)</span>。 <spanclass="math inline">\(x=1100110\)</span>，则<spanclass="math inline">\([x]原=01100110\)</span>； <spanclass="math inline">\(x=-1100111\)</span>，则<spanclass="math inline">\([x]原=11100111\)</span>。</li><li>反码：正数的反码是本身，负数的反码是其除符号位之外的所有位按位取反的结果。<span class="math inline">\(x=1100110\)</span>，则<spanclass="math inline">\([x]反=01100110\)</span>； <spanclass="math inline">\(x=-1100111\)</span>，则<spanclass="math inline">\([x]反=10011000\)</span>。</li><li>补码：正数的补码是其本身，复数的补码是其反码加一。 <spanclass="math inline">\(x=1100110\)</span>，则<spanclass="math inline">\([x]补=01100110\)</span>； <spanclass="math inline">\(x=-1100111\)</span>，则<spanclass="math inline">\([x]补=10011001\)</span>。</li></ul><h2 id="textascii-码"><span class="math inline">\(\text{ASCII}\)</span>码</h2><p><span class="math inline">\(\text{ASCII}\)</span>编码是由美国国家标准委员会制定的一种包括数字、字母、通用符号和控制符号在内的字符编码集，全称叫美国国家信息交换标准代码。</p><figure><img                      lazyload                     src="/images/loading.svg"                     data-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.51wendang.com%2Fpic%2F7f94132e26a37161b8794dd4%2F1-1355-png_6_0_0_0_0_959_1355_959_1355-959-0-0-959.jpg&amp;refer=http%3A%2F%2Fimg.51wendang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664800854&amp;t=7ad119d038c8e89713f2b37400ee1179"                     alt="ASCII"                 ><figcaption aria-hidden="true">ASCII</figcaption></figure><h1 id="十一计算机安全常识">十一、计算机安全常识</h1><p>计算机病毒是一种人为制造的能够侵入计算机系统并给计算机带来故障的程序或指令集合。</p><p>计算机病毒具有传播性、潜伏性、破坏性与隐蔽性的特点。</p><h1 id="十二运算相关知识">十二、运算相关知识</h1><h2 id="逻辑运算">逻辑运算</h2><ol type="1"><li><p>逻辑与：<span class="math inline">\(\&amp;\&amp;\)</span> 或<span class="math inline">\(∧\)</span>，同 <spanclass="math inline">\(T\)</span> 则 <spanclass="math inline">\(T\)</span>，否则为 <spanclass="math inline">\(F\)</span>。</p></li><li><p>逻辑或：<span class="math inline">\(||\)</span> 或 <spanclass="math inline">\(∨\)</span>，有 <spanclass="math inline">\(T\)</span> 则 <spanclass="math inline">\(T\)</span>，否则为 <spanclass="math inline">\(F\)</span>。</p></li><li><p>逻辑非：<span class="math inline">\(!\)</span> 或 <spanclass="math inline">\(┐\)</span>，为 <spanclass="math inline">\(T\)</span> 则 <spanclass="math inline">\(F\)</span>，反之亦然。</p></li><li><p>逻辑异或：^ 或 <span class="math inline">\(⊕\)</span>，同为 <spanclass="math inline">\(F\)</span>，异为 <spanclass="math inline">\(T\)</span>。</p></li></ol><h2 id="位运算">位运算</h2><ol type="1"><li>按位与：<spanclass="math inline">\(\&amp;\)</span>，类似于逻辑与。</li><li>按位或：<span class="math inline">\(|\)</span>，类似于逻辑或。</li><li>按位反：~，类似于逻辑非。</li><li>左移：<span class="math inline">\(&lt;&lt;\)</span>，左移 <spanclass="math inline">\(x\)</span> 位相当于乘 <spanclass="math inline">\(2^x\)</span>。</li><li>右移：<span class="math inline">\(&gt;&gt;\)</span>，右移 <spanclass="math inline">\(x\)</span> 位相当于除 <spanclass="math inline">\(2^x\)</span>。</li></ol><h1 id="十三图论相关">十三、图论相关</h1><h2 id="概念">概念</h2><ul><li><strong>图(Graph)</strong> 是一个二元组 <spanclass="math inline">\(G=(V(G),E(G))\)</span>，其中 <spanclass="math inline">\(V(G)\)</span> 为点集，<spanclass="math inline">\(E(G)\)</span> 为边集。</li><li><strong>无向图(Undirected Graph)</strong>，边是双向的。</li><li><strong>有向图(Directed Graph)</strong>，边是单向的。</li><li><strong>自环(Loop)</strong>，对于某条边 <spanclass="math inline">\(e=(u,u)\)</span>，则称其为一个自环。</li><li><strong>重边(Multiple Edge)</strong>，图中存在两个相同的边。</li><li><strong>简单图(Simple Graph)</strong>，一个图中没有自环和重边。</li><li><strong>完全图(CompleteGraph)</strong>，任意两点都有边相连。若一个图的点为 <spanclass="math inline">\(n\)</span>，则边的个数为 <spanclass="math inline">\(\frac{n(n-1)}{2}\)</span></li><li><strong>平面图</strong>，没有边相交的图。四个点的完全图是一个平面图，五个点完全图任意去掉一条边都是平面图。</li><li><strong>连通图(Connected Graph)</strong>，任意两点都可以到达。</li><li><strong>有向无环图(DAG)</strong>，顾名思义。它可以拓扑排序。</li><li><strong>树(Tree)</strong>，无向无环连通图，且 <spanclass="math inline">\(n\)</span> 个节点的树有 <spanclass="math inline">\(n-1\)</span> 条边。</li><li><strong>森林(forest)</strong>：每个连通分量（连通块）都是树的图。按照定义，棵树也是森林。</li><li><strong>结点的深度(depth)</strong>：到根结点的路径上的边数。</li><li><strong>树的高度(height)</strong>：所有结点的深度的最大值。</li><li><strong>叶结点（leaf node）</strong>：没有子结点的结点。</li><li><strong>父亲（parentnode）</strong>：对于除根以外的每个结点，定义为从该结到根路径上的第二个结点。</li><li><strong>祖先（ancestor）</strong>：一个结点到根结点的路径上，<strong>包括它本身</strong>的所有节点。</li></ul><h1 id="十四排列组合">十四、排列组合</h1><h2 id="加法原理与乘法原理">加法原理与乘法原理</h2><ul><li>加法原理：有 <span class="math inline">\(n\)</span> 类元素，第 <spanclass="math inline">\(i\)</span> 类有 <spanclass="math inline">\(c_i\)</span>个元素，每类选一个元素，求方案数。</li><li>乘法原理：有 <span class="math inline">\(n\)</span> 组元素，第 <spanclass="math inline">\(i\)</span> 组有 <spanclass="math inline">\(c_i\)</span>个元素，每组选一个元素，求方案数。</li><li>加法原理实际上是分类，乘法原理实际上是分步。</li></ul><h2 id="排列与组合">排列与组合</h2><h3 id="排列">排列</h3><p>在 <span class="math inline">\(n\)</span>个数中<strong>有序</strong>选择 <span class="math inline">\(k\)</span>个数，方案数记为：</p><p><span class="math display">\[A_{n}^{k}=\frac{n!}{(n-k)!}\]</span></p><h3 id="组合">组合</h3><p>在 <span class="math inline">\(n\)</span>个数中<strong>无序</strong>选择 <span class="math inline">\(k\)</span>个数，方案数记为：</p><p><spanclass="math display">\[C_{n}^{k}=\frac{n!}{k!(n-k)!}\]</span></p><p>在竞赛中也常记为：</p><p><span class="math display">\[{n\choose k} =\frac{n!}{k!(n-k)!}\]</span></p><p>组合数的一些性质：</p><ul><li><span class="math inline">\({n\choose k}={n\choose n-k}\)</span>考虑从 <span class="math inline">\(n\)</span> 个中选 <spanclass="math inline">\(k\)</span> 个相当于从 <spanclass="math inline">\(n\)</span> 个中不选 <spanclass="math inline">\(n-k\)</span> 个。</li><li>递推计算：<span class="math inline">\({n\choose k}={n-1\choosek}+{n-1\choose k-1}\)</span> 从 <span class="math inline">\(n\)</span>个物品里面选 <span class="math inline">\(k\)</span> 个出来，考虑第 <spanclass="math inline">\(n\)</span> 个选不选。如果选就变成了从 <spanclass="math inline">\(n−1\)</span> 个里选 <spanclass="math inline">\(k-1\)</span>；否则就是从 <spanclass="math inline">\(n-1\)</span> 个里选 <spanclass="math inline">\(k\)</span>。</li><li>二项式定理：<spanclass="math inline">\((a+b)^n=\sum\limits_{i=0}^{n}{n\choosei}a^ib^{n-i}\)</span></li><li><span class="math inline">\(\sum\limits_{i=0}^{n}{n\choosei}=2^n\)</span></li><li><span class="math inline">\({a+b\choosek}=\sum\limits_{i=0}^{k}{a\choose i}{b\choose k-i}\)</span></li></ul><h2 id="答题方法">答题方法</h2><h3 id="枚举法">枚举法</h3><p>最基本的方法，当题目范围不大的时候可以考虑枚举。</p><h3 id="插板法">插板法</h3><p>例：学校师生合影，共 <span class="math inline">\(8\)</span>个学生，<span class="math inline">\(4\)</span>个老师，要求老师在学生中间，且老师互不相邻，共有多少种不同的合影方式？</p><p>解：先排学生共有 <span class="math inline">\(A_{8}^{8}\)</span>种排法，然后把老师插入学生之间的空档，共有 <spanclass="math inline">\(7\)</span> 个空档可插，选其中的 <spanclass="math inline">\(4\)</span> 个空档,共 <spanclass="math inline">\(A_{7}^{4}\)</span>种选法。根据乘法原理，共有的不同坐法 <spanclass="math inline">\(A_{8}^{8}A_{7}^{4}\)</span> 种。</p><h3 id="捆绑法">捆绑法</h3><p>例：<span class="math inline">\(5\)</span> 个男生 <spanclass="math inline">\(3\)</span> 个女生排成一排，<spanclass="math inline">\(3\)</span>个女生要排在一起，有多少种不同的排法？</p><p>解：因为女生要排在一起，所以可以将 <spanclass="math inline">\(3\)</span> 个女生看成是一个人，与 <spanclass="math inline">\(5\)</span> 个男生作全排列，有 <spanclass="math inline">\(A_{6}^{6}\)</span> 种排法，其中女生内部也有 <spanclass="math inline">\(A_{3}^{3}\)</span> 种排法，根据乘法原理，共有<span class="math inline">\(A_{6}^{6}A_{3}^{3}\)</span>种不同的排法。</p><h3 id="对等法">对等法</h3><p>例：学校安排考试科目 <span class="math inline">\(9\)</span>门，语文要在数学之前考，有多少种不同的安排顺序?</p><p>解：不加任何限制条件，整个排法有 <spanclass="math inline">\(A_{9}^{9}\)</span>种，“语文安排在数学之前考”与“数学安排在语文之前考”的排法是相等的，所以语文安排在数学之前考的排法共<span class="math inline">\(\frac{1}{2}A_{9}^{9}\)</span>种。</p><h2 id="卡特兰数">卡特兰数</h2><p>卡特兰数的定义如下：</p><p><span class="math display">\[\begin{align}\left\{\begin{array}{ll}C_n=1 &amp;(n=0,1)\\C_n=\sum\limits_{i=0}^{n-1}C_iC_{n-i-1} &amp;(n\geq 2)\\\end{array}\right.\end{align}\]</span></p><p>非递推式：</p><p><span class="math display">\[C_n={2n\choose n}-{2n\choose n+1}=\frac{2n\choose n}{n+1}\]</span></p><p>卡特兰数的组合意义：</p><ol type="1"><li><span class="math inline">\(n\)</span> 个点的二叉树</li><li><span class="math inline">\(n+1\)</span> 个点的区分儿子顺序的树</li><li><span class="math inline">\(2n+1\)</span>个点的二叉树，满足没有儿子个数为 <span class="math inline">\(1\)</span>的节点</li><li>长度为 <span class="math inline">\(2n\)</span> 的合法括号匹配</li><li>长度为 <span class="math inline">\(2n\)</span>的字符串的数量，其中有 <span class="math inline">\(n\)</span> 个 <spanclass="math inline">\(0\)</span>，<span class="math inline">\(n\)</span>个 <span class="math inline">\(1\)</span>，且对于任意的 <spanclass="math inline">\(i\)</span>，<span class="math inline">\(0\)</span>的数量都不少于 <span class="math inline">\(1\)</span> 的。</li><li><span class="math inline">\(2\times n\)</span> 的杨表数量。</li></ol><p>证明略。</p><h2 id="容斥原理">容斥原理</h2><p><spanclass="math display">\[\left|\bigcup\limits_{i=1}^{n}S_i\right|=\sum\limits_{m=1}^n(-1)^{m-1}\sum\limits_{a_i&lt;a_{i+1}}\left|\bigcap\limits_{i=1}^mS_{a_i}\right|\]</span></p><p>简单的小应用：</p><p><span class="math inline">\(|A\cup B\cup C|=|A|+|B|+|C|-|A\capB|-|B\cap C|-|C\cap A|+|A\cap B\cap C|\)</span></p><h1 id="十五时空复杂度相关">十五、时空复杂度相关</h1><ul><li>时间复杂度：算法的时间复杂度<span class="math inline">\(\text{(TimeComplexity)}\)</span>是指算法所需要的计算工作量，用算法所执行的基本运算次数来度量。</li><li>空间复杂度：算法的空间复杂度<span class="math inline">\(\text{(SpaceComplexity)}\)</span>是指执行这个算法所需要的内存空间。</li></ul><h2 id="主定理">主定理</h2><p>在算法分析中，主定理 <span class="math inline">\(\text{(mastertheorem)}\)</span> 提供了用渐近符号（大 <spanclass="math inline">\(O\)</span>符号）表示许多由分治法得到的递推关系式的方法。</p><h3 id="支配理论">支配理论</h3><p>假设有递归关系式：</p><p><spanclass="math display">\[T(n)=aT\left(\frac{n}{b}\right)+f(n),其中a\geq1,b&gt; 1\]</span></p><p>其中：</p><ul><li><span class="math inline">\(n\)</span> 为问题规模；</li><li><span class="math inline">\(a\)</span> 为递归的子问题数量；</li><li><span class="math inline">\(\frac{n}{b}\)</span>为每个子问题的规模（假设每个子问题的规模基本相同）；</li><li><span class="math inline">\(f(n)\)</span>为递归以外进行的计算工作。</li></ul><h3 id="情形一">情形一</h3><p>若 <span class="math inline">\(f(n)&lt;n^{\log_ba}\)</span>（多项式的小于），则<spanclass="math inline">\(T(n)=\Theta(n^{\log_{b}a})\)</span></p><h3 id="情形二">情形二</h3><p>若 <span class="math inline">\(f(n)=n^{\log_b a}\)</span>，则<spanclass="math inline">\(T(n)=\Theta(n^{\log_{b}a}\log n)\)</span></p><h3 id="情形三">情形三</h3><p>若 <span class="math inline">\(f(n)&gt;n^{\log_ba}\)</span>（多项式的大于），则<spanclass="math inline">\(T(n)=\Theta(f(n))\)</span></p><h2 id="常见排序算法与其时空复杂度">常见排序算法与其时空复杂度</h2><table><thead><tr class="header"><th style="text-align: center;">排序方法</th><th style="text-align: center;">时间复杂度</th><th style="text-align: center;">辅助存储空间复杂度</th><th style="text-align: center;">稳定性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">插入排序</td><td style="text-align: center;"><spanclass="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;">冒泡排序</td><td style="text-align: center;"><spanclass="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="odd"><td style="text-align: center;">选择排序</td><td style="text-align: center;"><spanclass="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="even"><td style="text-align: center;">快速排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)-O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(\logn)-O(n)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="odd"><td style="text-align: center;">希尔排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="even"><td style="text-align: center;">堆排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="odd"><td style="text-align: center;">归并排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(n)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;">基数排序</td><td style="text-align: center;"><spanclass="math inline">\(O(d(n+r))\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(rd+1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="odd"><td style="text-align: center;">桶排序</td><td style="text-align: center;"><span class="math inline">\(O(\max\{value\})\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(\max\{value\})\)</span></td><td style="text-align: center;">稳定</td></tr></tbody></table><h1 id="十六后记">十六、后记</h1><h2 id="说些什么">说些什么</h2><p>又是一年初赛季，回首过去的一篇<a class="link"  href="https://w-rb.github.io/Pre/" >NOIP初赛知识点整理</a>和过去忐忑的初赛经历，发现很多不足之处，遂写下本篇。仓促之下写完，也许未来还会有修修补补，也祝我们都能在初赛中取得好成绩。</p><h2 id="参考与鸣谢">参考与鸣谢</h2><h3 id="参考">参考</h3><ul><li><a class="link"  href="https://blog.csdn.net/KImdaML/article/details/116570033" >Linux的基础操作_KIMdamI</a></li><li><a class="link"  href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC" >约翰·冯·诺依曼_WikiPedia</a></li><li><a class="link"  href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5" >艾伦·图灵_WikiPedia</a></li><li><a class="link"  href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96" >图灵奖_WikiPedia</a></li><li><a class="link"  href="https://blog.csdn.net/m0_63725962/article/details/123057876" >面向对象和面向过程（总结版）_程序员这么可爱</a></li><li><a class="link"   href="https://oi-wiki.org/graph/tree-basic/" >树_OI-Wiki</a></li><li><a class="link"   href="https://oi-wiki.org/graph/concept/" >图_OI-Wiki</a></li><li>《信息学奥赛一本通 初赛篇》</li><li>历届 NOIP/CSP 初赛原题。</li><li>RainAir's PPT</li></ul><h3 id="鸣谢">鸣谢</h3><ul><li><span class="math inline">\(\text{EXODUS}\)</span>对本文的审查。</li><li><span class="math inline">\(\text{lwj}\)</span> 对本文的勘误。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;NOIP 初赛知识点整理 第2版。&lt;/p&gt;
&lt;p&gt;温馨提示：不保证对，但也不保证错。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
