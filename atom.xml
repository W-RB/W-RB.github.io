<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏花盛开，佑浅浅而归</title>
  
  <subtitle>夏佑随记</subtitle>
  <link href="http://summace.cc/atom.xml" rel="self"/>
  
  <link href="http://summace.cc/"/>
  <updated>2023-08-04T04:27:27.984Z</updated>
  <id>http://summace.cc/</id>
  
  <author>
    <name>夏佑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新博客</title>
    <link href="http://summace.cc/NewBlog/"/>
    <id>http://summace.cc/NewBlog/</id>
    <published>2023-08-03T00:00:00.000Z</published>
    <updated>2023-08-04T04:27:27.984Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="出错。">  <script id="hbeData" type="hbeData" data-hmacdigest="0381dbdcc26eee56f4cd48c68ac764550b8d8348224dee3a32b44da00c6535ea">4630436162ade97ba2718b7d0c4b3b6377abd193e61de69559b7b58c5eb066f0b3fff512a5e27adcde7972cde5dee91410685dbcb80dbc851910b01340c23ec98fe2c935c79397b786bab884fca09e0f8b9a25259c0a727c10e962939a586534d92e3736311d5416e2de6884b6709199a748f52a253abd531cb12a2d8575690607a3c1f3286facc6fe4848e36c9f830e82ed009003aa969a0904c80511b01b446bad9600457c2e1b901716156cb31f1bd1625c25457a1bb94c6d6a1fc839c1e5ff96dca7d00be7e58dde54751d89aed7a771902e4dd4e836f84f8d31de7f7eff499481deb962946fdce823ad5c854116aa716715fbb835215a83b3d0b4e75c0c768090b5a68f2b409a6fb12957dd9720ddd2e6104361812839dfb74e8da7609fcd65ca7ab2e38eacc85dda5d4dcf72fc158ded5c7440d3481ef92a58bd0c80d402149de07b74499e808d3333e2440f70fa5a275b3610c2a9e8d35496a1af225db96e936709ac09a09907fa879b8663cc64155cca84446f0570fde9c02732ba78f9dd6492b567eaaa154d93bf19234b853b95555d8c1a7140e3c2749b0d80e98035bb637aeee92e770ab8780ffb6d2d4bc030f7137de2868d716ec413c0c72296fda66a37253ce3871bed9d8a0f2c84b597594a536d4855cdbbc2259e44960d4070b5f40adf75b562f76267ec5c6ed0eea3eb13c2b339794ca5a439d5c32ff1ef653fcea15e4ff081a6d5077eb52c78498f452b8f701d7c7526742ff40fa04925f32d22c5aeb62e478463f74507ad99e4f5cb9adb8c7e233341953348d54752562f0bc932a2961fd3e3bfb9168be9095450c45203329c0fd4340e15c358dab7a14aa15e4c51a85395e082110664bfd7ba3e191cd91b1fba98fecfc6c9ff838abaf03be2a3e1ea7a05edc45192afd11df8feda95cb246e12ee44b521ee464ab076a6e6de235f1f81dd06ed10abe5194945bc3b87a957f3c9ae4448bf09ae77ce79b02469d31ad322be7c205d1506f62c0f858d7903767c3f7b63208d0d2d0d899dbc42cbe673064e4b27c55f35b492e477f23360b482cb15913d6389feb678c5387a9d73d9b09a0056632407e9f256db4a8da8dae246b0d05c86d065a186d0ca37e216eed03edee73f34e24c9c67d4c5f4f689d65ac1574d2c1c3cc1c378044deeac9210efa5a6f45bb56be48996c48dc519d0b02bc0251e4c1591cf2027a4f1ab53dcd7d531544a252999bab8298e7d3363d4e506daaae0d6645a5769a2fb50f9deb16ec1362d7b5953fdf6ce8a3b225c6d7e8546b59c269e264f593f98f10583c46391b7349d1e28ba7eff3a3b879850eefbfcf855eddc5eda52f767d6655cf61c8fd3784ac53a8bdd80922ab2984b7d45a4d2bcb4ac12e41ca839114924d048a3294286d25ba73a83f85c0ce4ee7c162d05c893c7d4b17b2a6d64354c92d0e8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">123456</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这篇文章被密码保护。</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线性代数学习笔记</title>
    <link href="http://summace.cc/Linear-Algebra/"/>
    <id>http://summace.cc/Linear-Algebra/</id>
    <published>2023-08-02T00:00:00.000Z</published>
    <updated>2023-08-03T13:12:20.475Z</updated>
    
    <content type="html"><![CDATA[<p>学数论学自闭了，感觉线性代数还可以。</p><p>供自己复习用。</p><span id="more"></span><h1 id="矩阵">矩阵</h1><p>一个具有 <span class="math inline">\(n\)</span> 行 <spanclass="math inline">\(m\)</span> 列元素的矩形阵列，形如：</p><p><span class="math display">\[A=\begin{bmatrix}    a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,m}\\    a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; a_{2,m}\\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    a_{n,1} &amp; a_{n,2} &amp; \cdots &amp; a_{n,m}\\\end{bmatrix}\]</span></p><ul><li>主对角线：<span class="math inline">\(A_{i,i}\)</span> 的元素。</li><li>单位矩阵：主对角线为 <span class="math inline">\(1\)</span>，其余为<span class="math inline">\(0\)</span> 的矩阵，记为 <spanclass="math inline">\(I\)</span>。</li><li>方阵：行数和列数相等的矩阵。</li><li>同型矩阵：行数和列数分别相等的矩阵。</li></ul><h2 id="矩阵的运算">矩阵的运算</h2><h3 id="矩阵的加减">矩阵的加减</h3><p>只有同型矩阵才可以加减，直接将对应位置加减即可。</p><h3 id="转置矩阵">转置矩阵</h3><p>将矩阵行列互换，记作 <span class="math inline">\(A^{T}\)</span>。</p><h3 id="矩阵乘法">矩阵乘法</h3><p>设 <span class="math inline">\(A\)</span> 是 <spanclass="math inline">\(N \times K\)</span> 的矩阵，<spanclass="math inline">\(B\)</span> 是 <span class="math inline">\(K\timesM\)</span> 的矩阵，则乘积 <span class="math inline">\(C\)</span>为：</p><p><span class="math display">\[C_{i,j}=\sum\limits_{i=1}^KA_{i,k}B_{k,j}\]</span></p><h3 id="方阵的逆">方阵的逆</h3><p>若有方阵 <span class="math inline">\(P\)</span> 使方阵 <spanclass="math inline">\(A\times P=I\)</span>，则称方阵 <spanclass="math inline">\(P\)</span> 为方阵的逆矩阵。</p><p>逆矩阵不一定存在。</p><h1 id="行列式">行列式</h1><h2 id="积和式">积和式</h2><p>方阵 <span class="math inline">\(A\)</span>的积和式为不同行不同列所有排列 <span class="math inline">\(p_i\)</span>的乘积之和。显然，这样的排列有 <span class="math inline">\(n!\)</span>个。</p><h2 id="行列式-1">行列式</h2><p>在积和式的基础上，记 <span class="math inline">\(\pi_i\)</span> 为<span class="math inline">\(p_i\)</span> 的逆序对个数，那么对于每个<span class="math inline">\(p_i\)</span> 乘积，累加时赋上符号，若 <spanclass="math inline">\(\pi_i\)</span> 为偶数，则为正，否则为负。</p><p><span class="math display">\[\det(A)=\sum\limits_{i=1}^{n!}(-1)^{\pi_i}\prod\limits_{j=1}^{n}p_{i,j}\]</span></p><p>一些性质：</p><ul><li>转置矩阵的行列式不变。</li><li>交换任意两行（列）行列式取反。</li><li>某一行（列）乘 <span class="math inline">\(k\)</span>，行列式乘<span class="math inline">\(k\)</span>。</li><li>某一行整体加上另一行，行列式不变。</li></ul><h2 id="伴随矩阵">伴随矩阵</h2><h3 id="余子式">余子式</h3><p>矩阵 <span class="math inline">\(A\)</span> 第 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的余子式：</p><p><span class="math display">\[M_{i,j}=\det A&#39;_{i,j}\]</span></p><p>其中 <span class="math inline">\(A&#39;_{i,j}\)</span> 表示删除矩阵<span class="math inline">\(A\)</span> 第 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列后所得矩阵。</p><h3 id="代数余子式">代数余子式</h3><p>矩阵 <span class="math inline">\(A\)</span> 第 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的代数余子式：</p><p><span class="math display">\[C_{i,j}=(-1)^{i+j}M_{i,j}\]</span></p><h3 id="伴随矩阵-1">伴随矩阵</h3><p>矩阵 <span class="math inline">\(A\)</span> 的伴随矩阵 <spanclass="math inline">\(\text{adj} A\)</span> 为 <spanclass="math inline">\(A\)</span> 的余子矩阵的转置矩阵。</p><p><span class="math display">\[\text{adj} A=C^{T}\]</span></p><h3 id="可逆矩阵">可逆矩阵</h3><p>对于可逆矩阵，<span class="math inline">\(A^{-1}=\dfrac{\text{adj}A}{\det A}\)</span>。</p><p>若矩阵不可逆，则 <span class="math inline">\(\det A=0\)</span>。</p><h1 id="线性空间">线性空间</h1><p>若代数系统 <spanclass="math inline">\((V,+,\cdot,\mathbb{P})\)</span> ，其中 <spanclass="math inline">\(V\)</span> 为向量集，<spanclass="math inline">\((V,+)\)</span> 为阿贝尔群，<spanclass="math inline">\(\mathbb{P}\)</span> 为域，<spanclass="math inline">\(\cdot\)</span> 为数乘运算，满足以下条件：</p><ol type="1"><li>数乘：<span class="math inline">\(\mathbb{P}\)</span> 中元素 <spanclass="math inline">\(p\)</span> 与 <spanclass="math inline">\(V\)</span> 中元素 <spanclass="math inline">\(v\)</span> 运算结果 <spanclass="math inline">\(pv\)</span> 在 <spanclass="math inline">\(V\)</span> 中，且有意义，且满足封闭性。</li><li>数乘对向量和标量都满足加法分配律。</li><li>数乘满足结合律。</li><li>存在标量乘法单位元。</li></ol><p>则称其为线性空间。</p><h2 id="线性相关与线性无关">线性相关与线性无关</h2><p>若向量组 <span class="math inline">\(a_i \in V\)</span> 和任意标量组<span class="math inline">\(k_i\in \mathbb{P}\)</span> 满足 <spanclass="math inline">\(\sumk_ia_i=\theta\)</span>，则称这组向量线性无关，否则称线性相关。</p><p>零向量与任意向量线性相关。</p><h2 id="线性基">线性基</h2><p>线性空间 <span class="math inline">\(V\)</span>的一个极大线性无关组称为 <span class="math inline">\(V\)</span>的一组<strong>线性基</strong>，简称基。</p><p><span class="math inline">\(V\)</span> 的维数记为 <spanclass="math inline">\(\dim V\)</span>，为线性基元素个数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学数论学自闭了，感觉线性代数还可以。&lt;/p&gt;
&lt;p&gt;供自己复习用。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP算法与border浅记</title>
    <link href="http://summace.cc/KMP/"/>
    <id>http://summace.cc/KMP/</id>
    <published>2023-08-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:09:54.600Z</updated>
    
    <content type="html"><![CDATA[<p>终于完全明白了困扰多年的 KMP 算法，果然从 border理论理解才是最好的。</p><p>因此写下本文，供自己复习。</p><span id="more"></span><h1 id="border">border</h1><p>首先给出 <span class="math inline">\(\text{border}\)</span>的定义：在字符串 <span class="math inline">\(S\)</span>中，最长的<strong>真</strong>公共前后缀。</p><p>显然，<span class="math inline">\(\text{border}\)</span> 的 <spanclass="math inline">\(\text{border}\)</span> 也是 <spanclass="math inline">\(S\)</span> 的一个 <spanclass="math inline">\(\text{border}\)</span>。</p><p>我们定义 <span class="math inline">\(\text{nxt}[i]\)</span> 为 <spanclass="math inline">\(S[1\dots i]\)</span> 的 <spanclass="math inline">\(\text{border}\)</span>，考虑如何快速求 <spanclass="math inline">\(\text{nxt}\)</span>。</p><p>假设我们现在已知 <span class="math inline">\(\text{nxt}[1\dotsn]\)</span>，想要求出 <spanclass="math inline">\(\text{nxt}[n+1]\)</span>。</p><p>考虑 <span class="math inline">\(S[n+1]\)</span> 和 <spanclass="math inline">\(S[\text{nxt}[n]+1]\)</span>是否匹配。如果匹配，那么显然。 <spanclass="math inline">\(\text{nxt}[n+1]=\text{nxt}[n]+1\)</span>，否则我们继续考虑它是否可以和<span class="math inline">\(\text{nxt}[\text{nxt}[n]]\)</span>匹配。我们一直匹配到成功即可。</p><p>这样可以均摊 <span class="math inline">\(O(n)\)</span> 求出 <spanclass="math inline">\(\text{nxt}\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&quot; &quot;</span> + S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nxt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = S.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; S[i] != S[j + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(S[i] == S[j + <span class="number">1</span>] &amp;&amp; j + <span class="number">1</span> &lt; i) nxt[i] = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kmp">KMP</h1><p><span class="math inline">\(\text{KMP}\)</span>是用来快速匹配字符串的算法。</p><p>给定模式串 <span class="math inline">\(S\)</span>，文本串 <spanclass="math inline">\(T\)</span>，求 <spanclass="math inline">\(S\)</span> 在 <spanclass="math inline">\(T\)</span> 中所有匹配。</p><p>记 <span class="math inline">\(S\)</span> 长度为 <spanclass="math inline">\(s\)</span>，<span class="math inline">\(T\)</span>长度为 <span class="math inline">\(t\)</span>。</p><p>我们将 <span class="math inline">\(S\)</span> 和 <spanclass="math inline">\(\#\)</span> 和 <spanclass="math inline">\(T\)</span> 拼在一起，形成了 <spanclass="math inline">\(S\#T\)</span> 的新字符串。我们求出来这个字符串的<span class="math inline">\(\text{nxt}\)</span>。</p><p>之后我们从 <span class="math inline">\(s+1\)</span> 开始（即从 <spanclass="math inline">\(T\)</span> 开始）遍历 <spanclass="math inline">\(\text{nxt}\)</span>。如果 <spanclass="math inline">\(\text{nxt}[i] =s\)</span>，那么这是一个成功的匹配。</p><p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于完全明白了困扰多年的 KMP 算法，果然从 border
理论理解才是最好的。&lt;/p&gt;
&lt;p&gt;因此写下本文，供自己复习。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线段树浅记</title>
    <link href="http://summace.cc/Segment-Tree/"/>
    <id>http://summace.cc/Segment-Tree/</id>
    <published>2023-07-23T00:00:00.000Z</published>
    <updated>2023-08-03T13:13:11.434Z</updated>
    
    <content type="html"><![CDATA[<p>系统复盘了一下线段树，发现网上现有博客鲜有将线段树各种操作一步一步讲明白的，故结合自己理解写此文。</p><p>应该会持续更新。</p><span id="more"></span><h1 id="线段树">线段树</h1><p>先来看一个经典问题：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 x v</code>：给 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>。 <code>2 l r</code>：查询区间<span class="math inline">\([l,r]\)</span> 的和。 <spanclass="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>考虑最朴素的暴力：对于 <span class="math inline">\(1\)</span>操作，直接在数组上更改。对于每次 <span class="math inline">\(2\)</span>操作，我们暴力遍历一遍整个数组。这样单次修改复杂度是 <spanclass="math inline">\(O(1)\)</span>，但是查询复杂度是 <spanclass="math inline">\(O(n)\)</span>，最坏时间复杂度 <spanclass="math inline">\(O(nq)\)</span>，比较爆炸。</p><p>线段树作为一种基础的高级数据结构，具有单次修改、查询均为 <spanclass="math inline">\(O(\log n)\)</span>的优秀复杂度。这时候运用线段树，就比较好解决这个问题了。</p><h2 id="结构">结构</h2><p>我们先来说一下线段树的结构。</p><figure><img src="https://oi-wiki.org/ds/images/segt1.svg" alt="线段树" /><figcaption aria-hidden="true">线段树</figcaption></figure><p>（图源<a href="https://oi-wiki.org/ds/seg/">OI-Wiki</a>）</p><p>考虑现在有一段长度为 <span class="math inline">\(5\)</span> 的区间<span class="math inline">\([1,5]\)</span>，我们递归地每次分成两半。</p><p>第一层：<span class="math inline">\([1,5]\)</span>，第二层：<spanclass="math inline">\([1,3],[4,5]\)</span>，以此类推……</p><p>现在 <span class="math inline">\(d_1\)</span> 就记录着区间 <spanclass="math inline">\([1,5]\)</span> 的信息，<spanclass="math inline">\(d_2\)</span> 记录着 <spanclass="math inline">\([1,3]\)</span>的信息，以此类推。这个信息可以是多种多样的，根据本题的题意，我们可以记录“区间和”这个信息。此时，<spanclass="math inline">\(d_1\)</span> 就表示着区间 <spanclass="math inline">\([1,5]\)</span> 的和为 <spanclass="math inline">\(60\)</span>。</p><p>显然，我们现在的 <span class="math inline">\(d\)</span>数组构成了一个二叉树型结构，<span class="math inline">\(d_1\)</span>的儿子是 <span class="math inline">\(d_2\)</span> 和 <spanclass="math inline">\(d_3\)</span>，<spanclass="math inline">\(d_2\)</span> 的儿子是 <spanclass="math inline">\(d_4\)</span> 和 <spanclass="math inline">\(d_5\)</span>。那么根据二叉树的性质，我们很容易可以知道，若父亲节点的编号是<span class="math inline">\(k\)</span>，那么它的左儿子的节点编号应该是<span class="math inline">\(2k\)</span>，右儿子的节点编号应该是 <spanclass="math inline">\(2k+1\)</span>。</p><p>这样，一颗线段树的基本结构就出来了。</p><p>考虑一下我们需要维护哪些信息？首先，区间和 <spanclass="math inline">\(sum\)</span>。其次，我们需要维护当前节点所维护区间的左右端点<span class="math inline">\(l,r\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[MAXN &lt;&lt; <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>哎？你这个 <span class="math inline">\(tr\)</span> 数组怎么开了 <spanclass="math inline">\(4\)</span> 倍的空间啊？</p><p>我们考虑这颗线段树的结构，一个长度为 <spanclass="math inline">\(n\)</span> 的区间最多可以有 <spanclass="math inline">\(\log(n)\)</span> 层。求和的结果近似于 <spanclass="math inline">\(4n\)</span>，因此需要开够 <spanclass="math inline">\(4\)</span> 倍空间。</p><blockquote><p>注：无特殊说明外，本文 <span class="math inline">\(\log\)</span> 均为<span class="math inline">\(\log_2\)</span>。</p></blockquote><h2 id="信息的上传">信息的上传</h2><p>然而，我们现在的线段树只是一颗线段树，跟原来的序列没有啥关系啊？</p><p>考虑这颗线段树的叶子节点。我们发现叶子节点维护的区间都只有一个数，那么这个就对应着我们原序列的值。也就是说，左右端点均为<span class="math inline">\(i\)</span> 的线段树节点，其区间和就是 <spanclass="math inline">\(a_i\)</span> 的值。</p><p>然后我们需要让整棵树都维护正确的信息，这时候就需要我们把信息由下到上地更新。我们记载的信息是区间和，那么显然，父亲节点的信息就是儿子节点信息之和，也就是说：<spanclass="math inline">\(tr[k].sum=tr[ls(k)].sum+tr[rs(k)].sum\)</span>。</p><blockquote><p>注：下文将用 <span class="math inline">\(tr\)</span> 代替 <spanclass="math inline">\(d\)</span>。</p></blockquote><p>这里的 <span class="math inline">\(ls(k) = 2k, rs(k) =2k+1\)</span>，分别表示了当前节点的左右儿子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="comment">//常用技巧，使用#define会让你的代码更美丽</span></span><br><span class="line"><span class="comment">//根据基本的位运算常识，k&lt;&lt;1=2k, k&lt;&lt;1|1=2k+1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].sum = tr[ls].sum + tr[rs].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建树">建树</h2><p>著名感情学家鸭子曾经说过：我们要有所建树。不建树是一个线段树题目中常见的**错误。</p><p>考虑我们是怎么讲述一颗线段树的结构的？<spanclass="math inline">\(d_1\)</span>记录着整个区间的信息，然后每次将区间分成两半，分别记录着左右两半区间的信息……</p><p>那么参照这个思想，我们就可以建树了。从 <spanclass="math inline">\(d_1\)</span>出发，依次建立左右儿子的初始信息，然后 <spanclass="math inline">\(pushup\)</span>，把下层的节点信息上传到上层。对于叶子节点，此时显然一定有<span class="math inline">\(tr[k].l=tr[k].r\)</span>，<spanclass="math inline">\(tr[k].sum=a[l]\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[k].l = l;</span><br><span class="line">    tr[k].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度显然 <span class="math inline">\(O(n)\)</span>。</p><h2 id="单点修改">单点修改</h2><p>好了，现在树也建好了，是时候干点操作相关的事情了。单点修改！</p><p>这个东西有点像二分。由于我们只修改一个点，那么我们只需要每次看看这个点在左右两半区间的那边，然后一直到叶子的时候把它修改了，再更新一下整棵树就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[k].l == tr[k].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">update</span>(ls, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们最多跳 <span class="math inline">\(\log(n)\)</span>次，因此单点修改的时间复杂度是 <span class="math inline">\(O(\logn)\)</span> 的。</p><h2 id="区间查询">区间查询</h2><p>那么接下来解决最后一个问题：区间查询。</p><figure><img src="https://oi-wiki.org/ds/images/segt1.svg" alt="线段树" /><figcaption aria-hidden="true">线段树</figcaption></figure><p>再看一眼这张图。如果我们要查询区间 <spanclass="math inline">\([2,5]\)</span>的值，那么比较理想的状态应该是什么？</p><p>应该是，我们每次找到可以被询问区间包含的<strong>极大</strong>区间，最后将所有区间的信息相加。</p><p>太抽象了？让我们具体看看。</p><p>从第一层开始：<span class="math inline">\([1,5]\)</span>的信息显然太大了，我们用不了，那么往下面找。</p><p>现在我们有区间 <span class="math inline">\([1,3]\)</span> 和 <spanclass="math inline">\([4,5]\)</span> 的信息。我们发现 <spanclass="math inline">\([2,5]\)</span> 完全包含 <spanclass="math inline">\([4,5]\)</span>，也就是说 <spanclass="math inline">\([4,5]\)</span>的信息可以被我们利用，那么就算上它的区间和。那啥叫极大呢？我们发现利用<span class="math inline">\([4,5]\)</span> 的信息显然比分别利用 <spanclass="math inline">\([4,4]\)</span> 和 <spanclass="math inline">\([5,5]\)</span>要更优。意思就是：我们能用父亲的信息，就不用儿子的信息。</p><p>继续，我们现在还差 <span class="math inline">\([2,3]\)</span>的信息没解决。由于右边已经完成了，那么我们直接在左边找就可以。第三层是<span class="math inline">\([1,2]\)</span> 和 <spanclass="math inline">\([3,3]\)</span>，其中我们可以用 <spanclass="math inline">\([3,3]\)</span> 的信息，把它加上。</p><p>然后我们继续往下找，发现了 <span class="math inline">\([1,1]\)</span>和 <span class="math inline">\([2,2]\)</span>，其中我们可以利用 <spanclass="math inline">\([2,2]\)</span> 的信息，那就把它加上。</p><p>最后，我们发现区间 <span class="math inline">\([2,5]\)</span>实际上被拆成了 <span class="math inline">\([2,2] \cup [3,3]\cup[4,5]\)</span>，我们所求的答案自然就是这几个节点的信息之和。</p><p>那么考虑一下我们应该怎么写代码：如果当前节点的区间被询问区间完全包含，那么直接加上这个区间的信息。否则，如果查询区间的左端点在左儿子内，就到左儿子内中继续查询；如果查询区间的右端点在右儿子内，就到右儿子内中继续查询。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[k].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += <span class="built_in">query</span>(ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += <span class="built_in">query</span>(rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来分析一下时间复杂度：由于线段树只有 <spanclass="math inline">\(\log(n)\)</span> 层，那么我们也只需要询问 <spanclass="math inline">\(O(\log n)\)</span> 次，单次区间查询时间复杂度是<span class="math inline">\(O(\log n)\)</span>。</p><h2 id="区间修改与懒标记">区间修改与懒标记</h2><p>那么现在我们把这个问题进阶一下：</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 l r v</code>：给区间 <span class="math inline">\([l,r]\)</span>的每个元素加上 <span class="math inline">\(v\)</span>。<code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span>的和。 <span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>现在，我们由单点修改变成了区间修改。</p><p>问题在哪？我们每次修改，如果一个区间被修改区间包含，那么以它为根的整棵子树都要被修改，时间复杂度到了<span class="math inline">\(O(n)\)</span>，这是我们无法接受的。</p><p>哎？同样是涉及到区间，那为啥区间查询的复杂度很对，但是区间修改就很寄呢？</p><p>我们发现，区间查询的时候，如果一个节点被用到了，那么它的儿子就不会在被查询，因此时间复杂度可以到<span class="math inline">\(O(\logn)\)</span>。那我们能不能类比区间查询，让区间修改也这样呢？</p><p>这个时候就需要懒标记(lazy tag)出场了。</p><p>懒标记，顾名思义，是为了偷懒用的标记。</p><p>怎么偷懒呢？当我们遇到一个被修改区间完全包含的区间的时候，我们就给这个节点打上一个标记，意思是：我这个节点的后代应该被这个标记影响，但是我现在先不往下传。<del>（我知道你很急，但是你先别急）</del>到我什么时候要用到这个节点的后代的时候，我再把标记传下去。</p><p>这样的话，我们就可以保证区间修改的时间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>。</p><p>那么具体怎么实现呢？</p><p>当我们区间修改遇到一个整的区间时，我们选择仅更改当前的节点的值，并给它打上懒标记。以区间和为例，我们更改当前节点的值显然应当是<spanclass="math inline">\(v*(tr[k].r-tr[k].l+1)\)</span>，此时我们把当前节点的<span class="math inline">\(tag\)</span> 加上 <spanclass="math inline">\(v\)</span>，表示我后面的后代应当被加 <spanclass="math inline">\(v\)</span>。</p><p>然后我们想想怎么把标记下放。显然我们只需要把标记分别赋给他的两个儿子，然后把当前节点的标记清零就可以了。考虑一下，那些操作需要把标记下放？</p><p>由于需要用到后代的操作都需要下方，所以显然查询和修改都需要提前下放标记。显然，标记的下放必须在操作之前。</p><p>那么我们就可以开始写代码了。首先先单独写一个下放标记的函数<code>pushdown</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[ls].tag += tr[k].tag;</span><br><span class="line">    tr[rs].tag += tr[k].tag;</span><br><span class="line">    tr[ls].sum += (tr[ls].r - tr[ls].l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    tr[rs].sum += (tr[rs].r - tr[rs].l + <span class="number">1</span>) * tr[k].tag;</span><br><span class="line">    tr[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在更新一下查询和修改的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[k].sum += (tr[k].r - tr[k].l + <span class="number">1</span>) * v;</span><br><span class="line">        tr[k].tag += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[k].l &amp;&amp; tr[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[k].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (tr[k].l + tr[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += <span class="built_in">query</span>(ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += <span class="built_in">query</span>(rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线段树的进阶用法">线段树的进阶用法</h1><p>目前我们已经解决了线段树维护区间和的问题。线段树维护区间极值也很简单，只需要在原来的代码上稍作修改即可。但是，作为十分美丽的数据结构，线段树可以维护的东西远不止这些。接下来让我们看看线段树更为进阶的用法。</p><h2 id="维护区间平方和">维护区间平方和</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 l r v</code>：给区间 <span class="math inline">\([l,r]\)</span>的每个元素加上 <span class="math inline">\(v\)</span>。<code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span>的平方和，即 <spanclass="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>。 <spanclass="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这时候就需要我们思考，线段树要维护某些东西具体需要改什么。</p><p>原本有一段需要修改的区间 <span class="math inline">\(a_l, a_{l+1},..., a_r\)</span>。我们需要维护的东西是 <spanclass="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>。</p><p>考虑我们现在对这段东西整体加上 <spanclass="math inline">\(v\)</span>，那么我们的答案就变成了 <spanclass="math inline">\(\sum\limits_{i=l}^{r}(a_i+v)^2\)</span>。</p><p>运用我们初中就学过的完全平方公式：</p><p><span class="math inline">\(\sum\limits_{i=l}^{r}(a_i+v)^2 =\sum\limits_{i=l}^{r}(a_i^2+2a_iv+v^2) =\sum\limits_{i=l}^{r}a_i^2+2v\sum\limits_{i=l}^{r}a_i+(r-l+1)v^2\)</span></p><p>我们发现前面的 <spanclass="math inline">\(\sum\limits_{i=l}^{r}a_i^2\)</span>就是我们原先的值，而最后的 <spanclass="math inline">\((r-l+1)v^2\)</span> 可以直接算出来，中间的 <spanclass="math inline">\(2v\sum\limits_{i=l}^{r}a_i\)</span>只需要多维护一个区间和就可以了。</p><p>那么，这道题我们就需要维护两个值：区间平方和、区间和。修改的时候按照公式中的修改即可。</p><p>思考：区间方差。</p><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 l r v</code>：给区间 <span class="math inline">\([l,r]\)</span>的每个元素加上 <span class="math inline">\(v\)</span>。<code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span>的方差。 方差：<spanclass="math inline">\(\sigma^2=\dfrac{1}{n}\sum\limits_{i=1}^{n}(x_i-\overlinex)^2\)</span> <span class="math inline">\(1\leq n,q\leq10^5\)</span>。</p></blockquote><h2 id="区间乘与区间加">区间乘与区间加</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 l r v</code>：给区间 <span class="math inline">\([l,r]\)</span>的每个元素加上 <span class="math inline">\(v\)</span>。<code>2 l r v</code>：给区间 <span class="math inline">\([l,r]\)</span>的每个元素乘上 <span class="math inline">\(v\)</span>。<code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span>的和。 <span class="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这不好做？我直接开两个 <spanclass="math inline">\(tag\)</span>，分别维护加法和乘法懒标记，结果一合并不就行了！</p><p>等等，你先别急。你乘法和加法分别统计真的对吗？</p><p>例如，我们当前的数是 <spanclass="math inline">\(2\)</span>，对当前的数分别 <spanclass="math inline">\(\times 3,+2,\times 4\)</span>，答案应当是 <spanclass="math inline">\((2\times 3+2)\times4=32\)</span>。但是如果我们分别计算 <spanclass="math inline">\(multitag=3\times4=12,plustag=2\)</span>，答案就会变成 <spanclass="math inline">\(2\times12+2=26\)</span> 或者 <spanclass="math inline">\((2+2)\times 12=48\)</span>。</p><p>这是因为我们加法和乘法之间是有运算顺序的，因此我们不能简单地直接计算。</p><p>那有没有什么办法呢？当然有！我们在小学就学过一个伟大的东西，叫做乘法的分配律！</p><p>假设我们当前的节点有 <span class="math inline">\(multitag\)</span> 和<span class="math inline">\(plustag\)</span> 两个 <spanclass="math inline">\(tag\)</span>，那么当前节点的值应当是 <spanclass="math inline">\((x\timesmultitag+plustag)\)</span>，现在对这个节点进行 <spanclass="math inline">\(\times v\)</span> 的操作就会变成 <spanclass="math inline">\((x\times multitag+plustag)\times v=x\timesmultitag\times v + plustag\times v\)</span>。</p><p>于是，我们正常维护 <spanclass="math inline">\(multitag\)</span>，并且额外更新 <spanclass="math inline">\(plustag\)</span>，这样就可以了。</p><h2 id="区间开根">区间开根</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 l r v</code>：令区间 <span class="math inline">\([l,r]\)</span>的每个元素 <span class="math inline">\(x\)</span> 变成 <spanclass="math inline">\(\lfloor\sqrt{x}\rfloor\)</span>。<code>2 l r</code>：查询区间 <span class="math inline">\([l,r]\)</span>的和。 <span class="math inline">\(1\leq n,q\leq 10^5,1\leq a_i\leq10^{18}\)</span>。</p></blockquote><p>有没有发现这次的题目多了一个数据范围？</p><p>既然 <span class="math inline">\(a_i\leq10^{18}\)</span>，我们发现<strong>至多进行 <spanclass="math inline">\(6\)</span> 次 <spanclass="math inline">\(1\)</span> 操作</strong>，当前的数就会变成 <spanclass="math inline">\(1\)</span>。变成 <spanclass="math inline">\(1\)</span> 之后自然之后的操作都是无效的操作。</p><p>那么，我们在更改的时候可以暴力更改当前区间的数，并记录当前区间的最大值。如果最大值小于等于<spanclass="math inline">\(1\)</span>，那么就可以停止这个区间的更改了。</p><p>这样，查询的复杂度是不变的单次 <span class="math inline">\(O(\logn)\)</span>，我们来分析一下修改的时间复杂度。</p><p>不将值域局限在 <span class="math inline">\(10^{18}\)</span>内，我们考虑一个数会被更改多少次：</p><p><spanclass="math inline">\(a^{\left(\frac{1}{2}\right)^x}&lt;2\)</span>。</p><p>这是一个两层不等式，想得到 <span class="math inline">\(x\)</span>我们需要取两次对数，因此我们每个数最多会被更改 <spanclass="math inline">\(O(\log\log a)\)</span> （<spanclass="math inline">\(a\)</span> 为 <spanclass="math inline">\(a_i\)</span>的最大值）次。考虑我们暴力更改就相当于是单点修改，那么每对一个元素修改的复杂度就是<span class="math inline">\(O(\log n)\)</span> 的。我们一共有 <spanclass="math inline">\(n\)</span> 个元素，每个元素修改一次的复杂度是<span class="math inline">\(O(\log n)\)</span>，每个元素最多会被更改<span class="math inline">\(O(\log\log a)\)</span>次，那么，总的时间复杂度就是 <span class="math inline">\(O(n\logn\log\log a)\)</span>。单次的复杂度均摊是 <spanclass="math inline">\(O(\log n\log\log a)\)</span>的。可以通过本题。</p><h2 id="维护前前缀和">维护前前缀和</h2><blockquote><p>前缀和：<spanclass="math inline">\(S_i=\sum\limits_{k=1}^{i}a_k\)</span>；前前缀和：<spanclass="math inline">\(SS_i=\sum\limits_{k=1}^{i}S_i\)</span>。 给定序列<span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 x v</code>：将 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>。 <code>2 x</code>：查询 <spanclass="math inline">\(SS_x\)</span>。 <span class="math inline">\(1\leqn,q\leq 10^5\)</span>。</p></blockquote><p>我们现在有三个数组：原数组 <spanclass="math inline">\(a\)</span>，前缀和数组 <spanclass="math inline">\(S\)</span>，前前缀和数组 <spanclass="math inline">\(SS\)</span>。</p><p>对于 <span class="math inline">\(1\)</span> 操作，我们要用到的是<span class="math inline">\(a\)</span>。对于 <spanclass="math inline">\(2\)</span> 操作，我们要用到的是 <spanclass="math inline">\(SS\)</span>。那么，我们为什么不选择一个中间商<del>赚个差价</del>方便我们对两边都能维护到呢？</p><p>因此，我们可以维护前缀和数组 <spanclass="math inline">\(S\)</span>，对于操作 <spanclass="math inline">\(2\)</span>，答案即是从 <spanclass="math inline">\(1\)</span> 开始的区间和。对于操作 <spanclass="math inline">\(1\)</span>，我们只需要让从当前位置开始到 <spanclass="math inline">\(n\)</span> 的区间加上 <spanclass="math inline">\(v\)</span> 即可。</p><h2 id="区间加等差数列">区间加等差数列</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 l r d k</code>：令区间 <spanclass="math inline">\([l,r]\)</span> 的每个元素 <spanclass="math inline">\(a_i\)</span> 加上以 <spanclass="math inline">\(d\)</span> 为首项、<spanclass="math inline">\(k\)</span> 为公差的等差数列 <spanclass="math inline">\(\{c\}\)</span> 的 <spanclass="math inline">\(c_i\)</span>。 <code>2 l r</code>：查询区间 <spanclass="math inline">\([l,r]\)</span> 的和。 <spanclass="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>区间加的数不是同一个数，怎么办？</p><p>考虑一下等差数列的性质。我们没有必要知道每一个数是什么，我们只需要知道首项和公差，就可以推出数列的任意一项以及数列的和。那我们不妨用线段树维护加的等差数列的首项和公差。</p><h2 id="维护区间最大子段和">维护区间最大子段和</h2><blockquote><p>给定序列 <span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(q\)</span> 次操作，每次操作诸如：<code>1 x v</code>：将 <span class="math inline">\(a_x\)</span> 加上<span class="math inline">\(v\)</span>。 <code>2 l r</code>：查询区间<span class="math inline">\([l,r]\)</span> 内的最大子段和。 <spanclass="math inline">\(1\leq n,q\leq 10^5\)</span>。</p></blockquote><p>这咋做？</p><p>线段树保证复杂度的关键一步是要保证可以快速、正确地合并。这题单点修改是容易的，关键在于如何让信息快速合并。</p><p>我们思考一下合并区间最大子段和时，可能有哪些情况：</p><ol type="1"><li>全部在左半区间。</li><li>全部在右半区间。</li><li>横跨左右区间。</li></ol><p>我们显然是要维护当前区间的最大子段和的。对于 <spanclass="math inline">\(1\)</span> 情况和 <spanclass="math inline">\(2\)</span> 情况，直接合并就可以了。关键是 <spanclass="math inline">\(3\)</span> 情况该如何合并。</p><p>我们考虑横跨左右区间实际上就是左半区间右端点开始的区间最大子段和，和右半区间左端点开始的区间最大子段和合并。那我们不妨对每个节点多维护两个信息：以右端点开始的区间最大子段和（记作<spanclass="math inline">\(S[k]_r\)</span>），和以左端点开始的区间最大子段和（记作<spanclass="math inline">\(S[k]_l\)</span>）。这样，我们就可以做到快速算出区间最大子段和了。</p><p>不过问题在于，我们新维护的这两个值也需要考虑合并之后该怎么办。只考虑<span class="math inline">\(S[k]_l\)</span>，这个时候有两种情况：</p><ol type="1"><li><span class="math inline">\(S[k]_l\)</span> 是 <spanclass="math inline">\(S[ls(k)]_l\)</span>。</li><li><span class="math inline">\(S[k]_l\)</span>的右端点跨到了右区间，答案变成 <spanclass="math inline">\(sum_k+S[rs]_l\)</span>。</li></ol><p>而且只有这两种情况。（思考一下，为什么？）</p><p>现在所有问题已经解决，我们就可以快速维护了。</p><p>思考：<span class="math inline">\(1\)</span>操作改为区间加怎么做？</p><h1 id="线段树的本质">线段树的本质</h1><p>我们发现，线段树可以维护许多东西：区间和、区间极值……通过一些手法，我们也可以维护诸如区间最大子段和的东西。</p><p>那么，究竟什么样的信息才可以被维护呢？</p><p>首先，这个信息必须是<strong>可被快速合并的</strong>。其次，这个信息必须<strong>满足结合律</strong>。因为我们在合并的时候其实是并不关心信息之间的顺序的，这就要求其必须满足结合律。那么可以看出，这些信息实际上构成了一个半群。</p><p>以上情况都是在单点修改的时候。那么区间修改呢？为什么刚刚线段树维护区间最大子段和没办法区间修改呢？</p><p>在区间修改的时候，为了保证线段树复杂度的正确性，我们势必要引入标记。那么，这个标记也必须满足一定的性质。</p><p>首先，这个标记必须是<strong>可被快速合并的</strong>。其次，这个标记必须<strong>满足结合律</strong>。第三，这个标记必须<strong>可被快速作用到信息上</strong>。可以看出，标记实际上构成了一个幺半群。</p><p>因此，我们在考虑线段树维护某些东西的时候，一方面要考虑如何维护信息，另一方面要考虑如何维护标记。</p><p>有关更多这部分的内容，可以看<ahref="https://_rqy.blog.uoj.ac/blog/8105">_rqy的博客</a>。</p><h1 id="扫描线">扫描线</h1><p>具体来说，扫描线是一种思想，而不是一种数据结构。</p><p>扫描线比较经典的问题就是求矩形面积并了。</p><blockquote><p>给定若干四边平行于坐标轴的矩形。 求它们的面积并（重合部分只算一次）。<span class="math inline">\(n\leq 10^5\)</span>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;系统复盘了一下线段树，发现网上现有博客鲜有将线段树各种操作一步一步讲明白的，故结合自己理解写此文。&lt;/p&gt;
&lt;p&gt;应该会持续更新。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>SDOI2023&lt;br&gt;游记</title>
    <link href="http://summace.cc/SDOI2023/"/>
    <id>http://summace.cc/SDOI2023/</id>
    <published>2023-05-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:20.285Z</updated>
    
    <content type="html"><![CDATA[<p>体验省选。</p><span id="more"></span><h1 id="day--1">Day -1</h1><p>本来没想到可以来省选，毕竟 NOIP考的太拉了。甚至是正式选手，RMB-700。</p><p>周五中午从学校开润，下午到了平邑。</p><p>然后遇到了百年难得一遇的街区停电。</p><p>晚上去试机，Win7炸场，键盘拉跨，但是和美婷、庞队在一个考场，好耶。</p><h1 id="day1">Day1</h1><p><span class="math inline">\(8:00\)</span>就进考场了，先敲了线段树和快读，不知道能不能用上。</p><p><span class="math inline">\(8:30\)</span> 开考，先瞄一眼题目。T1看起来可做，T2 图论一眼弃，T3 应该能做。</p><p>于是开始写 T1。发现这不是萌萌题吗，省选怎么会出这么简单的题。<spanclass="math inline">\(9:17\)</span> 过了 <spanclass="math inline">\(3\)</span> 个样例，润润润。</p><p>然后就直接开始看T3。想了想，感觉暴力能写，于是开始写暴力，差不多写了两百多行，突然发现暴力思路是寄的。寄寄寄。</p><p>因为本来也没有希望进队，写出来一题感觉十分满足，于是就检查了下T1，一直到 <span class="math inline">\(13:00\)</span> 收卷。</p><p>然后学校统一安排了午饭。这真的是我在学校里吃过的有史以来最丰盛的一次。就是队伍非常long long，排了很久。</p><p>下午摆摆摆。</p><h1 id="day2">Day2</h1><p><span class="math inline">\(8:30\)</span> 开考，先瞄一眼题目。T1过河卒，感觉暴力可做。T2T3 看起来很难，先做 T1。</p><p>T1 的 <span class="math inline">\(20pts\)</span>是好拿的，很顺利拿下来了。</p><p>第二个 <span class="math inline">\(10pts\)</span> 就是红色和黑色1v1，手玩了半天没怎么会，先润。</p><p>然后发现第四个 <span class="math inline">\(20pts\)</span>是能拿的，于是敲了个大暴力。</p><p>T2 把最基本暴力分拿了。T3 想当然认为直接 <spanclass="math inline">\(1 0\)</span> 就行了，然后喜提 <spanclass="math inline">\(0pts\)</span>。</p><p>吃饭，润，美婷身份证丢了，于是陪着美婷润了两遍食堂-考场，很热。</p><p>然后就润回来了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;体验省选。&lt;/p&gt;</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>NOIP2022&lt;br&gt;爆零记</title>
    <link href="http://summace.cc/NOIP2022/"/>
    <id>http://summace.cc/NOIP2022/</id>
    <published>2022-12-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:13.975Z</updated>
    
    <content type="html"><![CDATA[<p>一次愉快的 NOIP，而又是与他们最后的诀别。</p><span id="more"></span><h1 id="day--8">Day -8</h1><p>由于 CSP-S 和高一的同学们脱轨了，因此乖乖回去学whk。本来以为没啥希望了，结果晚上 🍬一通电话通知居然能去了。非常惊讶。但是一段时间没学 OI了，感觉更菜了。就当是体验一下。</p><h1 id="day--7">Day -7</h1><p>要在下午 <span class="math inline">\(17:00\)</span> 之前到平邑，因此<span class="math inline">\(14:30\)</span>就要走。学校要求交艺术节作品，趁上午写了写结果写挂了，气急败坏。RP--。</p><p>然后下午睡了一路之后来到平邑，住在很豪华的全季酒店，感觉从来没住过如此豪华。酒店临着河（好像叫浚河，祊河支流），还算是河景房，环境非常优美。</p><p>睡得很安稳。</p><h1 id="day--6">Day -6</h1><p>上午 vp 了一下 CF，没切出 F，RP--。</p><p>题目里面有道题叫做 The Humanoid，是 ZTMY 歌名，RP++。</p><p>酒店居然有咖啡机。喝了一杯，好苦。</p><h1 id="day--5">Day -5</h1><p>写了几道线段树，感觉对线段树理解更深了一点。</p><p>写了几篇题解，但是发现自己换硬盘重装系统忘了把 Blog文件夹拷过来，只能等 m.2-&gt;usb 买来了在部署了，先写着。</p><p>鸭子可爱捏。</p><p>晚上和 <span class="citation" data-cites="chiptune">@chiptune</span>一起 vp 了一场 abc，没切出来 F，自闭了，RP--。</p><h1 id="day--4">Day -4</h1><p>下雨了。</p><p>测了下分院帽，Slytherin。</p><p>下午 vp 了一场 div4，本来想涨涨信心，结果没 AK，自闭了，RP--。</p><p>鸭子给了一首<ahref="https://music.163.com/#/song?id=557581315">好听的歌</a>，单循了，RP++。</p><p>感觉自己菜炸了，模板都不会了。</p><p>调整作息，<span class="math inline">\(22:00\)</span>就睡了，我真规律。</p><h1 id="day--3">Day -3</h1><p>上午敲了敲板子，愣神。</p><p>感觉自己没救了。</p><p>鸭子又给了一首<ahref="https://music.163.com/#/song?id=1347630432">好听的歌</a>，单循了，但是没有VIP，气得我满地乱爬。于是从 B 站下载音频上传到云盘，我真聪明。</p><p>写了个攒 RP 的程序，开始跑了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld, %lld, RP++\n&quot;</span>, i, <span class="built_in">clock</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梦神锐评：“你是真无聊。”</p><p>晚上头巨疼。不知道为什么。疼死我了。于是早早睡了。</p><p>有点后怕，别上考场再头疼。</p><h1 id="day--2">Day -2</h1><p>🍬 给了一场 GMOJ 的比赛，难炸了，只拿了 B 题 20pts 暴力分。</p><p>查询小w精神状态，结果为：就你还想打 NOIP？</p><p>出考场了，5考场。</p><p>测了一下 mbti，ENFJ-A。</p><p>下午被精度给整自闭了。但是美婷姐姐理我了，很开心，RP++。</p><p>写游记了。</p><h1 id="day--1">Day -1</h1><p>考前最后一天。上午意识到这一点有些紧张。</p><p>然后就肆无忌惮地摆了一天。看了看KMP、逆元，感觉还可以。</p><p>一直到晚上🍬开了个会，希望明天不要自闭吧。</p><p>鸭子请了一杯奶茶，芋泥+珍珠，很好喝。</p><p>领了前瞻的 300 原石，抽了一下，没想到 16抽就出了卢老爷，根据运气守恒定律，感觉明天会寄。</p><p>早点睡觉吧。还是有点紧张。</p><h1 id="day-1">Day 1</h1><p>早上六点起床，早饭没吃凉的，吃的不多，有点担心会不会饿。但是实际上并没有。</p><p>然后就坐（站）着大巴去 pyyz。终于见到 ss,lz1,lzy,zzk,lmt了，很开心。</p><p>带着手机去结果根本没查码。</p><p>上考场先把快读和对拍敲了，结果两个都没用到。</p><p>考试还有个小风波，一开始给的密码不对，后来又给了，导致拖后了十分钟，不过在后面补上了。没想到是双重密码，pdf的密码是一开始给的。</p><p>解压包的密码是 <code>biu#2019miss</code>，是不是在暗示错过了 2019年？（2019刚好疫情开始捏。）</p><p>pdf 的密码是 <code>solo@2022</code>，是不是暗示 2022年单身啊呜呜。</p><p>先看一遍题。T1 感觉可做，T2 是啥啊，名字倒是挺好听的。T3一眼图论，一眼要跑 Tarjan，一眼我不会。T4 一眼大数据结构，一眼不会。</p><p>然后感觉先看看 T1。然后就想到可以对于每列 <spanclass="math inline">\(j\)</span> 的每行 <spanclass="math inline">\(i\)</span>预处理一下最长可以向上延伸多少，然后就可以想到对于每行 <spanclass="math inline">\(i\)</span>维护最多可以向右延伸多少，然后就可以想到统计。但是是 <spanclass="math inline">\(O(n^4)(假设n,m同阶)\)</span> 的。</p><p>然后稍微一考虑就能想到前缀和优化一下到 <spanclass="math inline">\(O(n^2)\)</span>，然后就过了 <spanclass="math inline">\(114\ 514\)</span> 的大样例。好像也没法对拍，大概是<span class="math inline">\(10:00\)</span>，润了。</p><p>然后看了看 T2，感觉是很牛逼的构造，不会。之后 T4暴力跑线段树维护最大值 <span class="math inline">\(O(Qn^2\log n)8pts\)</span> 跑路了。</p><p>之后一直在 T4 和 T2 纠结，感觉都拿不到分。已经有点慌了。</p><p>然后感觉 T2 <span class="math inline">\(k=2n-2\)</span>的部分分好像可做，想了很长时间感觉可以每个分配两种颜色，最后一个栈做闲余栈，写了写过了样例，自己造了几组也过了。</p><p>然后感觉很没有头猪。又一直在想 T2 <spanclass="math inline">\(k=2n-1,n=2\)</span> 的部分分，写了一个 <spanclass="math inline">\(8\)</span> 个 <code>if</code>的大分类讨论，一直调不过去。眼看还有 <spanclass="math inline">\(10min\)</span>，先把东西都整理到 E盘，然后最后两分钟突然调出来了，过了样例，赶紧复制到文件里。感觉差不多了。</p><p>估分 <span class="math inline">\(100+30+0+8=138pts\)</span>，但是T1、T2 都很不稳。</p><p>水杯还落到教室里了，意识到的时候已经走了好几公里了，遂作罢。</p><p>lmt 说能 <span class="math inline">\(255pts\)</span>，结果 T2假了，<span class="math inline">\(200pts\)</span> 左右。</p><p>感觉是打的最烂的一次比赛。</p><p>T2 果然是 zrf 投的题啊……果然恶心。</p><p>luogu 测了一下 T1，过了，感觉安心一点了。</p><p>luogu 和 infoj 测了所有的，一分没挂。感觉是打的最好的一次比赛。</p><h1 id="days-later">Days Later</h1><p>T1 挂了，省二。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一次愉快的 NOIP，而又是与他们最后的诀别。&lt;/p&gt;</summary>
    
    
    
    <category term="随记" scheme="http://summace.cc/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LuoguP1133&lt;br&gt;教主的花园</title>
    <link href="http://summace.cc/LGP1133/"/>
    <id>http://summace.cc/LGP1133/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:00.184Z</updated>
    
    <content type="html"><![CDATA[<p>经典线性dp。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>典型的线性dp，首先考虑二维：</p><p>记 <span class="math inline">\(f_{i,j}\)</span> 表示当前为第 <spanclass="math inline">\(i\)</span> 位，放第 <spanclass="math inline">\(j\)</span> 种树的最大值。</p><p>然后我们发现我们没办法很好地表示树之间的高低关系，于是我们再加一维：</p><p>记 <span class="math inline">\(f_{i,j,0/1}\)</span> 表示当前为第<span class="math inline">\(i\)</span> 位，放第 <spanclass="math inline">\(j\)</span> 种树，当前树比上一位树 <spanclass="math inline">\(0(高)/1(低)\)</span> 的最大值。</p><p>我们可以很顺利地推出转移方程：</p><p><span class="math display">\[f_{i,j,0} = \max\limits_{k&lt;j}\{f_{i-1,k,1}\}\\f_{i,j,0} = \max\limits_{k&gt;j}\{f_{i-1,k,0}\}\]</span></p><p>如果这题只是一条线，那么这题到此为止就已经完成了。但是这道题是在环上，所以我们还要考虑如何处理头和尾。在记一维<span class="math inline">\(s\)</span> 表示第一位是那种树。即变成：</p><p>记 <span class="math inline">\(f_{i,j,s,0/1}\)</span> 表示当前为第<span class="math inline">\(i\)</span> 位，放第 <spanclass="math inline">\(j\)</span> 种树，第一位放 <spanclass="math inline">\(s\)</span> 种树，当前树比上一位树 <spanclass="math inline">\(0(高)/1(低)\)</span> 的最大值。</p><p><span class="math display">\[\text{if}\ \ 2\leq i&lt;n\begin{cases}    f_{i,j,s,0} = \max\limits_{k&lt;j}\{f_{i-1,k,s,1}\}\\    f_{i,j,s,1} = \max\limits_{k&gt;j}\{f_{i-1,k,s,0}\}\\\end{cases}\\\text{if}\ \ i=n\begin{cases}    f_{n,j,s,0} = \max\limits_{k&lt;j}\{f_{n-1,k,s,1}\}&amp; \text{if}\j&gt;s\\    f_{n,j,s,0} = \max\limits_{k&gt;j}\{f_{n-1,k,s,0}\}&amp; \text{if}\j&lt;s\\\end{cases}\]</span></p><h1 id="code">Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN][<span class="number">4</span>], f[MAXN][<span class="number">4</span>][<span class="number">4</span>][<span class="number">2</span>]; <span class="comment">//f(i,j,s,0/1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i][<span class="number">1</span>], &amp;a[i][<span class="number">2</span>], &amp;a[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">f[<span class="number">1</span>][j][j][<span class="number">0</span>] = f[<span class="number">1</span>][j][j][<span class="number">1</span>] = a[<span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt;= <span class="number">3</span>; s++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= <span class="number">3</span>; k++) f[i][j][s][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j][s][<span class="number">1</span>], f[i - <span class="number">1</span>][k][s][<span class="number">0</span>] + a[i][j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--) f[i][j][s][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j][s][<span class="number">0</span>], f[i - <span class="number">1</span>][k][s][<span class="number">1</span>] + a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt;= <span class="number">3</span>; s++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s &lt; j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--) f[n][j][s][<span class="number">0</span>] = <span class="built_in">max</span>(f[n][j][s][<span class="number">0</span>], f[n - <span class="number">1</span>][k][s][<span class="number">1</span>] + a[n][j]);</span><br><span class="line">            <span class="keyword">if</span>(s &gt; j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= <span class="number">3</span>; k++) f[n][j][s][<span class="number">1</span>] = <span class="built_in">max</span>(f[n][j][s][<span class="number">1</span>], f[n - <span class="number">1</span>][k][s][<span class="number">0</span>] + a[n][j]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(f[n][j][s][<span class="number">0</span>], f[n][j][s][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典线性dp。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>NOI2013&lt;br&gt;快餐店</title>
    <link href="http://summace.cc/LGP1399/"/>
    <id>http://summace.cc/LGP1399/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:04.979Z</updated>
    
    <content type="html"><![CDATA[<p>图片炸了，难过。本地也没有存。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>一道很经典的基环树上dp题。<del>调了一年</del>。</p><p>首先，如果没有环的话，这就是一道简单的求树上重心的题目。众所周知，树的重心一定在直径的中点上。</p><p>但是现在在一个基环树上做，应该怎么求呢？我们先画一个图：</p><!--more--><figure><img src="https://c2.im5i.com/2022/09/23/HW8Pz.png" alt="基环树" /><figcaption aria-hidden="true">基环树</figcaption></figure><p>为了方便，我们先设边权全部为 <spanclass="math inline">\(1\)</span>。</p><p>首先，我们可以想到断一条环上的边，然后求断边后的树的直径。</p><blockquote><p>略证：考虑到直径一定不会经过一整个环，所以依次断边后求直径一定不会漏掉真正的直径。</p></blockquote><p>这样的复杂度是 <span class="math inline">\(O(n^2)\)</span>的，我们考虑一下如何优化。</p><p>在刚刚的过程中，我们从环上的第一条边一直到最后一条边依次断开，而我们每次断开都要重新计算一次直径，这中间显然是有重合的部分的，于是我们可以考虑用类似于dp 的东西优化。</p><p>考虑有两种情况:</p><ol type="1"><li>直径没有经过环；</li><li>直径经过了环。</li></ol><p>第一个情况很好搞，第二种情况略有麻烦，也是我们刚刚复杂度的瓶颈所在。</p><p>先上结论：</p><ul><li>记 <span class="math inline">\(pre_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之前某以环上节点为根节点的子树的直径加上该点距离环上 <spanclass="math inline">\(1\)</span> 号点的距离的最大值；</li><li>记 <span class="math inline">\(suf_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之后某以环上节点为根节点的子树的直径加上该点距离环上 <spanclass="math inline">\(m\)</span> 号点的距离的最大值；</li><li>记 <span class="math inline">\(pres_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之前环上某两节点的子树直径加上两点之间的距离的最大值；</li><li>记 <span class="math inline">\(sufs_i\)</span> 表示 <spanclass="math inline">\(i\)</span>点之后环上某两节点的子树直径加上两点之间的距离的最大值；</li><li>记 <span class="math inline">\(w_{(i,j)}\)</span> 表示 <spanclass="math inline">\(i,j\)</span> 两点的距离。</li></ul><p>那么第 <span class="math inline">\(i\)</span> 号点的答案即为 <spanclass="math inline">\(\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\)</span>。</p><p>最终答案即为 <spanclass="math inline">\(\min\limits_{i=1}^{m-1}\{\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\}\)</span></p><p>是不是到现在已经有些晕了？没关系，我们从图上举例说明一下。</p><figure><img src="https://c2.im5i.com/2022/09/23/HX5t8.png" alt="删边" /><figcaption aria-hidden="true">删边</figcaption></figure><p>例如，我们现在有一只删了一条环边 <spanclass="math inline">\((4,5)\)</span> 的基环树。</p><p>我们仔细复盘一下刚刚的几句话。</p><p>先看 <span class="math inline">\(pre_i\)</span> 和 <spanclass="math inline">\(suf_i\)</span>。由于两个很像，所以重点解释 <spanclass="math inline">\(pre_i\)</span>。</p><blockquote><p>记 <span class="math inline">\(pre_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 点之前 <spanclass="math inline">\(//\)</span> 某以环上节点为根节点的子树的直径 <spanclass="math inline">\(//\)</span> 加上该点距离环上 <spanclass="math inline">\(1\)</span> 号点的距离 <spanclass="math inline">\(//\)</span> 的最大值。</p></blockquote><p>形式化的来说，我们要找的就是：</p><p><spanclass="math inline">\(pre_i=\max\limits_{j=1}^{i}\{dep_j+w_{(1,j)}\}\)</span></p><p>来看张图。</p><figure><img src="https://c2.im5i.com/2022/09/23/H21O4.png" alt="pre和suf" /><figcaption aria-hidden="true">pre和suf</figcaption></figure><p><em>可能有多种方案，图中仅展示一种。</em></p><p>图中绿色的部分即为 <spanclass="math inline">\(pre_4\)</span>，橙色的部分即为 <spanclass="math inline">\(suf_5\)</span>。</p><p>可以看出来 <span class="math inline">\(pre_i\)</span> 和 <spanclass="math inline">\(suf_i\)</span> 其实就是一棵子树的直径 <spanclass="math inline">\(+\)</span> 它前面（后面）的链的长度。</p><p>接下来再看看 <span class="math inline">\(pres_i\)</span> 和 <spanclass="math inline">\(sufs_i\)</span>，同样重点解释 <spanclass="math inline">\(pres_i\)</span>。</p><blockquote><p>记 <span class="math inline">\(pres_i\)</span> 表示 <spanclass="math inline">\(i\)</span> 点之前 <spanclass="math inline">\(//\)</span> 环上某两节点的子树直径 <spanclass="math inline">\(//\)</span> 加上两点之间的距离的最大值。</p></blockquote><p>形式化的来说，我们要找的就是：</p><p><spanclass="math inline">\(pres_i=\max\limits_{j=1}^{i}\{dep_i+dep_j+w_{(i,j)}\}\)</span></p><p>再来看张图。</p><figure><img src="https://c2.im5i.com/2022/09/23/H2fal.png" alt="pres和sufs" /><figcaption aria-hidden="true">pres和sufs</figcaption></figure><p><em>可能有多种方案，图中仅展示一种。</em></p><p>图中蓝色的部分即为 <spanclass="math inline">\(pres_4\)</span>，黄色的部分即为 <spanclass="math inline">\(sufs_5\)</span>。</p><p>好，弄清楚这 <span class="math inline">\(4\)</span>个，我们来看看结果的式子：</p><blockquote><p>那么第 <span class="math inline">\(i\)</span> 号点的答案即为 <spanclass="math inline">\(\max\{pre_i, suf_{i+1},pres_i+sufs_{i+1}+w_{(1,m)}\}\)</span>。</p></blockquote><p>我们考虑到删掉边 <span class="math inline">\((i,i+1)\)</span>的时候，直径有三种可能：</p><ol type="1"><li>直径在 <span class="math inline">\([1,i]\)</span> 之间；</li><li>直径在 <span class="math inline">\([i+1,m]\)</span> 之间；</li><li>直径跨过了边 <span class="math inline">\((1,m)\)</span>。</li></ol><p>对于第一种情况，我们惊喜地发现，<spanclass="math inline">\(pres_i\)</span> 即为我们所求。</p><p>对于第二种情况，我们再次惊喜地发现，<spanclass="math inline">\(sufs_{i+1}\)</span> 即为我们所求。</p><p>对于第三种情况，我们发现，由于 <spanclass="math inline">\(pre_i\)</span> 一直延伸到 <spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(suf_{i+1}\)</span> 一直延伸到 <spanclass="math inline">\(m\)</span>，所以我们再加上 <spanclass="math inline">\(w_{(1,m)}\)</span> 即可，也就是 <spanclass="math inline">\(pre_i+suf_{i+1}+w_{(1,m)}\)</span>。</p><p>最后我们遍历一遍，统计最小值即可。</p><h1 id="code">Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt, w;</span><br><span class="line">&#125;e[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], ent;</span><br><span class="line"><span class="type">int</span> fa[MAXN], tnt, dfn[MAXN], dis[MAXN];</span><br><span class="line"><span class="type">bool</span> iscyc[MAXN];</span><br><span class="line"><span class="type">int</span> cyc[MAXN], cnt, cycdis[MAXN];</span><br><span class="line">ll dep[MAXN];</span><br><span class="line">ll pre[MAXN], suf[MAXN], presub[MAXN], sufsub[MAXN];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++ent].to = v;</span><br><span class="line">    e[ent].w = w;</span><br><span class="line">    e[ent].nxt = head[u];</span><br><span class="line">    head[u] = ent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++tnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[v] = u;</span><br><span class="line">            dis[v] = e[i].w;</span><br><span class="line">            <span class="built_in">dfs1</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &gt; dfn[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(; v != u; v = fa[v])</span><br><span class="line">            &#123;</span><br><span class="line">                iscyc[v] = <span class="literal">true</span>;</span><br><span class="line">                cyc[++cnt] = v;</span><br><span class="line">                cycdis[cnt] = dis[v];</span><br><span class="line">            &#125;</span><br><span class="line">            iscyc[u] = <span class="literal">true</span>;</span><br><span class="line">            cyc[++cnt] = u;</span><br><span class="line">            cycdis[cnt] = e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!iscyc[v] &amp;&amp; v != father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">            ans = <span class="built_in">max</span>((ll)dep[u] + dep[v] + e[i].w, ans);</span><br><span class="line">            dep[u] = <span class="built_in">max</span>(dep[u], dep[v] + e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add_edge</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add_edge</span>(b, a, c);</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="built_in">dfs2</span>(cyc[i], <span class="number">0</span>);</span><br><span class="line">    ll sum = <span class="number">0</span>, maxdep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += cycdis[i - <span class="number">1</span>];</span><br><span class="line">        pre[i] = <span class="built_in">max</span>(pre[i - <span class="number">1</span>], dep[cyc[i]] + sum);</span><br><span class="line">        presub[i] = <span class="built_in">max</span>(presub[i - <span class="number">1</span>], sum + maxdep + dep[cyc[i]]);</span><br><span class="line">        maxdep = <span class="built_in">max</span>(maxdep, dep[cyc[i]] - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    sum = maxdep = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp = cycdis[cnt];</span><br><span class="line">    cycdis[cnt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += cycdis[i];</span><br><span class="line">        suf[i] = <span class="built_in">max</span>(suf[i + <span class="number">1</span>], dep[cyc[i]] + sum);</span><br><span class="line">        sufsub[i] = <span class="built_in">max</span>(sufsub[i + <span class="number">1</span>], sum + maxdep + dep[cyc[i]]);</span><br><span class="line">        maxdep = <span class="built_in">max</span>(maxdep, dep[cyc[i]] - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = presub[cnt];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">        res = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(presub[i], sufsub[i + <span class="number">1</span>]), pre[i] + suf[i + <span class="number">1</span>] + tmp), res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>, (<span class="type">double</span>)<span class="built_in">max</span>(ans, res) / <span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;图片炸了，难过。本地也没有存。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>LuoguP1253&lt;br&gt;扶苏的问题</title>
    <link href="http://summace.cc/LGP1253/"/>
    <id>http://summace.cc/LGP1253/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:02.927Z</updated>
    
    <content type="html"><![CDATA[<p>线段树。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>实际上相当于维护一颗线段树，支持区间覆盖、区间加和区间查询最大值。</p><p>维护最大值很好办，区间覆盖和区间加我们怎么维护呢？</p><p>首先，区间覆盖和区间加一定都分别需要记一个懒标记。我们把区间覆盖的懒标记记为<span class="math inline">\(ctag\)</span>，区间加的懒标记记为 <spanclass="math inline">\(atag\)</span>，那么我们如何把标记 <spanclass="math inline">\(\text{pushdown}\)</span> 呢？</p><p>首先，初始化要选择一个尽量不影响之后操作的值。<spanclass="math inline">\(atag\)</span> 显然选择 <spanclass="math inline">\(0\)</span> 即可。由于要更改的数字有正有负，<spanclass="math inline">\(ctag\)</span> 可以选取 <spanclass="math inline">\(-\infty\)</span>，在程序中我选用了 <spanclass="math inline">\(1e18+7\)</span> 作为 <spanclass="math inline">\(\text{INF}\)</span>。</p><p>考虑到如果我们当前节点有一个 <spanclass="math inline">\(atag\)</span> 标记，之后又打上了一个 <spanclass="math inline">\(ctag\)</span>标记，那么<strong>要覆盖的值会直接把要加的值覆盖</strong>，也就是说<span class="math inline">\(ctag\)</span> 会直接清除 <spanclass="math inline">\(atag\)</span>。而如果先打上 <spanclass="math inline">\(ctag\)</span>，再打上 <spanclass="math inline">\(atag\)</span>，则需要<strong>先把 <spanclass="math inline">\(ctag\)</span> 下放，再下放 <spanclass="math inline">\(atag\)</span></strong>。那么我们的 <spanclass="math inline">\(\text{pushdown}\)</span> 可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span> <span class="comment">//把下放的操作封装一下可以使代码更简洁</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx += v;</span><br><span class="line">    t[k].atag += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = v;</span><br><span class="line">    t[k].ctag = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpushdown</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">//ctag 的下放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].ctag == -INF) <span class="keyword">return</span>; <span class="comment">//如果没有标记，返回</span></span><br><span class="line">    t[ls].atag = t[rs].atag = <span class="number">0</span>; <span class="comment">//抹除 atag</span></span><br><span class="line">    <span class="built_in">cf</span>(ls, t[k].ctag), <span class="built_in">cf</span>(rs, t[k].ctag); <span class="comment">//ctag 下放</span></span><br><span class="line">    t[k].ctag = -INF; <span class="comment">//当前节点 ctag 清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apushdown</span><span class="params">(<span class="type">int</span> k)</span> <span class="comment">//atag 的下放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].atag == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//如果没有标记，返回</span></span><br><span class="line">    <span class="built_in">cpushdown</span>(k); <span class="comment">//先把 ctag 下放</span></span><br><span class="line">    <span class="built_in">af</span>(ls, t[k].atag), <span class="built_in">af</span>(rs, t[k].atag); <span class="comment">//atag 下放</span></span><br><span class="line">    t[k].atag = <span class="number">0</span>; <span class="comment">//当前节点 atag 清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">apushdown</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次 pushdown 操作包括 ctag 的下放和 atag 的下放，都要进行</span></span><br></pre></td></tr></table></figure><p>那么操作呢？区间加操作和之前一样即可，区间覆盖操作需要清除当前节点的<span class="math inline">\(atag\)</span>。</p><p>其他部分即为普通线段树模板。</p><h1 id="code">Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxx;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> atag, ctag;</span><br><span class="line">&#125;t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = <span class="built_in">max</span>(t[ls].maxx, t[rs].maxx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">af</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx += v;</span><br><span class="line">    t[k].atag += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cf</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].maxx = v;</span><br><span class="line">    t[k].ctag = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].ctag == -INF) <span class="keyword">return</span>;</span><br><span class="line">    t[ls].atag = t[rs].atag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cf</span>(ls, t[k].ctag), <span class="built_in">cf</span>(rs, t[k].ctag);</span><br><span class="line">    t[k].ctag = -INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].atag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">af</span>(ls, t[k].atag), <span class="built_in">af</span>(rs, t[k].atag);</span><br><span class="line">    t[k].atag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cpushdown</span>(k);</span><br><span class="line">    <span class="built_in">apushdown</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].l = l;</span><br><span class="line">    t[k].r = r;</span><br><span class="line">    t[k].atag = <span class="number">0</span>;</span><br><span class="line">    t[k].ctag = -INF;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].maxx = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">af</span>(k, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[k].atag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cf</span>(k, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">cover</span>(ls, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">cover</span>(rs, l, r, v);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r) <span class="keyword">return</span> t[k].maxx;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = (t[k].l + t[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(ls, l, r));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(rs, l, r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">cover</span>(<span class="number">1</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, l, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;线段树。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>HAOI2012&lt;br&gt;高速公路</title>
    <link href="http://summace.cc/LGP2221/"/>
    <id>http://summace.cc/LGP2221/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:35:07.475Z</updated>
    
    <content type="html"><![CDATA[<p>一道非常好的线段树题。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>优先想到线段树，考虑怎么维护。</p><p>记第 <span class="math inline">\(i\)</span> 到第 <spanclass="math inline">\(i+1\)</span> 条边为第 <spanclass="math inline">\(i\)</span> 条边，将问题转化成维护 <spanclass="math inline">\(n-1\)</span> 个数。</p><p>那么，我们维护一个前缀和 <spanclass="math inline">\(sum\)</span>，根据题意：</p><p><span class="math display">\[Ans=\frac{\sum\limits_{i=l}^{r}\sum\limits_{j=l}^{r}sum_j-sum_i}{\binom{r-l+1}{2}}\]</span></p><p>下面的东西很好算，重点是上面的东西怎么维护。</p><p>我们把上面的东西记作 <spanclass="math inline">\(ans\)</span>，考虑枚举每条边被计算的次数，可以理解成枚举每个点左右两条路。</p><p>所以：</p><p><span class="math display">\[\begin{split}ans &amp;=\sum\limits_{i=l}^{r}a_i\times (r-i+1)(i-l+1)\\    &amp;=\sum\limits_{i=l}^{r}a_i\times (ir-lr+r-i^2+il-i+i-l+1)\\    &amp;=\sum\limits_{i=l}^{r}a_i\times (-i^2+(l+r)i-lr+r-l+1)\\    &amp;=-\sum\limits_{i=l}^{r}a_i\timesi^2+(l+r)\sum\limits_{i=l}^{r}a_i\timesi+(r-l-lr+1)\sum\limits_{i=l}^{r}a_i\end{split}\]</span></p><p>现在需要维护 <spanclass="math inline">\(sum_1=\sum_{i=l}^{r}a_i\times i^2\)</span>，<spanclass="math inline">\(sum_2=\sum_{i=l}^{r}a_i\times i\)</span>，<spanclass="math inline">\(sum_3=\sum_{i=l}^{r}a_i\)</span>。</p><p>即变成：</p><p><spanclass="math display">\[ans=-sum1+(l+r)sum2+(r-l-lr+1)sum3\]</span></p><p>考虑 <code>pushup</code> 的时候，直接相加就可以了。</p><p>考虑在区间 <span class="math inline">\([L,R]\)</span> 加上一个 <spanclass="math inline">\(x\)</span> 的时候怎么做：</p><p><span class="math display">\[\begin{split}sum_3&#39;&amp;= \sum\limits_{i=L}^{R}(a_i+x)\\&amp;= (R-L+1)x+\sum\limits_{i=L}^{R}a_i\\&amp;= (R-L+1)x+sum_3\\\Delta sum_3 &amp;= (R-L+1)x\end{split}\]</span></p><p>直接维护。</p><p><span class="math display">\[\begin{split}sum_2&#39;&amp;= \sum\limits_{i=L}^{R}i(a_i+x)\\&amp;= \sum\limits_{i=L}^{R}i\times a_i+\sum\limits_{i=L}^{R}ix\\&amp;= \sum\limits_{i=L}^{R}i\times a_i+x\sum\limits_{i=L}^{R}i\\&amp;= x\sum\limits_{i=L}^{R}i+sum_2\\\Delta sum_2 &amp;= x\sum\limits_{i=L}^{R}i\end{split}\]</span></p><p>维护区间和。</p><p><span class="math display">\[\begin{split}sum_1&#39;&amp;= \sum\limits_{i=L}^{R}i^2(a_i+x)\\&amp;= \sum\limits_{i=L}^{R}i^2\times a_i+\sum\limits_{i=L}^{R}i^2x\\&amp;= \sum\limits_{i=L}^{R}i^2\times a_i+x\sum\limits_{i=L}^{R}i^2\\&amp;= x\sum\limits_{i=L}^{R}i^2+sum_1\\\Delta sum_1 &amp;= x\sum\limits_{i=L}^{R}i^2\end{split}\]</span></p><p>维护区间平方和。</p><p>最后求期望约分即可。</p><h1 id="code">Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans1, ans2, ans3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum1, sum2, sum3, sum4, sum5;</span><br><span class="line">            <span class="type">int</span> lazy;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">        &#125;tree[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rc</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].lazy += v;</span><br><span class="line">tree[k].sum1 += (tree[k].r - tree[k].l + <span class="number">1</span>) * v;</span><br><span class="line">            tree[k].sum2 += v * tree[k].sum5;</span><br><span class="line">            tree[k].sum3 += v * tree[k].sum4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].sum1 = tree[<span class="built_in">lc</span>(k)].sum1 + tree[<span class="built_in">rc</span>(k)].sum1;</span><br><span class="line">            tree[k].sum2 = tree[<span class="built_in">lc</span>(k)].sum2 + tree[<span class="built_in">rc</span>(k)].sum2;</span><br><span class="line">            tree[k].sum3 = tree[<span class="built_in">lc</span>(k)].sum3 + tree[<span class="built_in">rc</span>(k)].sum3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">lc</span>(k), tree[k].lazy);</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">rc</span>(k), tree[k].lazy);</span><br><span class="line">tree[k].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].lazy = <span class="number">0</span>;</span><br><span class="line">            tree[k].l = l;</span><br><span class="line">            tree[k].r = r;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[k].sum4 = l * l;</span><br><span class="line">                tree[k].sum5 = l;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">lc</span>(k), l, mid);</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">rc</span>(k), mid + <span class="number">1</span>, r);</span><br><span class="line">tree[k].sum4 = tree[<span class="built_in">lc</span>(k)].sum4 + tree[<span class="built_in">rc</span>(k)].sum4;</span><br><span class="line">            tree[k].sum5 = tree[<span class="built_in">lc</span>(k)].sum5 + tree[<span class="built_in">rc</span>(k)].sum5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= tree[k].l &amp;&amp; tree[k].r &lt;= R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">f</span>(k, v);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(k);</span><br><span class="line"><span class="type">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(k), L, R, v);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(k), L, R, v);</span><br><span class="line"><span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= tree[k].l &amp;&amp; tree[k].r &lt;= R)</span><br><span class="line">            &#123;</span><br><span class="line">                ans1 += tree[k].sum1;</span><br><span class="line">                ans2 += tree[k].sum2;</span><br><span class="line">                ans3 += tree[k].sum3;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="built_in">pushdown</span>(k);</span><br><span class="line"><span class="type">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) <span class="built_in">query</span>(<span class="built_in">lc</span>(k), L, R);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) <span class="built_in">query</span>(<span class="built_in">rc</span>(k), L, R);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> l, r, v;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        r--;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;v);</span><br><span class="line">            t.<span class="built_in">update</span>(<span class="number">1</span>, l, r, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans1 = ans2 = ans3 = <span class="number">0</span>;</span><br><span class="line">            t.<span class="built_in">query</span>(<span class="number">1</span>, l, r);</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            a = (r - l + <span class="number">1</span> - r * l) * ans1 + (r + l) * ans2 - ans3;</span><br><span class="line">            b = (r - l + <span class="number">2</span>) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            c = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; l &lt;&lt; r &lt;&lt; b;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, a / c, b / c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道非常好的线段树题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>USACO08FEB Hotel G</title>
    <link href="http://summace.cc/LGP2894/"/>
    <id>http://summace.cc/LGP2894/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:16:14.950Z</updated>
    
    <content type="html"><![CDATA[<p>经典线段树问题。</p><span id="more"></span><h1 id="prob.">Prob.</h1><p><span class="math inline">\(n\)</span> 个房间，两种操作：</p><ol type="1"><li><code>1 x</code>：在 <span class="math inline">\([1,n]\)</span>中寻找一段长度为 <span class="math inline">\(x\)</span>的空房区间。若存在，入住这些房间，并输出最小的左端点。若不存在，输出<span class="math inline">\(0\)</span>；</li><li><code>2 l r</code>：<span class="math inline">\([l,l+r-1]\)</span>退房。</li></ol><h1 id="sol.">Sol.</h1><p>这道题也算是线段树常规操作了。我们要维护连续的空房区间，想想要维护哪些值？</p><p>与分治的思想类似，一段空房区间可以全部在左半部分、全部在右半部分、或者左半部分和右半部分都有一部分。那么我们可以维护三个值：从<strong>左端点开始的</strong>最长空房区间长度、从<strong>右端点开始的</strong>最长空房区间长度、以及<strong>整个区间的</strong>最长空房区间长度。我们把它们分别记为<span class="math inline">\(lmax,rmax,maxx\)</span>。</p><p>那我们想想线段树的各个模块该如何写。</p><h2 id="textpushup"><spanclass="math inline">\(\text{pushup}\)</span></h2><p>由于我们要维护三个值，那么上传的时候也要上传三个值。</p><p>分情况讨论：</p><h3 id="lmax-如何上传"><span class="math inline">\(lmax\)</span>如何上传？</h3><p>显然，当前节点的 <span class="math inline">\(lmax\)</span>直接选取左区间的 <span class="math inline">\(lmax\)</span>就可以了。但是这里有一种特殊情况：<strong>当左区间的 <spanclass="math inline">\(lmax\)</span> 等于整段左区间的长度时，<spanclass="math inline">\(lmax\)</span>可以继续延伸至右区间的左端。</strong>此时 <spanclass="math inline">\(lmax\)</span> 应该为左区间的 <spanclass="math inline">\(lmax\)</span> 加上有区间的 <spanclass="math inline">\(lmax\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t[ls].lmax == (t[ls].r - t[ls].l + <span class="number">1</span>)) t[k].lmax = t[ls].lmax + t[rs].lmax;</span><br><span class="line"><span class="keyword">else</span> t[k].lmax = t[ls].lmax;    </span><br></pre></td></tr></table></figure><h3 id="rmax-如何上传"><span class="math inline">\(rmax\)</span>如何上传？</h3><p>与 <span class="math inline">\(lmax\)</span> 类似，当右区间的 <spanclass="math inline">\(rmax\)</span> 等于整段右区间的长度时，<spanclass="math inline">\(rmax\)</span>可以继续延伸至左区间的右端。否则，选取右区间的 <spanclass="math inline">\(rmax\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t[rs].rmax == (t[rs].r - t[rs].l + <span class="number">1</span>)) t[k].rmax = t[rs].rmax + t[ls].rmax;</span><br><span class="line"><span class="keyword">else</span> t[k].rmax = t[rs].rmax;</span><br></pre></td></tr></table></figure><h3 id="maxx-如何上传"><span class="math inline">\(maxx\)</span>如何上传？</h3><p>显然，<span class="math inline">\(maxx\)</span>直接从左端点开始的长度、右端点开始的长度、以及左右都有的长度中选取最大值即可。左右都有的长度就是左区间的<span class="math inline">\(rmax\)</span> 加上右区间的 <spanclass="math inline">\(lmax\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t[k].maxx = <span class="built_in">max</span>(<span class="built_in">max</span>(t[ls].maxx, t[rs].maxx), t[ls].rmax + t[rs].lmax);</span><br></pre></td></tr></table></figure><p>那么，我们的 <span class="math inline">\(\text{pushup}\)</span>就可以这么写了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[ls].lmax == (t[ls].r - t[ls].l + <span class="number">1</span>)) t[k].lmax = t[ls].lmax + t[rs].lmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].lmax = t[ls].lmax;</span><br><span class="line">    <span class="keyword">if</span>(t[rs].rmax == (t[rs].r - t[rs].l + <span class="number">1</span>)) t[k].rmax = t[rs].rmax + t[ls].rmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].rmax = t[rs].rmax;</span><br><span class="line">    t[k].maxx = <span class="built_in">max</span>(<span class="built_in">max</span>(t[ls].maxx, t[rs].maxx), t[ls].rmax + t[rs].lmax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="textpushdown"><spanclass="math inline">\(\text{pushdown}\)</span></h2><p>当然，区间修改就一定要打懒标记。虽然这道题目的修改不是常规的数值修改，我们仍然要打<span class="math inline">\(tag\)</span>。</p><p>注意到修改操作有两种：开房和退房。那么我们的 <spanclass="math inline">\(tag\)</span> 可以分别用 <spanclass="math inline">\(0/1/2\)</span> 表示 无标记/开房/退房。</p><p>那么当 <span class="math inline">\(tag=1\)</span>时，整段区间都不可用，<spanclass="math inline">\(lmax=rmax=maxx=0\)</span>。</p><p>当 <span class="math inline">\(tag=2\)</span>时，整段区间都可用，<spanclass="math inline">\(lmax=rmax=maxx=len\)</span>，<spanclass="math inline">\(len\)</span> 为区间长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].tag == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//无标记返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">1</span>) <span class="comment">//开房标记，整段区间不可用</span></span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">1</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = <span class="number">0</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">2</span>) <span class="comment">//退房标记，整段区间都可用</span></span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">2</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = t[ls].r - t[ls].l + <span class="number">1</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = t[rs].r - t[rs].l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t[k].tag = <span class="number">0</span>; <span class="comment">//别忘了清零标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="textbuild"><spanclass="math inline">\(\text{build}\)</span></h2><p>这个和常规操作没什么不同，只是由于初始全部都是空房，把所有 <spanclass="math inline">\(lmax,rmax,maxx\)</span>赋为当前区间长度就可以了。</p><h2 id="textupdate"><spanclass="math inline">\(\text{update}\)</span></h2><p>修改操作有两个：开房和退房。但是大体上没什么不同，可以只用一个函数解决。</p><p>当是开房操作时，整段区间不可用，<spanclass="math inline">\(lmax=rmax=maxx=0\)</span>，打上 <spanclass="math inline">\(1\)</span> 标记。</p><p>当是退房操作时，整段区间都可用，<spanclass="math inline">\(lmax=rmax=maxx=len\)</span>，打上 <spanclass="math inline">\(2\)</span> 标记。</p><p>函数添加一个参数 <span class="math inline">\(type\)</span>，<spanclass="math inline">\(1/2\)</span> 分别表示 开房/退房 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = <span class="number">0</span>;</span><br><span class="line">            t[k].tag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = t[k].r - t[k].l + <span class="number">1</span>;</span><br><span class="line">            t[k].tag = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = t[k].l + t[k].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, type);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, type);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="textquery"><spanclass="math inline">\(\text{query}\)</span></h2><p>查询时，要从三部分查询：全部在左区间找、在中间找、全部在右区间找。</p><p>这里有一个优先级的问题：由于我们要输出最小的编号，那么应该是左区间→中间→右区间的顺序。</p><p>所以，如果左儿子的 <spanclass="math inline">\(maxx&gt;=len(len为要查询的长度)\)</span>，那么就从左儿子里找。否则，如果左儿子的<span class="math inline">\(rmax\)</span> 加上右儿子的 <spanclass="math inline">\(lmax\)</span> 大于等于 <spanclass="math inline">\(len\)</span>（也就是跨左右儿子的空房区间），那么直接输出这段的左端点。否则，去右儿子里找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].l == t[k].r) <span class="keyword">return</span> t[k].l;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(t[ls].maxx &gt;= len) <span class="keyword">return</span> <span class="built_in">query</span>(ls, len); <span class="comment">//去左儿子里找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[ls].rmax + t[rs].lmax &gt;= len) <span class="keyword">return</span> t[ls].r - t[ls].rmax + <span class="number">1</span>; <span class="comment">//去中间找，答案就是左儿子 rmax 的左端点，可以用左儿子的右端点 - rmax长度 + 1 表示</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs, len); <span class="comment">//去右儿子里找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="code">Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (k &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, tag;</span><br><span class="line">    <span class="type">int</span> lmax, rmax, maxx;</span><br><span class="line">&#125;t[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[ls].lmax == (t[ls].r - t[ls].l + <span class="number">1</span>)) t[k].lmax = t[ls].lmax + t[rs].lmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].lmax = t[ls].lmax;</span><br><span class="line">    <span class="keyword">if</span>(t[rs].rmax == (t[rs].r - t[rs].l + <span class="number">1</span>)) t[k].rmax = t[rs].rmax + t[ls].rmax;</span><br><span class="line">    <span class="keyword">else</span> t[k].rmax = t[rs].rmax;</span><br><span class="line">    t[k].maxx = <span class="built_in">max</span>(<span class="built_in">max</span>(t[ls].maxx, t[rs].maxx), t[ls].rmax + t[rs].lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].tag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">1</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = <span class="number">0</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[k].tag == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[ls].tag = t[rs].tag = <span class="number">2</span>;</span><br><span class="line">        t[ls].lmax = t[ls].rmax = t[ls].maxx = t[ls].r - t[ls].l + <span class="number">1</span>;</span><br><span class="line">        t[rs].lmax = t[rs].rmax = t[rs].maxx = t[rs].r - t[rs].l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[k].tag = <span class="number">0</span>;</span><br><span class="line">    t[k].l = l, t[k].r = r;</span><br><span class="line">    t[k].maxx = t[k].lmax = t[k].rmax = (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[k].l &amp;&amp; t[k].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = <span class="number">0</span>;</span><br><span class="line">            t[k].tag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[k].lmax = t[k].rmax = t[k].maxx = t[k].r - t[k].l + <span class="number">1</span>;</span><br><span class="line">            t[k].tag = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid = t[k].l + t[k].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">update</span>(ls, l, r, type);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">update</span>(rs, l, r, type);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[k].l == t[k].r) <span class="keyword">return</span> t[k].l;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(t[ls].maxx &gt;= len) <span class="keyword">return</span> <span class="built_in">query</span>(ls, len);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[ls].rmax + t[rs].lmax &gt;= len) <span class="keyword">return</span> t[ls].r - t[ls].rmax + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">1</span>].maxx &lt; len) <span class="comment">//如果整段区间都没有大于等于 len 的空房区间，那么输出 0</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> ans = <span class="built_in">query</span>(<span class="number">1</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, ans, ans + len - <span class="number">1</span>, <span class="number">1</span>); <span class="comment">//别忘了开上房</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, l, l + r - <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//退房</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ext.">Ext.</h2><p>讲个笑话，这道题我调了三次的原因；</p><ol type="1"><li>没建树 <del>（lmt：我们要有所建树！）</del>；</li><li><code>Shift</code> 没按上 <del>（导致 93行加号打成了等号）</del>；</li><li>从 <span class="math inline">\(l\)</span> 开 <spanclass="math inline">\(r\)</span> 个房，不是从 <spanclass="math inline">\(l\)</span> 开到 <spanclass="math inline">\(r\)</span> <del>（所以在 Prob. 里面特意说了是 [l,r-l+1]）</del>。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典线段树问题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>SDOI2006&lt;br&gt;保安站岗</title>
    <link href="http://summace.cc/LGP2458/"/>
    <id>http://summace.cc/LGP2458/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:35:02.578Z</updated>
    
    <content type="html"><![CDATA[<p>一道很经典的树形dp题目。</p><span id="more"></span><h1 id="sol.">Sol.</h1><p>很明显的树形dp，先把方程设出来：</p><p><span class="math inline">\(f_{x,0/1/2}\)</span> 表示当前节点为 <spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(0(自己覆盖)/1(儿子覆盖)/2(父亲覆盖)\)</span>，且其子节点都已全部覆盖的最小权值。</p><p>很套路的树形dp方程，分别考虑如何转移：</p><p>记 <span class="math inline">\(son(i)\)</span> 表示 <spanclass="math inline">\(i\)</span> 的所有子节点，<spanclass="math inline">\(k_i\)</span> 表示控制 <spanclass="math inline">\(i\)</span> 点所需的代价。</p><h2 id="f_x0自己覆盖">1. <spanclass="math inline">\(f_{x,0}\)</span>（自己覆盖）</h2><p><span class="math inline">\(f_{x,0} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1},f_{y,2}\}+k_x\)</span></p><p>解释：由于当前节点自己覆盖自己，所以不需考虑其他的节点，在所有子节点中找到最小值转移即可。</p><h2 id="f_x1儿子覆盖">2. <spanclass="math inline">\(f_{x,1}\)</span>（儿子覆盖）</h2><p><span class="math inline">\(f_{x,1} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\}\)</span></p><p>解释：当当前节点被儿子覆盖时，说明当前节点不可能覆盖儿子节点，也就无法从<span class="math inline">\(f_{y,2}\)</span> 转移。</p><p>但是有一种这样的情况：当儿子节点全部选择 <spanclass="math inline">\(f_{y,1}\)</span>时，即儿子节点全部被它的儿子节点覆盖，在这种情况下 <spanclass="math inline">\(x\)</span> 节点无法被儿子节点覆盖。</p><p>所以我们在转移的时候记一个 <span class="math inline">\(q\)</span>表示是否全部选择的 <spanclass="math inline">\(f_{y,1}\)</span>，如果是，则强制选择一个节点让其选择<spanclass="math inline">\(f_{y,0}\)</span>。我们要向最小化代价，显然要让强制选择的节点<span class="math inline">\(f_{y,0}\)</span> 与 <spanclass="math inline">\(f_{y,1}\)</span>的差值最小。所以现在转移方程如下：</p><p><span class="math inline">\(f_{x,1} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\},\text{if all choose }f_{y,1},\text{then}+\min\limits_{y\inson(x)}\{f_{y,0}-f_{y,1}\}\)</span></p><h2 id="f_x2父亲覆盖">3. <spanclass="math inline">\(f_{x,2}\)</span>（父亲覆盖）</h2><p><span class="math inline">\(f_{x,2} = \sum\limits_{y\inson(x)}\min\{f_{y,0},f_{y,1}\}\)</span></p><p>解释：这个就比较简单了，当当前节点被父亲覆盖，直接从可能的方式转移即可。</p><h1 id="code">Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125;e[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], k[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = k[x];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, minn = INF;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">        f[x][<span class="number">0</span>] += <span class="built_in">min</span>(f[y][<span class="number">0</span>], <span class="built_in">min</span>(f[y][<span class="number">1</span>], f[y][<span class="number">2</span>]));</span><br><span class="line">        f[x][<span class="number">2</span>] += <span class="built_in">min</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> tmp = <span class="built_in">min</span>(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);</span><br><span class="line">        f[x][<span class="number">1</span>] += tmp;</span><br><span class="line">        <span class="keyword">if</span>(tmp == f[y][<span class="number">0</span>]) flag = <span class="literal">false</span>;</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, f[y][<span class="number">0</span>] - f[y][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) f[x][<span class="number">1</span>] += minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">        k[x] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add_edge</span>(x, y);</span><br><span class="line">            <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道很经典的树形dp题目。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>CTSC2012&lt;br&gt;电阻网络</title>
    <link href="http://summace.cc/LGP4020/"/>
    <id>http://summace.cc/LGP4020/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:15:49.415Z</updated>
    
    <content type="html"><![CDATA[<p>在各学科交叉应用的潮流下，一道具有超前预见性的好题。</p><span id="more"></span><h1 id="solution">Solution</h1><h2 id="前置知识">前置知识</h2><h3 id="欧姆定律">欧姆定律</h3><p>在同一电路中，通过某段导体的电流跟这段导体两端的电压成正比，跟这段导体的电阻成反比。</p><p><span class="math display">\[I=\frac{U}{R}\]</span></p><p>其中 <span class="math inline">\(I\)</span> 为电流，<spanclass="math inline">\(U\)</span> 为电压，<spanclass="math inline">\(R\)</span> 为电阻。</p><h3 id="基尔霍夫第一定律">基尔霍夫第一定律</h3><p>会合于任意节点的电流和等于零。</p><p><span class="math display">\[\sum I=0\]</span></p><h2 id="solution-1">Solution</h2><p>本题中全部为相同电阻，所以答案与电阻大小无关，记电阻大小为 <spanclass="math inline">\(R\)</span>，钦定一个叶子节点为根。</p><p>考虑第 <span class="math inline">\(i\)</span> 个节点，记 <spanclass="math inline">\(i\)</span> 的父亲为 <spanclass="math inline">\(fa\)</span>，儿子集合为 <spanclass="math inline">\(son\)</span>，<spanclass="math inline">\(fa\)</span> 到 <spanclass="math inline">\(i\)</span> 的电流为 <spanclass="math inline">\(I_i\)</span>，<spanclass="math inline">\(i\)</span> 处电能为 <spanclass="math inline">\(E_i\)</span>。</p><p>则从 <span class="math inline">\(fa\)</span> 到 <spanclass="math inline">\(i\)</span>的过程中，电势差的产生可以看作两部分，一部分是电阻导致的电势的下降，一部分是电源导致的电势的上升，这两部分之和等于电势差。即：</p><p><spanclass="math display">\[I_iR+E_i=\varphi_{fa}-\varphi_i\]</span></p><p>移项得：</p><p><spanclass="math display">\[I_i=\frac{\varphi_{fa}-\varphi_i-E_i}{R}\]</span></p><p>这是 <span class="math inline">\(i\)</span>祖先方向的电流，同理，对于儿子方向的任意 <spanclass="math inline">\(x\in son\)</span>，我们有：</p><p><spanclass="math display">\[I_xR+E_x=\varphi_{i}-\varphi_x\]</span></p><p>得：</p><p><spanclass="math display">\[I_x=\frac{\varphi_{i}-\varphi_x-E_x}{R}\]</span></p><p>求和得：</p><p><span class="math display">\[\sum\limits_{x\inson}I_x=\sum\limits_{x\inson}\frac{\varphi_{i}-\varphi_x-E_x}{R}\]</span></p><p>根据基尔霍夫第一定律：</p><p><span class="math display">\[I_i=\sum\limits_{x\inson}I_x\]</span></p><p>即：</p><p><spanclass="math display">\[\frac{\varphi_{fa}-\varphi_i-E_i}{R}=\sum\limits_{x\inson}\frac{\varphi_{i}-\varphi_x-E_x}{R}\]</span></p><p>继续化简：</p><p><spanclass="math display">\[\varphi_{fa}-\varphi_i-E_i=\sum\limits_{x\inson}(\varphi_{i}-\varphi_x-E_x)\]</span></p><p><spanclass="math display">\[\varphi_{fa}-\varphi_i-E_i=|son|\varphi_i-\sum\limits_{x\inson}(\varphi_x+E_x)\]</span></p><p><spanclass="math display">\[(|son|+1)\varphi_i=\varphi_{fa}-E_i+\sum\limits_{x\inson}(\varphi_x+E_x)\]</span></p><p>注意到 <span class="math inline">\(|son|\)</span>是儿子集合，相当于当前节点向儿子方向的度数；<spanclass="math inline">\(1\)</span> 相当于当前节点向父亲方向的度数，所以<span class="math inline">\(|son|+1\)</span> 实际上相当于节点 <spanclass="math inline">\(i\)</span> 的度数，记为 <spanclass="math inline">\(deg_i\)</span>。</p><p><spanclass="math display">\[deg_i\varphi_i=\varphi_{fa}-E_i+\sum\limits_{x\inson}(\varphi_x+E_x)\]</span></p><p><spanclass="math display">\[\varphi_i=\frac{\varphi_{fa}-E_i+\sum\limits_{x\inson}(\varphi_x+E_x)}{deg_i}\]</span></p><p>为了方便进行递推，我们设 <spanclass="math inline">\(\varphi_i=K_i\varphi_{fa}+B_i\)</span>，其中 <spanclass="math inline">\(K_i,B_i\)</span> 都是只与 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(son\)</span> 有关的常量。</p><p>把 <span class="math inline">\(\varphi_x\)</span>用刚刚的形式表示出来：</p><p><spanclass="math display">\[\varphi_x=K_x\varphi_{i}+B_x\]</span></p><p>代入原式：</p><p><spanclass="math display">\[\varphi_i=\frac{\varphi_{fa}-E_i+\sum\limits_{x\inson}(K_x\varphi_{i}+B_x+E_x)}{deg_i}\]</span></p><p>把这个式子表示成刚刚的形式：</p><p><spanclass="math display">\[deg_i\varphi_i=\varphi_{fa}-E_i+\sum\limits_{x\inson}(K_x\varphi_{i}+B_x+E_x)\]</span></p><p><spanclass="math display">\[deg_i\varphi_i=\varphi_{fa}-E_i+\sum\limits_{x\inson}K_x\varphi_{i}+\sum\limits_{x\in son}(B_x+E_x)\]</span></p><p><spanclass="math display">\[deg_i\varphi_i=\varphi_{fa}-E_i+\varphi_i\sum\limits_{x\inson}K_x+\sum\limits_{x\in son}(B_x+E_x)\]</span></p><p><spanclass="math display">\[deg_i\varphi_i-\varphi_i\sum\limits_{x\inson}K_x=\varphi_{fa}-E_i+\sum\limits_{x\in son}(B_x+E_x)\]</span></p><p><span class="math display">\[\varphi_i(deg_i-\sum\limits_{x\inson}K_x)=\varphi_{fa}-E_i+\sum\limits_{x\in son}(B_x+E_x)\]</span></p><p><spanclass="math display">\[\varphi_i=\frac{1}{deg_i-\sum\limits_{x\inson}K_x}\varphi_{fa}+\frac{\sum\limits_{x\inson}(B_x+E_x)-E_i}{deg_i-\sum\limits_{x\in son}K_x}\]</span></p><p>我们发现此时已经表示成 <spanclass="math inline">\(\varphi_i=K_i\varphi_{fa}+B_i\)</span>的形式了。那么：</p><p><span class="math display">\[K_i=\frac{1}{deg_i-\sum\limits_{x\inson}K_x}\]</span></p><p><span class="math display">\[B_i=\frac{\sum\limits_{x\inson}(B_x+E_x)-E_i}{deg_i-\sum\limits_{x\inson}K_x}=K_i(\sum\limits_{x\in son}(B_x+E_x)-E_i)\]</span></p><p>因为我们要求 <span class="math inline">\(i\)</span>到地面，所以特判一下叶子。叶子度数为 <spanclass="math inline">\(2\)</span>，一条边连向地面，地面电势为 <spanclass="math inline">\(0\)</span>。所以：</p><p><spanclass="math display">\[\varphi_i=\frac{\varphi_{fa}-E_i}{2}\]</span></p><p><span class="math display">\[K_i=\frac{1}{2}\]</span></p><p><span class="math display">\[B_i=\frac{-E_i}{2}\]</span></p><p>发现 <span class="math inline">\(K_i\)</span>只需要预处理一下就好了。由于链长不超过 <spanclass="math inline">\(50\)</span> ，剩下的可以暴力做。</p><h1 id="code">Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN], cnt;</span><br><span class="line"><span class="type">int</span> rt, n, m;</span><br><span class="line"><span class="type">int</span> deg[MAXN], fa[MAXN];</span><br><span class="line"><span class="type">double</span> k[MAXN], b[MAXN], sumb[MAXN], ph[MAXN], sumph[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt] = (Edge)&#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    edge[++cnt] = (Edge)&#123;u, head[v]&#125;;</span><br><span class="line">    head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    <span class="type">double</span> sumk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v != f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">init</span>(v, u);</span><br><span class="line">            sumk += k[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k[u] = <span class="number">1.0</span> / (deg[u] - sumk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sumb[fa[u]] -= b[u];</span><br><span class="line">        b[u] = (sumb[u] + sumph[u] - ph[u]) * k[u];</span><br><span class="line">        sumb[fa[u]] += b[u];</span><br><span class="line">        <span class="built_in">add</span>(fa[u], e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[v] == u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">        e = -e;</span><br><span class="line">    &#125;</span><br><span class="line">    ph[u] += e;</span><br><span class="line">    sumph[v] += e;</span><br><span class="line">    <span class="built_in">add</span>(u, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> k[u] * <span class="built_in">query</span>(fa[u]) + b[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v);</span><br><span class="line">        deg[u]++, deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_edge</span>(i, <span class="number">0</span>);</span><br><span class="line">            deg[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">1</span>) deg[i] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, <span class="built_in">query</span>(u));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u, v, e;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;e);</span><br><span class="line">            <span class="built_in">modify</span>(u, v, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在各学科交叉应用的潮流下，一道具有超前预见性的好题。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://summace.cc/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>初赛知识点整理第2版</title>
    <link href="http://summace.cc/Pre2/"/>
    <id>http://summace.cc/Pre2/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:16:07.063Z</updated>
    
    <content type="html"><![CDATA[<p>NOIP 初赛知识点整理 第2版。</p><p>温馨提示：不保证对，但也不保证错。</p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=1819306496&amp;auto=1&amp;height=66"></iframe><h1 id="一noi-史">一、NOI 史</h1><ol type="1"><li>NOI 于 <span class="math inline">\(1984\)</span> 年首次举行。</li><li>NOIP 于 <span class="math inline">\(1995\)</span> 年首次举行。</li><li>NOIP 于 <span class="math inline">\(2019\)</span> 年暂停。</li><li>CSP 于 <span class="math inline">\(2019\)</span> 年首次举行。</li><li>NOIP 于 <span class="math inline">\(2020\)</span> 年恢复。</li></ol><h1 id="二计算机发展史">二、计算机发展史</h1><ul><li><span class="math inline">\(1944\)</span>年，<strong>美籍匈牙利</strong>数学家<strong>冯·诺依曼</strong>提出计算机基本结构和工作方式的设想，为计算机的诞生和发展提供了理论基础。</li><li><span class="math inline">\(1946\)</span> 年，世界上第一台电子计算机<strong>ENIAC</strong> 在美国宾夕法尼亚大学诞生。</li></ul><table><thead><tr class="header"><th style="text-align: center;">代别</th><th style="text-align: center;">年代</th><th style="text-align: center;">电子元件</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">第一代</td><td style="text-align: center;"><spanclass="math inline">\(1946-1958\)</span></td><td style="text-align: center;">电子管</td></tr><tr class="even"><td style="text-align: center;">第二代</td><td style="text-align: center;"><spanclass="math inline">\(1959-1964\)</span></td><td style="text-align: center;">晶体管</td></tr><tr class="odd"><td style="text-align: center;">第三代</td><td style="text-align: center;"><spanclass="math inline">\(1965-1970\)</span></td><td style="text-align: center;">集成电路</td></tr><tr class="even"><td style="text-align: center;">第四代</td><td style="text-align: center;"><spanclass="math inline">\(1970-\text{今}\)</span></td><td style="text-align: center;">大规模、超大规模集成电路</td></tr></tbody></table><h1 id="三计算机著名人物及奖项">三、计算机著名人物及奖项</h1><h2 id="艾伦麦席森图灵alan-mathison-turing英国人">艾伦·麦席森·图灵(AlanMathison Turing，英国人)</h2><p>被称为计算机科学之父，人工智能之父。图灵对于人工智能的发展有诸多贡献，例如图灵曾写过一篇名为《计算机器和智能》的论文，提问“机器会思考吗？”（CanMachinesThink?），作为一种用于判定机器是否具有智能的测试方法，即图灵测试。至今，每年都有试验的比赛。此外，图灵提出的著名的图灵机模型为现代计算机的逻辑工作方式奠定了基础。</p><h2 id="约翰冯诺依曼john-von-neumann美籍匈牙利人">约翰·冯·诺依曼(Johnvon Neumann，美籍匈牙利人)</h2><p>被后人称为“现代计算机之父”、“博弈论之父”。1945年6月，冯·诺伊曼与戈德斯坦、勃克斯等人，联名发表了一篇长达101页纸的报告，即计算机史上著名的“101页报告”，是现代计算机科学发展里程碑式的文献。明确规定用二进制替代十进制运算，并将计算机分成5大组件，这一卓越的思想为电子计算机的逻辑结构设计奠定了基础，已成为计算机设计的基本原则。1951年，EDVAC计算机宣告完成。</p><h2 id="图灵奖acm-a.m-turing-award">图灵奖(ACM A.M Turing Award)</h2><p>美国计算机协会（ACM）于1966年设立的奖项，专门奖励对计算机事业作出重要贡献的个人。其名称取自世界计算机科学的先驱、英国科学家、曼彻斯特大学教授艾伦·图灵（A.M.Turing），这个奖设立目的之一是纪念这位现代计算机科学的奠基者。获奖者必须是在计算机领域具有持久而重大的先进性的技术贡献。大多数获奖者是计算机科学家。图灵奖是计算机界最负盛名的奖项，有“计算机界诺贝尔奖”之称。</p><h1 id="四linux-基本操作">四、Linux 基本操作</h1><h2 id="目录切换命令-cd">目录切换命令 <code>cd</code></h2><ul><li><code>cd xxx/</code> 切换到该目录下 <code>xxx</code> 目录</li><li><code>cd …/</code> 切换到上一层目录</li><li><code>cd /</code> 切换到系统根目录</li><li><code>cd ~</code> 切换到用户主目录</li></ul><h2 id="目录操作命令">目录操作命令</h2><ul><li><code>mkdir xxx</code> 新建名为 <code>xxx</code> 的文件夹（可能需要<code>sudo</code>）</li><li><code>ls xxx</code> 显示 <code>xxx</code> 下所有文件和目录</li><li><code>ls -a</code> 显示所有文件和目录（包括隐藏文件）</li><li><code>ls -l</code> 显示所有文件和目录（包括详细信息）</li><li><code>find xxx -name 'yyy'</code> 寻找 <code>xxx</code> 目录下名为<code>yyy</code> 相关的文件</li><li><code>mv xxx yyy</code> 重命名（目录文件均可）</li><li><code>cp -r xxx yyy</code> 把 <code>xxx</code> 拷贝到<code>yyy</code> 位置</li><li><code>rm [-rf] xxx</code> 删除 <code>xxx</code></li></ul><h2 id="文件操作命令">文件操作命令</h2><ul><li><code>touch xxx</code> 新建 <code>xxx</code> 文件</li><li><code>cat xxx</code> 显示 <code>xxx</code> 文件</li><li><code>vim xxx</code> 修改 <code>xxx</code> 文件</li></ul><h1 id="五计算机基础架构">五、计算机基础架构</h1><p>现代计算机基本为冯·诺依曼架构，即硬件部分分为五部分：运算器、控制器、存储器、输入设备、输出设备。</p><h2 id="运算器">运算器</h2><p>计算机硬件中的运算器主要功能是对数据和信息进行运算和加工。运算器包括以下几个部分：通用寄存器、状态寄存器、累加器和关键的算术逻辑单元。运算器可以进行算术计算（加减乘除）和逻辑运算（与或非）。</p><h2 id="控制器">控制器</h2><p>控制器和运算器共同组成了中央处理器<spanclass="math inline">\((CPU)\)</span>。控制器可以看作计算机的大脑和指挥中心，它通过整合分析相关的数据和信息，可以让计算机的各个组成部分有序地完成指令。</p><h2 id="存储器">存储器</h2><p>顾名思义，存储器就是计算机的记忆系统，是计算机系统中的记事本。而和记事本不同的是，存储器不仅可以保存信息，还能接受计算机系统内不同的信息并对保存的信息进行读取。存储器由主存和辅存组成，主存就是通常所说的内存，分为<span class="math inline">\(RAM\)</span> 和 <spanclass="math inline">\(ROM\)</span>两个部分。辅存即外存，但是计算机在处理外存的信息时，必须首先经过内外存之间的信息交换才能够进行。</p><h1 id="六计算机硬件系统">六、计算机硬件系统</h1><h2 id="cpu中央处理器"><spanclass="math inline">\(CPU\)</span>(中央处理器)</h2><p>由运算器、控制器和一些寄存器组成；作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。<span class="math inline">\(CPU\)</span>的主要性能指标是主频和字长。</p><h3 id="主频">主频</h3><p>主频是指计算机 <span class="math inline">\(CPU\)</span>的时钟频率，它在很大程度上决定了计算机的运算速度。一般时钟频率越高，运算速度就越快。主频的单位一般是<span class="math inline">\(MHz\)</span>（兆赫）或 <spanclass="math inline">\(GHz\)</span>（吉赫）。</p><h3 id="字长">字长</h3><p>字长是指一台计算机所能处理的二进制代码的位数。计算机的字长直接影响到它的精度、功能和速度。字长愈长，能表示的数值范围就越大，计算出的结果的有效位数也就越多；字长愈长，能表示的信息就越多，机器的功能就更强。常用的有<span class="math inline">\(32\)</span> 位、<spanclass="math inline">\(64\)</span> 位字长。</p><h2 id="存储器-1">存储器</h2><p>存储器的主要功能是用来保存各类程序的数据信息。存储器可分为主存储器和辅助存储器两类。</p><h3 id="主存储器">主存储器</h3><p>主存储器（也称为内存储器），属于主机的一部分。用于存放系统当前正在执行的数据和程序，属于临时存储器。</p><p>它和 <span class="math inline">\(CPU\)</span>一起构成了计算机的主机部分，它存储的信息可以被 <spanclass="math inline">\(CPU\)</span>直接访问。内存由半导体存储器组成，存取速度较快，但一般容量较小。</p><p>内存储器通常可以分为随机存储器 <spanclass="math inline">\(RAM\)</span>、只读存储器 <spanclass="math inline">\(ROM\)</span> 和高速缓冲存储器 <spanclass="math inline">\(Cache\)</span> 三种。</p><ul><li><span class="math inline">\(RAM(Random\ Access\ Memory)\)</span>是一种读写存储器，其内容可以随时根据需要读出，也可以随时重新写入新的信息。当电源电压去掉时，RAM中保存的信息都将全部丢失。</li><li><span class="math inline">\(ROM(Read-Only\ Memory)\)</span>是一种内容只能读出而不能写入和修改的存储器，其存储的信息是在制作该存储器时就被写入的。在计算机运行过程中，<spanclass="math inline">\(ROM\)</span>中的信息只能被读出，而不能写入新的内容。计算机断电后，<spanclass="math inline">\(ROM\)</span>中的信息不会丢失。它主要用于检查计算机系统的配置情况并提供最基本的输入/输出<spanclass="math inline">\((I/O)\)</span>控制程序。</li><li><span class="math inline">\(Cache\)</span>是高速缓冲存储器。由于计算机的 <span class="math inline">\(CPU\)</span>速度的不断提高，RAM的速度很难满足高速 <spanclass="math inline">\(CPU\)</span>的要求，所以在读/写系统内存都要加入等待的时间，这对高速 <spanclass="math inline">\(CPU\)</span> 来说是一种极大的浪费。<spanclass="math inline">\(Cache\)</span> 是指在 <spanclass="math inline">\(CPU\)</span>与内存之间设置的一级或两级高速小容量存储器，固化在主板上。在计算机工作时，系统先将数据由外存读入<span class="math inline">\(RAM\)</span> 中，再由 <spanclass="math inline">\(RAM\)</span> 读入 <spanclass="math inline">\(Cache\)</span> 中，然后 <spanclass="math inline">\(CPU\)</span> 直接从 <spanclass="math inline">\(Cache\)</span> 中取数据进行操作。</li></ul><h3 id="辅助存储器">辅助存储器</h3><p>辅助存储器（也称外存储器），它属于外部设备。用于存放暂不用的数据和程序，属于永久存储器。</p><p>它的容量一般都比较大，而且大部分可以移动，便于在不同计算机之间进行信息交流。在微型计算机中，常用的外存有软盘、硬盘、闪存和光盘。</p><ul><li><strong>软盘存储器</strong>由软盘、软盘驱动器和软盘适配器三部分组成。软盘是活动的存储介质，软盘驱动器是读写装置，软盘适配器是软盘驱动器与主机连接的接口。软盘驱动器安装在主机箱内，软盘驱动器插槽暴露在主机箱的前面板上，可方便地插入或取出软盘。 </li><li><strong>硬盘存储器</strong>是由电机和硬盘组成的，一般置于主机箱内。硬盘是涂有磁性材料的磁盘组件，用于存放数据。硬盘的机械转轴上串有若干个盘片，每个盘片的上下两面各有一个读/写磁头，与软盘磁头不同，硬盘的磁头不与磁盘表面接触，它们在离盘片面百万分之一英寸的气垫上。硬盘是一个非常精密的机械装置，磁道间只有百万分之几英寸的间隙，磁头传动装置必须把磁头快速而准确地移到指定的磁道上。 </li><li><strong>闪存</strong>又名优盘，是在存储速度与容量上介于软盘与硬盘之间的一种外部存储器。  </li><li><strong>光盘</strong>的存储介质不同于磁盘，它属于另一类存储器。由于光盘的容量大、存取速度较快、不易受干扰等特点，其应用越来越广泛。光盘根据其制造材料和记录信息方式的不同一般分为三类：只读光盘、一次写入型光盘和可擦写光盘。</li></ul><h1 id="七计算机语言">七、计算机语言</h1><p>计算机语言可以分为三类：机器语言、汇编语言、高级语言。</p><h2 id="机器语言">机器语言</h2><p>计算机最早的语言处理程序是机器语言，它是计算机能直接识别的语言，而且速度快。机器语言是用二进制代码来编写计算机程序，因此又称二进制语言。</p><h2 id="汇编语言">汇编语言</h2><p>由于机器语言的记忆困难，汇编语言开始用一些符号代替机器指令。但是用汇编语言编写的源程序不能被计算机直接识别，必须使用特定程序将用汇编语言写的源程序翻译和连接成能被计算机直接识别的二进制代码。</p><h2 id="高级语言">高级语言</h2><h3 id="翻译方式">翻译方式</h3><p>计算机并不能直接地接受和执行用高级语言编写的源程序，源程序在输入计算机时，通过程序翻译成机器语言形式的目标程序，通常有两种方式，即编译方式和解释方式。</p><ul><li>编译方式：编译方式的翻译工作由编译程序来完成，它先将整个源程序都转换成二进制代码，生成目标程序，把目标程序和可执行程序连接。</li><li>解释方式：源程序进入计算机时，解释程序边扫描边解释，对源程序的语句解释一条，执行一条，不产生目标程序。</li></ul><h3 id="面向对象与面向过程">面向对象与面向过程</h3><ul><li><p>面向过程 <span class="math inline">\((Procedure\Oriented)\)</span>：把事情拆分成几个步骤（相当于拆分成一个个的方法和数据），然后按照一定的顺序执行。</p></li><li><p>面向对象 <span class="math inline">\((Object\Oriented)\)</span>：面向对象会把事物抽象成对象的概念，先抽象出对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法。</p></li></ul><h3 id="常见语言">常见语言</h3><table><thead><tr class="header"><th style="text-align: center;">语言</th><th style="text-align: center;">面向对象/面向过程</th><th style="text-align: center;">翻译方式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">面向过程</td><td style="text-align: center;">编译方式</td></tr><tr class="even"><td style="text-align: center;">C++</td><td style="text-align: center;">半面向对象</td><td style="text-align: center;">编译方式</td></tr><tr class="odd"><td style="text-align: center;">Java</td><td style="text-align: center;">面向对象</td><td style="text-align: center;">不属于（更接近于解释方式）</td></tr><tr class="even"><td style="text-align: center;">Python</td><td style="text-align: center;">面向对象</td><td style="text-align: center;">解释方式</td></tr><tr class="odd"><td style="text-align: center;">Pascal</td><td style="text-align: center;">面向对象</td><td style="text-align: center;">编译方式</td></tr><tr class="even"><td style="text-align: center;">Fortran</td><td style="text-align: center;">面向过程</td><td style="text-align: center;">编译方式</td></tr></tbody></table><h1 id="八网络及网络协议">八、网络及网络协议</h1><p>所谓计算机网络，就是利用通信线路和设备，把分布在不同地理位置上的多台计算机连接起来。计算机网络是现代通信技术与计算机技术相结合的产物。</p><figure><img src="https://z3.ax1x.com/2021/09/07/hT3wND.jpg" alt="协议" /><figcaption aria-hidden="true">协议</figcaption></figure><h2 id="网络协议">网络协议</h2><p>网络中计算机与计算机之间的通信依靠协议进行。协议是计算机收、发数据的规则。</p><ol type="1"><li><p>HTTP协议：基于TCP协议，超文本传输协议，对应于应用层，用于如何封装数据。也就是在底层是基于socket，http只不过是在收发数据的时候定义了很多规则，http头信息之类。</p></li><li><p>TCP/IP协议：关注的是客户端与服务器之间的数据传输是否成功（三次握手，传输失败会重发）。传输层协议，主要解决数据如何在网络中传输.</p></li><li><p>TCP/UDP协议:传输控制协议，对应于传输层，主要解决数据在网络中的传输。</p></li><li><p>IP 协议：对应于网络层，同样解决数据在网络中的传输。</p></li><li><p>TCP 协议：对应于传输层，是基于网络层的IP协议。</p></li><li><p>socket：属于传输层协议，是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p></li></ol><h3id="电子邮件协议全部隶属于tcpip协议">电子邮件协议(全部隶属于TCP/IP协议)</h3><ol type="1"><li>SMTP 协议：简单邮件传输协议(TCP25端口)；</li><li>POP3 协议：POP邮局协议第三版本(TCP110端口)；</li><li>IMAP 协议：互联网信息访问协议(TCP143端口)；</li></ol><h2 id="网络简述">网络简述</h2><ol type="1"><li>LAN：局域网</li><li>WAN：广域网</li><li>MAN：城域网</li><li>WLAN：无线局域网</li><li>WWAN：无线广域网</li><li>WMAN：无线城域网</li></ol><h1 id="九进制转换">九、进制转换</h1><h2 id="概述">概述</h2><p>常见进制有十进制、八进制、二进制、十六进制。</p><p><span class="math inline">\(N\)</span>进制逢<spanclass="math inline">\(N\)</span>进一，十六进制 <spanclass="math inline">\(10-15\)</span> 分别用 <spanclass="math inline">\(A-F\)</span> 表示。</p><p><span class="math inline">\(N\)</span>进制的数一般用 <spanclass="math inline">\((\overline{qwq})_{N}\)</span> 表示。</p><h2 id="十进制转x进制">十进制转<spanclass="math inline">\(X\)</span>进制</h2><p>短除法。</p><h2 id="x进制转十进制"><spanclass="math inline">\(X\)</span>进制转十进制</h2><p><span class="math inline">\((N)_{X}\)</span> 转为 <spanclass="math inline">\((M)_{10}\)</span>。</p><p>记 <span class="math inline">\(N_i\)</span> 表示 <spanclass="math inline">\((N)_{X}\)</span> 从低位向高位第 <spanclass="math inline">\(i\)</span> 位的数，<spanclass="math inline">\(SW_N\)</span> 为 <spanclass="math inline">\((N)_{X}\)</span> 的数位数。</p><p><span class="math inline">\(M = \sum\limits_{i=1}^{SW_N} N_i\timesX^{i-1}\)</span></p><h1 id="十信息编码">十、信息编码</h1><h2 id="二进制编码">二进制编码</h2><ul><li>原码（原码表示法）：十进制数直接转换来的二进制数。值得注意的是，原码的最高位是符号位：整数为<span class="math inline">\(0\)</span>，负数为 <spanclass="math inline">\(1\)</span>。 <spanclass="math inline">\(x=1100110\)</span>，则<spanclass="math inline">\([x]原=01100110\)</span>； <spanclass="math inline">\(x=-1100111\)</span>，则<spanclass="math inline">\([x]原=11100111\)</span>。</li><li>反码：正数的反码是本身，负数的反码是其除符号位之外的所有位按位取反的结果。<span class="math inline">\(x=1100110\)</span>，则<spanclass="math inline">\([x]反=01100110\)</span>； <spanclass="math inline">\(x=-1100111\)</span>，则<spanclass="math inline">\([x]反=10011000\)</span>。</li><li>补码：正数的补码是其本身，复数的补码是其反码加一。 <spanclass="math inline">\(x=1100110\)</span>，则<spanclass="math inline">\([x]补=01100110\)</span>； <spanclass="math inline">\(x=-1100111\)</span>，则<spanclass="math inline">\([x]补=10011001\)</span>。</li></ul><h2 id="textascii-码"><span class="math inline">\(\text{ASCII}\)</span>码</h2><p><span class="math inline">\(\text{ASCII}\)</span>编码是由美国国家标准委员会制定的一种包括数字、字母、通用符号和控制符号在内的字符编码集，全称叫美国国家信息交换标准代码。</p><figure><imgsrc="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.51wendang.com%2Fpic%2F7f94132e26a37161b8794dd4%2F1-1355-png_6_0_0_0_0_959_1355_959_1355-959-0-0-959.jpg&amp;refer=http%3A%2F%2Fimg.51wendang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664800854&amp;t=7ad119d038c8e89713f2b37400ee1179"alt="ASCII" /><figcaption aria-hidden="true">ASCII</figcaption></figure><h1 id="十一计算机安全常识">十一、计算机安全常识</h1><p>计算机病毒是一种人为制造的能够侵入计算机系统并给计算机带来故障的程序或指令集合。</p><p>计算机病毒具有传播性、潜伏性、破坏性与隐蔽性的特点。</p><h1 id="十二运算相关知识">十二、运算相关知识</h1><h2 id="逻辑运算">逻辑运算</h2><ol type="1"><li><p>逻辑与：<span class="math inline">\(\&amp;\&amp;\)</span> 或<span class="math inline">\(∧\)</span>，同 <spanclass="math inline">\(T\)</span> 则 <spanclass="math inline">\(T\)</span>，否则为 <spanclass="math inline">\(F\)</span>。</p></li><li><p>逻辑或：<span class="math inline">\(||\)</span> 或 <spanclass="math inline">\(∨\)</span>，有 <spanclass="math inline">\(T\)</span> 则 <spanclass="math inline">\(T\)</span>，否则为 <spanclass="math inline">\(F\)</span>。</p></li><li><p>逻辑非：<span class="math inline">\(!\)</span> 或 <spanclass="math inline">\(┐\)</span>，为 <spanclass="math inline">\(T\)</span> 则 <spanclass="math inline">\(F\)</span>，反之亦然。</p></li><li><p>逻辑异或：^ 或 <span class="math inline">\(⊕\)</span>，同为 <spanclass="math inline">\(F\)</span>，异为 <spanclass="math inline">\(T\)</span>。</p></li></ol><h2 id="位运算">位运算</h2><ol type="1"><li>按位与：<spanclass="math inline">\(\&amp;\)</span>，类似于逻辑与。</li><li>按位或：<span class="math inline">\(|\)</span>，类似于逻辑或。</li><li>按位反：~，类似于逻辑非。</li><li>左移：<span class="math inline">\(&lt;&lt;\)</span>，左移 <spanclass="math inline">\(x\)</span> 位相当于乘 <spanclass="math inline">\(2^x\)</span>。</li><li>右移：<span class="math inline">\(&gt;&gt;\)</span>，右移 <spanclass="math inline">\(x\)</span> 位相当于除 <spanclass="math inline">\(2^x\)</span>。</li></ol><h1 id="十三图论相关">十三、图论相关</h1><h2 id="概念">概念</h2><ul><li><strong>图(Graph)</strong> 是一个二元组 <spanclass="math inline">\(G=(V(G),E(G))\)</span>，其中 <spanclass="math inline">\(V(G)\)</span> 为点集，<spanclass="math inline">\(E(G)\)</span> 为边集。</li><li><strong>无向图(Undirected Graph)</strong>，边是双向的。</li><li><strong>有向图(Directed Graph)</strong>，边是单向的。</li><li><strong>自环(Loop)</strong>，对于某条边 <spanclass="math inline">\(e=(u,u)\)</span>，则称其为一个自环。</li><li><strong>重边(Multiple Edge)</strong>，图中存在两个相同的边。</li><li><strong>简单图(Simple Graph)</strong>，一个图中没有自环和重边。</li><li><strong>完全图(CompleteGraph)</strong>，任意两点都有边相连。若一个图的点为 <spanclass="math inline">\(n\)</span>，则边的个数为 <spanclass="math inline">\(\frac{n(n-1)}{2}\)</span></li><li><strong>平面图</strong>，没有边相交的图。四个点的完全图是一个平面图，五个点完全图任意去掉一条边都是平面图。</li><li><strong>连通图(Connected Graph)</strong>，任意两点都可以到达。</li><li><strong>有向无环图(DAG)</strong>，顾名思义。它可以拓扑排序。</li><li><strong>树(Tree)</strong>，无向无环连通图，且 <spanclass="math inline">\(n\)</span> 个节点的树有 <spanclass="math inline">\(n-1\)</span> 条边。</li><li><strong>森林(forest)</strong>：每个连通分量（连通块）都是树的图。按照定义，棵树也是森林。</li><li><strong>结点的深度(depth)</strong>：到根结点的路径上的边数。</li><li><strong>树的高度(height)</strong>：所有结点的深度的最大值。</li><li><strong>叶结点（leaf node）</strong>：没有子结点的结点。</li><li><strong>父亲（parentnode）</strong>：对于除根以外的每个结点，定义为从该结到根路径上的第二个结点。</li><li><strong>祖先（ancestor）</strong>：一个结点到根结点的路径上，<strong>包括它本身</strong>的所有节点。</li></ul><h1 id="十四排列组合">十四、排列组合</h1><h2 id="加法原理与乘法原理">加法原理与乘法原理</h2><ul><li>加法原理：有 <span class="math inline">\(n\)</span> 类元素，第 <spanclass="math inline">\(i\)</span> 类有 <spanclass="math inline">\(c_i\)</span>个元素，每类选一个元素，求方案数。</li><li>乘法原理：有 <span class="math inline">\(n\)</span> 组元素，第 <spanclass="math inline">\(i\)</span> 组有 <spanclass="math inline">\(c_i\)</span>个元素，每组选一个元素，求方案数。</li><li>加法原理实际上是分类，乘法原理实际上是分步。</li></ul><h2 id="排列与组合">排列与组合</h2><h3 id="排列">排列</h3><p>在 <span class="math inline">\(n\)</span>个数中<strong>有序</strong>选择 <span class="math inline">\(k\)</span>个数，方案数记为：</p><p><span class="math inline">\(A_{n}^{k}=\frac{n!}{(n-k)!}\)</span></p><h3 id="组合">组合</h3><p>在 <span class="math inline">\(n\)</span>个数中<strong>无序</strong>选择 <span class="math inline">\(k\)</span>个数，方案数记为：</p><p><spanclass="math inline">\(C_{n}^{k}=\frac{n!}{k!(n-k)!}\)</span></p><p>在竞赛中也常记为：</p><p><span class="math inline">\({n\choose k} =\frac{n!}{k!(n-k)!}\)</span></p><p>组合数的一些性质：</p><ul><li><span class="math inline">\({n\choose k}={n\choose n-k}\)</span>考虑从 <span class="math inline">\(n\)</span> 个中选 <spanclass="math inline">\(k\)</span> 个相当于从 <spanclass="math inline">\(n\)</span> 个中不选 <spanclass="math inline">\(n-k\)</span> 个。</li><li>递推计算：<span class="math inline">\({n\choose k}={n-1\choosek}+{n-1\choose k-1}\)</span> 从 <span class="math inline">\(n\)</span>个物品里面选 <span class="math inline">\(k\)</span> 个出来，考虑第 <spanclass="math inline">\(n\)</span> 个选不选。如果选就变成了从 <spanclass="math inline">\(n−1\)</span> 个里选 <spanclass="math inline">\(k-1\)</span>；否则就是从 <spanclass="math inline">\(n-1\)</span> 个里选 <spanclass="math inline">\(k\)</span>。</li><li>二项式定理：<spanclass="math inline">\((a+b)^n=\sum\limits_{i=0}^{n}{n\choosei}a^ib^{n-i}\)</span></li><li><span class="math inline">\(\sum\limits_{i=0}^{n}{n\choosei}=2^n\)</span></li><li><span class="math inline">\({a+b\choosek}=\sum\limits_{i=0}^{k}{a\choose i}{b\choose k-i}\)</span></li></ul><h2 id="答题方法">答题方法</h2><h3 id="枚举法">枚举法</h3><p>最基本的方法，当题目范围不大的时候可以考虑枚举。</p><h3 id="插板法">插板法</h3><p>例：学校师生合影，共 <span class="math inline">\(8\)</span>个学生，<span class="math inline">\(4\)</span>个老师，要求老师在学生中间，且老师互不相邻，共有多少种不同的合影方式？</p><p>解：先排学生共有 <span class="math inline">\(A_{8}^{8}\)</span>种排法，然后把老师插入学生之间的空档，共有 <spanclass="math inline">\(7\)</span> 个空档可插，选其中的 <spanclass="math inline">\(4\)</span> 个空档,共 <spanclass="math inline">\(A_{7}^{4}\)</span>种选法。根据乘法原理，共有的不同坐法 <spanclass="math inline">\(A_{8}^{8}A_{7}^{4}\)</span> 种。</p><h3 id="捆绑法">捆绑法</h3><p>例：<span class="math inline">\(5\)</span> 个男生 <spanclass="math inline">\(3\)</span> 个女生排成一排，<spanclass="math inline">\(3\)</span>个女生要排在一起，有多少种不同的排法？</p><p>解：因为女生要排在一起，所以可以将 <spanclass="math inline">\(3\)</span> 个女生看成是一个人，与 <spanclass="math inline">\(5\)</span> 个男生作全排列，有 <spanclass="math inline">\(A_{6}^{6}\)</span> 种排法，其中女生内部也有 <spanclass="math inline">\(A_{3}^{3}\)</span> 种排法，根据乘法原理，共有<span class="math inline">\(A_{6}^{6}A_{3}^{3}\)</span>种不同的排法。</p><h3 id="对等法">对等法</h3><p>例：学校安排考试科目 <span class="math inline">\(9\)</span>门，语文要在数学之前考，有多少种不同的安排顺序?</p><p>解：不加任何限制条件，整个排法有 <spanclass="math inline">\(A_{9}^{9}\)</span>种，“语文安排在数学之前考”与“数学安排在语文之前考”的排法是相等的，所以语文安排在数学之前考的排法共<span class="math inline">\(\frac{1}{2}A_{9}^{9}\)</span>种。</p><h2 id="卡特兰数">卡特兰数</h2><p>卡特兰数的定义如下：</p><p><span class="math inline">\(C_0=0,C_1=1\)</span></p><p><spanclass="math inline">\(C_n=\sum\limits_{i=0}^{n-1}C_iC_{n-i-1}(n\geq2)\)</span></p><p>非递推式：</p>$C_n={2n\choose n}-{2n\choose n+1}=\frac{{2n\choose n}}{n+1}$<p>卡特兰数的组合意义：</p><ol type="1"><li><span class="math inline">\(n\)</span> 个点的二叉树</li><li><span class="math inline">\(n+1\)</span> 个点的区分儿子顺序的树</li><li><span class="math inline">\(2n+1\)</span>个点的二叉树，满足没有儿子个数为 <span class="math inline">\(1\)</span>的节点</li><li>长度为 <span class="math inline">\(2n\)</span> 的合法括号匹配</li><li>长度为 <span class="math inline">\(2n\)</span>的字符串的数量，其中有 <span class="math inline">\(n\)</span> 个 <spanclass="math inline">\(0\)</span>，<span class="math inline">\(n\)</span>个 <span class="math inline">\(1\)</span>，且对于任意的 <spanclass="math inline">\(i\)</span>，<span class="math inline">\(0\)</span>的数量都不少于 <span class="math inline">\(1\)</span> 的。</li><li><span class="math inline">\(2\times n\)</span> 的杨表数量。</li></ol><p>证明略。</p><h2 id="容斥原理">容斥原理</h2><p><spanclass="math inline">\(\left|\bigcup\limits_{i=1}^{n}S_i\right|=\sum\limits_{m=1}^n(-1)^{m-1}\sum\limits_{a_i&lt;a_{i+1}}\left|\bigcap\limits_{i=1}^mS_{a_i}\right|\)</span></p><p>简单的小应用：</p><p><span class="math inline">\(|A\cup B\cup C|=|A|+|B|+|C|-|A\capB|-|B\cap C|-|C\cap A|+|A\cap B\cap C|\)</span></p><h1 id="十五时空复杂度相关">十五、时空复杂度相关</h1><ul><li>时间复杂度：算法的时间复杂度<span class="math inline">\(\text{(TimeComplexity)}\)</span>是指算法所需要的计算工作量，用算法所执行的基本运算次数来度量。</li><li>空间复杂度：算法的空间复杂度<span class="math inline">\(\text{(SpaceComplexity)}\)</span>是指执行这个算法所需要的内存空间。</li></ul><h2 id="主定理">主定理</h2><p>在算法分析中，主定理 <span class="math inline">\(\text{(mastertheorem)}\)</span> 提供了用渐近符号（大 <spanclass="math inline">\(O\)</span>符号）表示许多由分治法得到的递推关系式的方法。</p><h3 id="支配理论">支配理论</h3><p>假设有递归关系式：</p>$$T(n)=aT\left(\frac{n}{b}\right)+f(n),其中a\geq 1,b> 1$$<p>其中：</p><ul><li><span class="math inline">\(n\)</span> 为问题规模；</li><li><span class="math inline">\(a\)</span> 为递归的子问题数量；</li><li><span class="math inline">\(\frac{n}{b}\)</span>为每个子问题的规模（假设每个子问题的规模基本相同）；</li><li><span class="math inline">\(f(n)\)</span>为递归以外进行的计算工作。</li></ul><h3 id="情形一">情形一</h3><p>若 <span class="math inline">\(f(n)&lt;n^{\log_ba}\)</span>（多项式的小于），即 <span class="math inline">\(\exist\epsilon&gt;0,有f(n)=\Theta(n^{\log_{b}a-\epsilon})\)</span>，则<spanclass="math inline">\(T(n)=\Theta(n^{\log_{b}a})\)</span></p><h3 id="情形二">情形二</h3><p>若 <span class="math inline">\(f(n)=n^{\log_b a}\)</span>，即 <spanclass="math inline">\(\exist \epsilon\geq0,有f(n)=\Theta(n^{\log_{b}a}\log^\epsilon n)\)</span>，则<spanclass="math inline">\(T(n)=\Theta(n^{\log_{b}a}\log^{\epsilon+1}n)\)</span></p><h3 id="情形三">情形三</h3><p>若 <span class="math inline">\(f(n)&gt;n^{\log_ba}\)</span>（多项式的大于），即 <span class="math inline">\(\exist\epsilon&gt;0,有f(n)=\Omega(n^{\log_{b}a+\epsilon})\)</span>，同时存在常数 <spanclass="math inline">\(c&lt;1\)</span> 以及充分大的 <spanclass="math inline">\(n\)</span>，满足 <spanclass="math inline">\(af\left(\frac{n}{b}\right)\leqcf(n)\)</span>，则<spanclass="math inline">\(T(n)=\Theta(f(n))\)</span></p><h2 id="常见排序算法与其时空复杂度">常见排序算法与其时空复杂度</h2><table><thead><tr class="header"><th style="text-align: center;">排序方法</th><th style="text-align: center;">时间复杂度</th><th style="text-align: center;">辅助存储空间复杂度</th><th style="text-align: center;">稳定性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">插入排序</td><td style="text-align: center;"><spanclass="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;">冒泡排序</td><td style="text-align: center;"><spanclass="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="odd"><td style="text-align: center;">选择排序</td><td style="text-align: center;"><spanclass="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="even"><td style="text-align: center;">快速排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)-O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(\logn)-O(n)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="odd"><td style="text-align: center;">希尔排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="even"><td style="text-align: center;">堆排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="odd"><td style="text-align: center;">归并排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(n)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;">基数排序</td><td style="text-align: center;"><spanclass="math inline">\(O(d(n+r))\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(rd+1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="odd"><td style="text-align: center;">桶排序</td><td style="text-align: center;"><span class="math inline">\(O(\max\{value\})\)</span></td><td style="text-align: center;"><spanclass="math inline">\(O(\max\{value\})\)</span></td><td style="text-align: center;">稳定</td></tr></tbody></table><h1 id="十六后记">十六、后记</h1><h2 id="说些什么">说些什么</h2><p>又是一年初赛季，回首过去的一篇<ahref="https://w-rb.github.io/Pre/">NOIP初赛知识点整理</a>和过去忐忑的初赛经历，发现很多不足之处，遂写下本篇。仓促之下写完，也许未来还会有修修补补，也祝我们都能在初赛中取得好成绩。</p><h2 id="参考与鸣谢">参考与鸣谢</h2><h3 id="参考">参考</h3><ul><li><ahref="https://blog.csdn.net/KImdaML/article/details/116570033">Linux的基础操作_KIMdamI</a></li><li><ahref="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC">约翰·冯·诺依曼_WikiPedia</a></li><li><ahref="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5">艾伦·图灵_WikiPedia</a></li><li><ahref="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96">图灵奖_WikiPedia</a></li><li><ahref="https://blog.csdn.net/m0_63725962/article/details/123057876">面向对象和面向过程（总结版）_程序员这么可爱</a></li><li><a href="https://oi-wiki.org/graph/tree-basic/">树_OI-Wiki</a></li><li><a href="https://oi-wiki.org/graph/concept/">图_OI-Wiki</a></li><li>《信息学奥赛一本通 初赛篇》</li><li>历届 NOIP/CSP 初赛原题。</li><li>RainAir's PPT</li></ul><h3 id="鸣谢">鸣谢</h3><ul><li><span class="math inline">\(\text{EXODUS}\)</span>对本文的审查。</li><li><span class="math inline">\(\text{lwj}\)</span> 对本文的勘误。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;NOIP 初赛知识点整理 第2版。&lt;/p&gt;
&lt;p&gt;温馨提示：不保证对，但也不保证错。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>初赛知识点整理</title>
    <link href="http://summace.cc/Pre/"/>
    <id>http://summace.cc/Pre/</id>
    <published>2021-09-01T00:00:00.000Z</published>
    <updated>2023-08-03T13:03:43.095Z</updated>
    
    <content type="html"><![CDATA[<p>NOIP 初赛知识点整理。</p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=1498613705&amp;auto=1&amp;height=66"></iframe><h1 id="一信息学史">一、信息学史</h1><ol type="1"><li>第一台电子计算机：<spanclass="math inline">\(\text{ENIAC}\)</span>，美国宾夕法尼亚大学，1946年2月14日。</li><li><span class="math inline">\(\text{NOI}\)</span> 于<strong>1984年</strong> 首次举行。</li><li><span class="math inline">\(\text{NOIP}\)</span> 于<strong>1995年</strong> 首次举行。</li><li><span class="math inline">\(\text{NOIP}\)</span> 于<strong>2019年</strong> 暂停。</li><li><span class="math inline">\(\text{CSP}\)</span> 于<strong>2019年</strong> 首次举行。</li><li><span class="math inline">\(\text{NOIP}\)</span> 于<strong>2020年</strong> 恢复。</li><li><strong>2022年</strong>后，<spanclass="math inline">\(\text{NOI}\)</span> 系列赛事将停止对<strong>Pascal，C</strong> 语言的支持，仅允许使用 <strong>C++</strong>语言。</li></ol><h1 id="二信息学著名人物与奖项">二、信息学著名人物与奖项</h1><ol type="1"><li>图灵：艾伦·麦西森·图灵(Alan Mathison Turing)，被称为<strong>计算机科学之父</strong>、<strong>人工智能之父</strong>。</li><li>图灵奖：计算机界最高奖。</li><li>冯·诺依曼：约翰·冯·诺依曼(John vonNeumann)，<strong>现代计算机之父</strong>，<strong>博弈论之父</strong>，奠基现代计算机基本结构(冯·诺依曼体系计算机)。</li><li>姚期智，唯一一位华籍图灵奖获得者，清华大学人工智能姚班教授。</li></ol><h1 id="三现代计算机基础结构">三、现代计算机基础结构</h1><h2 id="冯诺依曼架构">冯·诺依曼架构</h2><p>五大部分：</p><h3 id="运算器">运算器</h3><p>计算机硬件中的运算器主要功能是对数据和信息进行运算和加工。运算器包括以下几个部分：通用寄存器、状态寄存器、累加器和关键的算术逻辑单元。运算器可以进行算术计算（加减乘除）和逻辑运算（与或非）。</p><h3 id="控制器">控制器</h3><p>控制器和运算器共同组成了中央处理器（CPU）。控制器可以看作计算机的大脑和指挥中心，它通过整合分析相关的数据和信息，可以让计算机的各个组成部分有序地完成指令。</p><h3 id="存储器">存储器</h3><p>顾名思义，存储器就是计算机的记忆系统，是计算机系统中的记事本。而和记事本不同的是，存储器不仅可以保存信息，还能接受计算机系统内不同的信息并对保存的信息进行读取。存储器由主存和辅存组成，主存就是通常所说的内存，分为RAM和ROM两个部分。辅存即外存，但是计算机在处理外存的信息时，必须首先经过内外存之间的信息交换才能够进行。</p><h3 id="输入设备">输入设备</h3><p>略。</p><h3 id="输出设备">输出设备</h3><p>略。</p><h2 id="计算机硬件系统">计算机硬件系统</h2><h3 id="中央处理器cpu">中央处理器(CPU)</h3><p>作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。由运算器和控制器组成。</p><p>目前知名品牌有 <span class="math inline">\(\text{Intel}\)</span> 和<span class="math inline">\(\text{AMD}\)</span>。</p><h3 id="存储器-1">存储器</h3><h4 id="只读存储器rom">只读存储器(ROM)</h4><p>以非破坏性读出方式工作，只能读出无法写入信息。信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器。</p><p>简要：断电不消失数据。</p><h4 id="随机存储器ram">随机存储器(RAM)</h4><p>是与CPU直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。RAM工作时可以随时从任何一个指定的地址写入（存入）或读出（取出）信息。它与ROM的最大区别是数据的易失性，即一旦断电所存储的数据将随之丢失。RAM在计算机和数字系统中用来暂时存储程序、数据和中间结果。</p><p>简要：断电消失数据。</p><h1 id="四网络及网络协议">四、网络及网络协议</h1><figure><img src="https://z3.ax1x.com/2021/09/07/hT3wND.jpg" alt="协议" /><figcaption aria-hidden="true">协议</figcaption></figure><h2 id="协议简述">协议简述</h2><ol type="1"><li><p>HTTP协议：基于TCP协议，超文本传输协议，对应于应用层，用于如何封装数据.。也就是在底层是基于socket，http只不过是在收发数据的时候定义了很多规则，http头信息之类。</p></li><li><p>TCP/IP协议：关注的是客户端与服务器之间的数据传输是否成功（三次握手，传输失败会重发）。传输层协议，主要解决数据如何在网络中传输；</p></li><li><p>TCP/UDP协议:传输控制协议，对应于传输层，主要解决数据在网络中的传输。</p></li><li><p>IP 协议：对应于网络层，同样解决数据在网络中的传输。</p></li><li><p>TCP协议：对应于传输层，是基于网络层的IP协议。</p></li><li><p>socket：属于传输层协议，是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p></li></ol><h3id="电子邮件协议全部隶属于tcpip协议">电子邮件协议(全部隶属于TCP/IP协议)</h3><ol type="1"><li>SMTP协议：简单邮件传输协议(TCP25端口)；</li><li>POP3协议：POP邮局协议第三版本(TCP110端口)；</li><li>IMAP协议：互联网信息访问协议(TCP143端口)；</li></ol><h2 id="网络简述">网络简述</h2><ol type="1"><li>LAN：局域网</li><li>WAN：广域网</li><li>MAN：城域网</li><li>WLAN：无线局域网</li><li>WWAN：无线广域网</li><li>WMAN：无线城域网</li></ol><h1 id="五计算机基本常识">五、计算机基本常识</h1><h2 id="存储单位换算">存储单位换算</h2><p><span class="math inline">\(1PB=1024TB\)</span>;</p><p><span class="math inline">\(1TB=1024GB\)</span>;</p><p><span class="math inline">\(1GB=1024MB\)</span>;</p><p><span class="math inline">\(1MB=1024KB\)</span>;</p><p><span class="math inline">\(1KB=1024B\)</span>;</p><p><span class="math inline">\(1B=8bit\)</span>;</p><h2 id="进制转换">进制转换</h2><p>短除法。</p><h2 id="编程语言">编程语言</h2><h3 id="低级语言">低级语言</h3><p>汇编语言，机器语言</p><h3 id="高级语言">高级语言</h3><h4 id="面向对象">面向对象</h4><p><strong>C++,Java,EIFFEL,Simula 67</strong>等。</p><h4 id="面向过程">面向过程</h4><p><strong>C,Fortran</strong>等。</p><h1 id="六二进制相关知识">六、二进制相关知识</h1><h2 id="原码补码反码">原码、补码、反码</h2><ol type="1"><li>原码(原码表示法)：十进制数直接转换来的二进制数。值得注意的是，原码的最高位是符号位：整数为<span class="math inline">\(0\)</span>，负数为 <spanclass="math inline">\(1\)</span>。</li><li>补码：正数的补码是其本身，复数的补码是其反码加一。</li><li>反码：正数的反码是本身，负数的反码是<strong>其除符号位之外的所有位按位取反的结果</strong>。</li></ol><h1 id="七运算相关知识">七、运算相关知识</h1><h2 id="数学运算">数学运算</h2><p>略。</p><h2 id="逻辑运算">逻辑运算</h2><ol type="1"><li><p>逻辑与：<span class="math inline">\(\&amp;\&amp;\)</span> 或<span class="math inline">\(∧\)</span>，同 <spanclass="math inline">\(T\)</span> 则 <spanclass="math inline">\(T\)</span>，否则为 <spanclass="math inline">\(F\)</span>。</p></li><li><p>逻辑或：<span class="math inline">\(||\)</span> 或 <spanclass="math inline">\(∨\)</span>，有 <spanclass="math inline">\(T\)</span> 则 <spanclass="math inline">\(T\)</span>，否则为 <spanclass="math inline">\(F\)</span>。</p></li><li><p>逻辑非：<span class="math inline">\(!\)</span> 或 <spanclass="math inline">\(┐\)</span>，为 <spanclass="math inline">\(T\)</span> 则 <spanclass="math inline">\(F\)</span>，反之亦然。</p></li><li><p>逻辑异或：<span class="math inline">\(\text{^}\)</span> 或 <spanclass="math inline">\(⊕\)</span>，同为 <spanclass="math inline">\(F\)</span>，异为 <spanclass="math inline">\(T\)</span>。</p></li></ol><h2 id="位运算">位运算</h2><ol type="1"><li>按位与：<spanclass="math inline">\(\&amp;\)</span>，类似于逻辑与。</li><li>按位或：<span class="math inline">\(|\)</span>，类似于逻辑或。</li><li>按位反：<span class="math inline">\(~\)</span>，类似于逻辑非。</li><li>左移：<span class="math inline">\(&lt;&lt;\)</span>，左移 <spanclass="math inline">\(x\)</span> 位相当于乘 <spanclass="math inline">\(2^x\)</span>。</li><li>右移：<span class="math inline">\(&gt;&gt;\)</span>，右移 <spanclass="math inline">\(x\)</span> 位相当于除 <spanclass="math inline">\(2^x\)</span>。</li></ol><h1 id="八图论理论知识">八、图论理论知识</h1><h2 id="概念">概念</h2><p><strong>图(Graph)</strong> 是一个二元组 <spanclass="math inline">\(G=(V(G),E(G))\)</span>，其中 <spanclass="math inline">\(V(G)\)</span> 为点集，<spanclass="math inline">\(E(G)\)</span> 为边集。</p><p><strong>无向图(Undirected Graph)</strong>，边是双向的。</p><p><strong>有向图(Directed Graph)</strong>，边是单向的。</p><p><strong>自环(Loop)</strong>，对于某条边 <spanclass="math inline">\(e=(u,u)\)</span>，则称其为一个自环。</p><p><strong>重边(Multiple Edge)</strong>，图中存在两个相同的边。</p><p><strong>简单图(Simple Graph)</strong>，一个图中没有自环和重边。</p><p><strong>完全图(CompleteGraph)</strong>，任意两点都有边相连。若一个图的点数为 <spanclass="math inline">\(n\)</span>，则边的个数为 <spanclass="math inline">\(\frac{n(n-1)}{2}\)</span></p><p><strong>平面图</strong>，没有边相交的图。四个点的完全图是一个平面图，五个点的完全图任意去掉一条边都是平面图。</p><p><strong>连通图(Connected Graph)</strong>，任意两点都可以到达。</p><p><strong>有向无环图(DAG)</strong>，顾名思义。它可以拓扑排序。</p><p><strong>树(Tree)</strong>，无向无环连通图，且 <spanclass="math inline">\(n\)</span> 个节点的树有 <spanclass="math inline">\(n-1\)</span> 条边。</p><p><strong>森林(forest)</strong>：每个连通分量（连通块）都是树的图。按照定义，一棵树也是森林。</p><p><strong>结点的深度(depth)</strong>：到根结点的路径上的边数。</p><p><strong>树的高度(height)</strong>：所有结点的深度的最大值。</p><p><strong>叶结点（leaf node）</strong>：没有子结点的结点。</p><p><strong>父亲（parentnode）</strong>：对于除根以外的每个结点，定义为从该结点到根路径上的第二个结点。</p><p><strong>祖先（ancestor）</strong>：一个结点到根结点的路径上，<strong>包括它本身</strong>的所有节点。</p><p>其余参考<ahref="https://oi-wiki.org/graph/tree-basic/">OI-Wiki:树</a>，<ahref="https://oi-wiki.org/graph/concept/">OI-Wiki:图</a>。</p><p><del>图论怎么这么多基础概念</del>。</p><h2 id="二叉树">二叉树</h2><p>先序遍历：根—左—右。</p><p>中序遍历：左—根—右。</p><p>后序遍历：左—右—根</p><h1 id="九基础数据结构理论知识">九、基础数据结构理论知识</h1><h2 id="栈">栈</h2><p><strong>先进后出(FILO,First In LastOut)</strong>，可以想象成一个竖立的木桶。</p><p>后缀表达式：可以用栈实现。</p><h2 id="队列">队列</h2><p><strong>先进先出(FIFO,First In FirstOut)</strong>，可以想象成一个队列。</p><p>双端队列、优先队列、单调队列略。</p><h2 id="链表">链表</h2><p>访问元素时间复杂度为 <spanclass="math inline">\(O(n)\)</span>，但是删除元素时间复杂度为 <spanclass="math inline">\(O(1)\)</span>。</p><h1 id="十排列组合">十、排列组合</h1><h2 id="排列数">排列数</h2><p>从 <span class="math inline">\(n\)</span> 个不同的元素中任取 <spanclass="math inline">\(m\)</span> 个元素的所有排列的个数，记作 <spanclass="math inline">\(P_{n}^{m}\)</span>。</p><p><span class="math display">\[P_{n}^{m} =\frac{n!}{(n-m)!}\]</span></p><h2 id="组合数">组合数</h2><p>从 <span class="math inline">\(n\)</span> 个不同元素中，任取 <spanclass="math inline">\(m\)</span> 个元素并成一组，记作 <spanclass="math inline">\(C_{n}^{m}\)</span>。</p><p><span class="math display">\[C_{n}^{m} =\frac{n!}{m!(n-m)!}\]</span></p><h2 id="加法原理和乘法原理">加法原理和乘法原理</h2><p>感性理解。</p><h2 id="题目中的技巧">题目中的技巧</h2><h3 id="插入法">插入法</h3><p>例：学校师生合影，共 <span class="math inline">\(8\)</span>个学生，<span class="math inline">\(4\)</span>个老师，要求老师在学生中间，且老师互不相邻，共有多少种不同的合影方式？</p><p>解：先排学生共有 <span class="math inline">\(P_{8}^{8}\)</span>种排法，然后把老师插入学生之间的空档，共有 <spanclass="math inline">\(7\)</span> 个空档可插，选其中的 <spanclass="math inline">\(4\)</span> 个空档,共 <spanclass="math inline">\(P_{7}^{4}\)</span>种选法。根据乘法原理，共有的不同坐法 <spanclass="math inline">\(P_{8}^{8}P_{7}^{4}\)</span> 种。</p><h3 id="捆绑法">捆绑法</h3><p>例：<span class="math inline">\(5\)</span> 个男生 <spanclass="math inline">\(3\)</span> 个女生排成一排，<spanclass="math inline">\(3\)</span>个女生要排在一起，有多少种不同的排法？</p><p>解：因为女生要排在一起，所以可以将 <spanclass="math inline">\(3\)</span> 个女生看成是一个人，与 <spanclass="math inline">\(5\)</span> 个男生作全排列，有 <spanclass="math inline">\(P_{6}^{6}\)</span> 种排法，其中女生内部也有 <spanclass="math inline">\(P_{3}^{3}\)</span> 种排法，根据乘法原理，共有<span class="math inline">\(P_{6}^{6}P_{3}^{3}\)</span>种不同的排法。</p><h3 id="剩余法">剩余法</h3><p>反过来。</p><h3 id="对等法">对等法</h3><p>例：学校安排考试科目 <span class="math inline">\(9\)</span>门，语文要在数学之前考，有多少种不同的安排顺序?</p><p>解：不加任何限制条件，整个排法有 <spanclass="math inline">\(P_{9}^{9}\)</span>种，“语文安排在数学之前考”与“数学安排在语文之前考”的排法是相等的，所以语文安排在数学之前考的排法共<span class="math inline">\(\frac{1}{2}P_{9}^{9}\)</span>种。</p><h1 id="十一时空复杂度相关">十一、时空复杂度相关</h1><h2 id="时间复杂度">时间复杂度</h2><p>时间复杂度的计算，简而言之就是计算循环层数。</p><p>例如对于下列代码段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    ans++;</span><br></pre></td></tr></table></figure><p>这里套用了两层到 <span class="math inline">\(n\)</span>的循环，所以说时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span>。</p><p>常见的时间复杂度计算：</p><ul><li>二分类：<span class="math inline">\(O(\log n)\)</span>；</li><li>搜索类：<span class="math inline">\(O(感性理解)\)</span>；</li><li>乱搞类：<span class="math inline">\(O(能过)\)</span>。</li></ul><p>值得注意的是，计算时间复杂度一般忽略其中的常数因子。</p><p>如：一个算法的时间复杂度为 <spanclass="math inline">\(O(2n)\)</span>，则一般写成 <spanclass="math inline">\(O(n)\)</span>。</p><p>这也是 OIer 常说的 <strong>大常数</strong>的由来。常数因子有时也可能导致 <spanclass="math inline">\(TLE\)</span>，这就是 <strong>卡常</strong>的由来。</p><p><del>扯远了</del></p><p>其余更多复杂的时间复杂度可以参考<strong>《具体数学》渐进式</strong>。</p><h2 id="空间复杂度">空间复杂度</h2><p>类似于时间复杂度，即数组的大小。</p><p>例如对于下列代码段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[n];</span><br><span class="line"><span class="type">int</span> b[n][n];</span><br></pre></td></tr></table></figure><p><code>a</code>数组的空间复杂度是 <spanclass="math inline">\(O(n)\)</span>，<code>b</code>数组的空间复杂度是<span class="math inline">\(O(n^2)\)</span>。</p><h2 id="常见基础算法的时空复杂度">常见基础算法的时空复杂度</h2><p>为了方便，前面均为时间复杂度，后面均为空间复杂度。</p><p>有些算法不提供空间复杂度，用 <span class="math inline">\(-\)</span>表示。</p><ol type="1"><li><span class="math inline">\(Dijkstra(无优化)\)</span>：<spanclass="math inline">\(O(n^2),-\)</span>；</li><li><span class="math inline">\(Dijkstra(堆优化)\)</span>：<spanclass="math inline">\(O(n+m)\log n,-\)</span>；</li><li><span class="math inline">\(SPFA\)</span>：<spanclass="math inline">\(\text{Worst}O(|V|\cdot|E|),-\)</span>；</li><li><span class="math inline">\(Floyd\)</span>：<spanclass="math inline">\(O(n^3),-\)</span>；</li><li><span class="math inline">\(0/1背包\)</span>：<spanclass="math inline">\(O(VN),O(VN)\)</span>;</li><li><span class="math inline">\(KMP\)</span>：<spanclass="math inline">\(O(m+n)\)</span>。</li></ol><h2 id="排序算法的时间复杂度与稳定性">排序算法的时间复杂度与稳定性</h2><table><thead><tr class="header"><th style="text-align: center;">排序方法</th><th style="text-align: center;">时间复杂度</th><th style="text-align: center;">稳定性</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">插入排序</td><td style="text-align: center;"><spanclass="math inline">\(O(n^2)\)</span></td><td style="text-align: center;">稳定</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">冒泡排序</td><td style="text-align: center;"><spanclass="math inline">\(O(n^2)\)</span></td><td style="text-align: center;">稳定</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">选择排序</td><td style="text-align: center;"><spanclass="math inline">\(O(n^2)\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">快速排序</td><td style="text-align: center;"><span class="math inline">\(期望O(n\logn)\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">希尔排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">堆排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">归并排序</td><td style="text-align: center;"><span class="math inline">\(O(n\logn)\)</span></td><td style="text-align: center;">稳定</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">基数排序</td><td style="text-align: center;"><spanclass="math inline">\(O(d(n+r))\)</span></td><td style="text-align: center;">稳定</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">桶排序</td><td style="text-align: center;"><span class="math inline">\(O(\max\{value\})\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><del>猴子排序</del></td><td style="text-align: center;"><spanclass="math inline">\(O(1)-O(∞)\)</span></td><td style="text-align: center;">不稳定</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><del>欧皇排序</del></td><td style="text-align: center;"><spanclass="math inline">\(O(\text{NULL})\)</span></td><td style="text-align: center;">稳定</td><td style="text-align: center;"></td></tr></tbody></table><h1 id="十二概率与期望">十二、概率与期望</h1><p><del>不会</del></p><h1 id="十三阅读程序与补全程序相关">十三、阅读程序与补全程序相关</h1><ol type="1"><li>先看有没有注释，<del>没有注释的都是屑</del>；</li><li>猜测变量名称，猜测变量的作用；</li><li>自己阅读每个语句，理解其作用；</li><li>理解代码段的作用；</li><li>根据样例猜测作用；</li><li>手玩几组数据，模拟代码作用；</li><li>认真审题，细致思考。</li></ol><h1 id="十四总结">十四、总结</h1><p>个人认为前面的计算机基础知识背背即可，重点放在<strong>排列组合题</strong> 和 <strong>阅读/补全程序题</strong>上，多刷初赛原题。</p><p>考场上不要慌张，时间充足，充分利用时间，多检查几遍，<del>不会的看顺眼的蒙</del>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NOIP 初赛知识点整理。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://summace.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
